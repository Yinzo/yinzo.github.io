<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>untagged on 雪地</title>
    <link>https://yinzo.github.io/tags/untagged/</link>
    <description>Recent content in untagged on 雪地</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn-zh</language>
    <lastBuildDate>Wed, 01 Mar 2017 17:04:00 +0800</lastBuildDate>
    
	<atom:link href="https://yinzo.github.io/tags/untagged/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>原始模型优化笔记</title>
      <link>https://yinzo.github.io/posts/%E5%8E%9F%E5%A7%8B%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 01 Mar 2017 17:04:00 +0800</pubDate>
      
      <guid>https://yinzo.github.io/posts/%E5%8E%9F%E5%A7%8B%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0/</guid>
      <description>原始模型优化笔记  400:Nice at epoch 38, validation acc 96.56% 200:Nice at epoch 37, validation acc 95.22% 100:Nice at epoch 34, validation acc 94.78%单轮训练时间与50维相近，测试样例测试耗时 0.92secs 50:Nice at epoch 40, validation acc 94.39%单轮训练时间在7秒左右，测试样例(av 8365806)测试耗时 0.7secs  在两个 conv 层之间和两个 fc 层之间各加入了一个 \(p=0.5\) 的 dropout
40 epoch 时只有 89.1 acc， 和预想的一样，会导致 达到最佳效果的 epoch 数上升。
用了 dropout 后一个很明显的变化是，原本训练过程中通常是train acc 高于 validation acc，现在通常是 validation acc 高于 train acc，训练后期才基本持平或反超
vector在 epoch 90 左右 达到了96.50%上下的 acc，最终在epoch 300 以上能达到 97.</description>
    </item>
    
    <item>
      <title>低素质弹幕分类器 CNN 训练笔记</title>
      <link>https://yinzo.github.io/posts/%E4%BD%8E%E7%B4%A0%E8%B4%A8%E5%BC%B9%E5%B9%95%E5%88%86%E7%B1%BB%E5%99%A8-cnn-%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 06 Feb 2017 14:48:00 +0800</pubDate>
      
      <guid>https://yinzo.github.io/posts/%E4%BD%8E%E7%B4%A0%E8%B4%A8%E5%BC%B9%E5%B9%95%E5%88%86%E7%B1%BB%E5%99%A8-cnn-%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/</guid>
      <description>低素质弹幕分类器 CNN 训练笔记 完成训练后，乍一看准确率很高，结果 print 出来看一下，低素质弹幕完全没有被过滤，完全是将分类全部丢给 positive 达到的高准确率 (0.98) 的确是 meaningless classification
并且这个结果在loss里看得很清楚，loss一直是处于15+的
尝试增加第二个卷积层的节点数，然而训练并没有明显变好
然后加大了FC层的隐节点，瞬间loss开始猛降，最后降到了0.3左右，print 出来一看，的确效果不错，但是有一部分语句较短的低素质的弹幕没有被识别出来。
然后由于感觉最后一次迭代没有收敛到极致，尝试加大迭代次数看看这个模型的极限如何。
设置迭代100次后。
Epoch 100/100 2999/2999 [==============================] - 9s - loss: 3.7457e-04 - acc: 1.0000  虽然 acc 和 loss 都到了令人发指的地步，但是发现训练集和测试集忘记shuffle了。。
但是还是看了一眼测试结果，骂人弹幕的识别率为意料之中的0，因为全都被判定为普通弹幕了。shuffle之后重新训练看看吧，先迭代10次，看看效果，然后再测试100次的过拟合程度
10次的结果是准确率在92.45左右，人工检测的结果还可以，检测出了一部分，但是不够理想，调整的迭代20次看看。
Epoch 20/20 2999/2999 [==============================] - 9s - loss: 0.0689 - acc: 0.9810 Correct: 1918 Incorrect: 83 Accuracy: 95.852  人工检测结果有所提升，但是仍然不够理想，提高到50次看看
Epoch 50/50 2999/2999 [==============================] - 9s - loss: 6.4179e-04 - acc: 1.0000 Correct: 1963 Incorrect: 38 Accuracy: 98.</description>
    </item>
    
    <item>
      <title>低素质弹幕分类器的CNN实现</title>
      <link>https://yinzo.github.io/posts/%E4%BD%8E%E7%B4%A0%E8%B4%A8%E5%BC%B9%E5%B9%95%E5%88%86%E7%B1%BB%E5%99%A8%E7%9A%84cnn%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Mon, 06 Feb 2017 14:48:00 +0800</pubDate>
      
      <guid>https://yinzo.github.io/posts/%E4%BD%8E%E7%B4%A0%E8%B4%A8%E5%BC%B9%E5%B9%95%E5%88%86%E7%B1%BB%E5%99%A8%E7%9A%84cnn%E5%AE%9E%E7%8E%B0/</guid>
      <description>低素质弹幕分类器的CNN实现 对于一条弹幕，首先进行分词，然后通过 word2vec 转换为词向量，再填充至固定长度，作为卷积神经网络的输入。
卷积神经网络的结构如下：
最终输出为2位的 categorical result，直接使用第一项，即骂人弹幕的概率作为输出。
然后通过代理，在弹幕服务器与播放器之间插入一层，实现弹幕的分类与屏蔽。最终实现了有效的骂人弹幕自动屏蔽，但是误伤的情况依然存在。
使用游戏区的所有弹幕来训练 word2vec model。这里我是用的是 word2vec 的 Python 实现 gensim
训练脚本来自这篇文章 中英文维基百科语料上的Word2Vec实验
然后，我从所有弹幕中随机抽取了5000条，进行人工标注分类，其中有63条骂人弹幕。由于骂人弹幕太少，我又通过关键词搜索加人工筛选的方式，增加了4000条骂人弹幕。
以这约9000条弹幕作为训练样本，80%的弹幕作为 train set， 其余的20%作为 validation set
对训练样本进行预处理：
 分词 转换为词向量 填充至100位长，其中填充的位的词向量全部置零。  开始构建卷积神经网络，我选用的框架是使用 TensorFlow 后端的 keras。最终经过调试，得到这样一个结构
具体的训练过程可以看这里
需要注意的是，model.fit 指定了 class weight
单次训练迭代时间约25秒，我总共迭代了20次。其中每次迭代我都将 model 保存到一个列表中，并使用当前 model 对验证集进行测试，输出测试结果。
然后根据测试结果，选用了第3次迭代的 model ，尝试使用新的，不在样本中的视频弹幕进行人工检验识别效果。
选用视频 av8365806 里面存在大量对骂的弹幕，适合进行测试
这里我花了小半天时间，用 tornado 搭了个服务器，模拟 comment.bilibili.com 的所有请求，其中对于弹幕的请求，插入一层封装好的神经网络模型进行分类，再返回给用户请求，其余请求直接转发。搭建好后通过 Surge 的 URL Rewrite 将请求转到本地服务器上。
然后此时访问弹幕都会先经过本地服务器进行处理了。查看 av8365806 的弹幕分类情况：
首先是比较欣慰的结果，大部分直接用脏字喷人的弹幕都被高确信地识别出来了
其次，存在一些短弹幕被误伤的情况，而且确信度还莫名的挺高
然后，依然存在一部分弹幕脏字不明显，以及一些反讽的语句没有识别出来
另外由于3000弹幕的识别时间在5秒左右，再加上网络延迟以及一些预处理后处理的时间，整体延迟约10秒，所以这个代理服务器可能还没能达到投入大规模使用的效率，比较可惜。
但是其识别效果，对于日常观感绝对是有所提升的。</description>
    </item>
    
    <item>
      <title>在 Linode 上编译 hybla 模块</title>
      <link>https://yinzo.github.io/posts/%E5%9C%A8-linode-%E4%B8%8A%E7%BC%96%E8%AF%91-hybla-%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Tue, 27 Dec 2016 23:22:00 +0800</pubDate>
      
      <guid>https://yinzo.github.io/posts/%E5%9C%A8-linode-%E4%B8%8A%E7%BC%96%E8%AF%91-hybla-%E6%A8%A1%E5%9D%97/</guid>
      <description>在 Linode 上编译 hybla 模块 执行到这一步时运行出错
Google 一番后发现是缺少 tcp_hybla 模块，需要自己手动编译。引用一下 https://plus.google.com/+BoluoKING/posts/dLyYhBf3mwp 的科普
 中美之间的线路质量不是很好，rtt较长且时常丢包。TCP的设计目的是解决不可靠线路上可靠传输的问题，即为了解决丢包，但丢包却使TCP传输速度大幅下降。HTTP协议在传输层使用的是TCP协议，所以网页下载的速度就取决于TCP单线程下载的速度（因为网页就是单线程下载的）。丢包使得TCP传输速度大幅下降的主要原因是丢包重传机制，控制这一机制的就是TCP拥塞控制算法。
Linux内核中提供了若干套TCP拥塞控制算法，这些算法各自适用于不同的环境。
1）reno是最基本的拥塞控制算法，也是TCP协议的实验原型。
2）bic适用于rtt较高但丢包极为罕见的情况，比如北美和欧洲之间的线路，这是2.6.8到2.6.18之间的Linux内核的默认算法。
3）cubic是修改版的bic，适用环境比bic广泛一点，它是2.6.19之后的linux内核的默认算法。
4）hybla适用于高延时、高丢包率的网络，比如卫星链路——同样适用于中美之间的链路。
我们需要做的工作就是将TCP拥塞控制算法改为hybla算法，并且优化TCP参数。
 于是又开始找 hybla 模块的编译指南，参考了这两篇文章，并且修改了一下不太明确的地方，写个修改版的指南吧。
 Linode编译hybla htcp模块 Linode编译hybla htcp拥塞控制算法模块  在这里下载 https://www.kernel.org/pub/linux/kernel/
我这里是 4.8.3，于是进入 v4.x 目录，向下翻即找到了，复制文件地址，在vps上 wget 下载下来
注意修改对应的下载地址和文件名
然后用你喜欢的编辑器编辑 .config 文件，查找 CONFIG_TCP_CONG_CUBIC=y，在这一行下面增加一行
CONFIG_TCP_CONG_HYBLA=y  然后编译
编译耗时约15~20分钟
以下是 hybla 所用的 Makefile
# Makefile for tcp_hybla.ko obj-m := tcp_hybla.o KDIR := /tmp/kernel/linux-4.8.3 PWD := $(shell pwd) default: $(MAKE) -C $(KDIR) SUBDIRS=$(PWD) modules  注意上面__第三行 KDIR := /root/kernel/linux-3.</description>
    </item>
    
    <item>
      <title>无需手动缓存长度</title>
      <link>https://yinzo.github.io/posts/%E6%97%A0%E9%9C%80%E6%89%8B%E5%8A%A8%E7%BC%93%E5%AD%98%E9%95%BF%E5%BA%A6/</link>
      <pubDate>Wed, 27 Jul 2016 17:13:00 +0800</pubDate>
      
      <guid>https://yinzo.github.io/posts/%E6%97%A0%E9%9C%80%E6%89%8B%E5%8A%A8%E7%BC%93%E5%AD%98%E9%95%BF%E5%BA%A6/</guid>
      <description>无需手动缓存长度 其中数据集是一个List。看到这里说到为了提高代码效率，特地开了一个变量来保存其长度。
我回忆起以前调试bug的时候，总是能看到List对象里面有一个函数__len__，想必Python对于这种常用函数会有所优化，对于这种集合类型的对象，如果对其长度进行缓存，这样多次调用len函数，就不会重复进行遍历计算了。这么简单的优化，Python必然是有做的。
于是去Google，原本准备搜len函数的具体实现代码，结果直接找到stackoverflow有相关问题，明确的验证了我的想法。
对于这种类型，Python都会对其长度进行缓存。也就是说，对于len函数，只在第一次调用的时候复杂度为O(N)，后续调用的复杂度都是常数级的。所以，我们平时写代码的时候，可以不需要多此一举的再开一个单独的变量来缓存了。也就是说，以下代码在没有特殊需求的情况下，是多此一举的：
  </description>
    </item>
    
    <item>
      <title>使用 Python 装饰器来将普通函数加入任务队列</title>
      <link>https://yinzo.github.io/posts/%E4%BD%BF%E7%94%A8-python-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%9D%A5%E5%B0%86%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%8A%A0%E5%85%A5%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/</link>
      <pubDate>Thu, 14 Jul 2016 23:41:00 +0800</pubDate>
      
      <guid>https://yinzo.github.io/posts/%E4%BD%BF%E7%94%A8-python-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%9D%A5%E5%B0%86%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%8A%A0%E5%85%A5%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/</guid>
      <description>使用 Python 装饰器来将普通函数加入任务队列 首先，我们先声明了一个 namedtuple ，其中包含以下几个元素：
 func ：需要加入任务队列的目标函数对象 args 和 kwargs ：目标函数对象的参数 result_obj ：用于保存目标函数返回值的一个字典， 装饰器函数将目标函数加入任务队列之后，会直接返回一个{&#39;result&#39;: None, &#39;done&#39;: False}的字典。等到目标函数异步执行完成之后， Worker 会用返回值替换这一字典的result，并设置done为True  Worker 和普通的 Consumer 定义基本没有区别，唯一要注意的地方是，记得要用函数返回值，替换掉任务返回值字典的&#39;result&#39;，并修改任务状态，即
同样是比较标准的 Producer ，其中queue_up函数就是这次的主角了。对于目标函数，先构建一个返回值字典，然后将目标函数和参数加入任务队列，最后返回这一返回值字典。非常简单的结构，但是使用起来非常的方便。
这里我构造了一个用来测试的代码
读者可以尝试删除掉some_operation函数前面的装饰器，对比有无这个装饰器对程序运行的影响。
可以看到，对于需要测试的some_operation函数，我仅仅是在其定义前加上了一个装饰器的调用，就使得这个函数的执行不会阻塞主线程了。并且对于异步调用函数的返回值，也很好的进行了保留传递。</description>
    </item>
    
    <item>
      <title>关于Python的logging模块初始化无效的一个小坑</title>
      <link>https://yinzo.github.io/posts/%E5%85%B3%E4%BA%8Epython%E7%9A%84logging%E6%A8%A1%E5%9D%97%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%A0%E6%95%88%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9D%91/</link>
      <pubDate>Tue, 19 Apr 2016 23:45:00 +0800</pubDate>
      
      <guid>https://yinzo.github.io/posts/%E5%85%B3%E4%BA%8Epython%E7%9A%84logging%E6%A8%A1%E5%9D%97%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%A0%E6%95%88%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9D%91/</guid>
      <description>关于Python的logging模块初始化无效的一个小坑 一般使用logging模块都会对其进行初始化，使用以下代码：
 log_format = &#39;[%(levelname)s] %(asctime)s %(filename)s line %(lineno)d: %(message)s&#39; date_fmt = &#39;%a, %d %b %Y %H:%M:%S&#39; logging.basicConfig( format=log_format, datefmt=date_fmt, level=log_level, )  或者，只是简单使用，可以不初始化，直接logging.info(&amp;quot;blablabla&amp;quot;)
但是，如果当你先直接不初始化logging设置，直接输出之后，你再尝试初始化，你的设置将不会不会生效。尝试以下代码
# -*- coding: utf-8 -*- import logging def init_logging(log_level=logging.INFO): log_format = &#39;[%(levelname)s] %(asctime)s %(filename)s line %(lineno)d: %(message)s&#39; date_fmt = &#39;%a, %d %b %Y %H:%M:%S&#39; logging.basicConfig( format=log_format, datefmt=date_fmt, level=log_level, ) if __name__ == &#39;__main__&#39;: logging.critical(&amp;quot;critical&amp;quot;) logging.warning(&amp;quot;warning&amp;quot;) logging.info(&amp;quot;info&amp;quot;) logging.debug(&amp;quot;debug&amp;quot;) init_logging(logging.DEBUG) print &amp;quot;\n&amp;quot; print &amp;quot;initial finished.&amp;quot; print &amp;quot;\n&amp;quot; logging.</description>
    </item>
    
    <item>
      <title>Python Decorator的一些细节</title>
      <link>https://yinzo.github.io/posts/python-decorator%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/</link>
      <pubDate>Thu, 31 Mar 2016 19:14:00 +0800</pubDate>
      
      <guid>https://yinzo.github.io/posts/python-decorator%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/</guid>
      <description>Python Decorator的一些细节 而且当一个文件（模块）被import的时候，文件内的__所有__装饰器就会被激活执行。因为装饰器语句相当于文件中的普通语句，而非函数声明或者类声明的一部分。
用以下代码方便理解：
# sample.py def decorator_function(func): print &amp;quot;executing the decorator.&amp;quot; def wrapper(*args, **kwargs): print &amp;quot;decorated function is executing.&amp;quot; return func(*args, **kwargs) return wrapper print &amp;quot;this python file is executing.&amp;quot; @decorator_function def test_function(sth): print &amp;quot;blablabla&amp;quot;+sth test_function(&amp;quot;yeah&amp;quot;)  而当我们对一个类里面的普通函数使用修饰符进行修饰的时候，然后我们正常调用这一函数（通过实例化的对象调用），会报错提示这一函数变成了unbound method，缺少了类中函数默认的首参数self。这一问题是由于经过装饰器修饰的函数，实际上是被传递到了装饰器函数中，在这个装饰器函数中被独立调用的，而非被其原先所在的类对象调用。因此在这个装饰器函数中，没有其原来所在的类来对它进行调用，导致提示unbound method.</description>
    </item>
    
    <item>
      <title>通过EMET来禁用EMET——EMET的禁用与绕过思路讲解</title>
      <link>https://yinzo.github.io/posts/%E9%80%9A%E8%BF%87emet%E6%9D%A5%E7%A6%81%E7%94%A8emetemet%E7%9A%84%E7%A6%81%E7%94%A8%E4%B8%8E%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF%E8%AE%B2%E8%A7%A3/</link>
      <pubDate>Sun, 27 Mar 2016 11:46:00 +0800</pubDate>
      
      <guid>https://yinzo.github.io/posts/%E9%80%9A%E8%BF%87emet%E6%9D%A5%E7%A6%81%E7%94%A8emetemet%E7%9A%84%E7%A6%81%E7%94%A8%E4%B8%8E%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF%E8%AE%B2%E8%A7%A3/</guid>
      <description>通过EMET来禁用EMET——EMET的禁用与绕过思路讲解 微软的Enhanced Mitigation Experience Toolkit (EMET)是一项提高程序安全性的项目。它通过动态链接库(DLL)来运行在『受保护』的程序中，并且做一些修改来使得破解更加困难。
我们已经见过很多次EMET在过去的研究或者攻击中被绕过了[2, 3, 4, 5, 6, 7, 8]。通常来说，微软都是通过修改或者增加一些安全设计来搞定现有的绕过问题。 EMET的设计目的是使得破解行为的成本升高，而不是一个『傻瓜式的防破解方案』[1]。所以，只要拥有在进程空间中读写的能力，理论上我们就能搞定所有的安全设计[2]。
如果一个攻击者能够毫不费力地绕过EMET，那这就完全打破了EMET提高破解成本的最初目的。我们在新技术那段展示了一种禁用EMET的技术。微软在EMET5.5中打了个补丁来解决这个问题。
讨论完这个新技术之后，我们来说说之前提到的用来绕过或搞掉EMET的那个技术。如果你想了解关于EMET是怎么实现保护程序的，请参考附录。
EMET会根据系统的架构，来选择注入emet.dll还是emet64.dll到每一个被保护的进程中，以此在Windows API（比如kernel32.dll, ntdll.dll或者kernelbase.dll里面的函数）hook上。这些hook使得EMET能够分析所有通过关键API调用的代码，并判断他们是否合法。如果代码被认为是合法的，EMET的hook会跳回请求的API处，否则会触发一个exception。
但是，EMET里面存在着这样一段代码用来卸载EMET。这段代码整个禁用EMET的保护，并且把受保护的程序还原为无保护的初始状态。任何人都能简单地定位这段代码，并调用它，就能够完全禁用EMET的保护。在EMET.dll v5.2.0.1中这个函数位于0x65813中，跳到这段代码上并调用它就能弄掉EMET的hooks。
这一特性之所以存在，是因为emet.dll里面的用于完全退出进程的代码，为了方便，而在DllMain里面留了个入口。
DllMain的函数原型：
BOOL WINAPI DllMain( _In_ HINSTANCE hinstDLL, _In_ DWORD fdwReason, _In_ LPVOID lpvReserved );  需要注意的是，第一个参数传递是DLL的地址，第二个是PE loader用来指明DLL是否被加载。如果fdwReason是1，说明DLL已经被加载或者初始化。如果是0（DLL_PROCESS_DETACH），emet.dll会初始化卸载的代码，并去除它的hook和exception处理句柄，轻而易举地停止了EMET的检查。不过这并不会把EMET从内存中移除，它只是确保了所有的保护都被禁用了。
这种特性可能存在与所有基于探测的产品之中，也就是那些依赖hook的并以此保证产品不被破坏，一定存在一个卸载所有保护的方法。EMET的DllMain能够通过一个Return Oriented Programming (ROP)程序来找到，并带着正确的参数跳到DllMain的对应位置，禁用保护。这个我们下一节来详细说。
BOOL WINAPI DllMain (GetModuleHandleW(&amp;quot;EMET.dll&amp;quot;) ,DLL_PROCESS_DETACH , NULL);  GetModuleHandleW函数没有被EMET hook上，因为EMET认为它不是关键Windows API。我们使用这个函数来搞到emet.dll的地址。因为PE header位于基地址上，我们必须通过它找到DllMain的地址来传递所需的参数。
在EMET.dll v5.2.0.1中，在emet.dll的0xF2958上有一个全局变量。EMET通过这个变量作为一个structure数组指针，指向被绕过的API（detoured APIs），每一个结构体的大小为0x18 bytes，如下所示：
struct Detoured_API { BOOL isActive; // isActive field shows the hooking status, Active: 0x1 PVOID DetouredAPIConfig; // pointer to Detoured_API_Config structure PVOID nextDetouredAPI; // pointer to the next Detoured_API structure DWORD valueX; DWORD valueY; DWORD valueZ; };  最后三个变量和这篇文章没有关系。DetouredAPIConfig保存着一个指针指向另一个结构体Detoured_API_Config，大小是0x18 bytes.</description>
    </item>
    
    <item>
      <title>Ideas for Neural Network</title>
      <link>https://yinzo.github.io/posts/ideas-for-neural-network/</link>
      <pubDate>Fri, 04 Mar 2016 20:44:00 +0800</pubDate>
      
      <guid>https://yinzo.github.io/posts/ideas-for-neural-network/</guid>
      <description>Ideas for Neural Network * automatically find and make training set from search engine * the paremeters include: * learning rate * iteration times * regularization term \\(\\lambda\\) * activation function * number of hidden layers(units)   About MCS, maybe we can train a model for fusion method to do the judge.  </description>
    </item>
    
    <item>
      <title>Notes for Neural Network</title>
      <link>https://yinzo.github.io/posts/notes-for-neural-network/</link>
      <pubDate>Thu, 03 Mar 2016 00:57:00 +0800</pubDate>
      
      <guid>https://yinzo.github.io/posts/notes-for-neural-network/</guid>
      <description>Notes for Neural Network    If we set the initial \\(\\Theta\\) be the same, the units in next layer with the same \\(x\_i\\) will get the same result, then all units in the same layer will get the same output. At last, the cost function will also get same cost, so we will update the \\(\\Theta\\) with same step.     seems \\(\\delta^{(l)}\_{i}\\) means the cost of \\(i\_{th}\\) unit in the \\(l\_{th}\\) layer    How to decide the iteration times</description>
    </item>
    
    <item>
      <title>Note for &lt;Thesis - Behavior of Machine Learning Algorithms in Adversarial Environments.pdf&gt;(1)</title>
      <link>https://yinzo.github.io/posts/note-for-thesis-behavior-of-machine-learning-algorithms-in-adversarial-environments.pdf1/</link>
      <pubDate>Thu, 04 Feb 2016 16:55:00 +0800</pubDate>
      
      <guid>https://yinzo.github.io/posts/note-for-thesis-behavior-of-machine-learning-algorithms-in-adversarial-environments.pdf1/</guid>
      <description>Note for &amp;ldquo;Thesis - Behavior of Machine Learning Algorithms in Adversarial Environments.pdf&amp;rdquo;(1)  The process is too complex to designed for human operator Requirement of dynamical development   Alter his approach based on knowledge of the learner’s shortcomings Mislead it by cleverly crafting data to corrupt Deceive the learning process   An attacker can exploit the nature of a machine learning system to mis-train it and cause it to fail   What techniques can a patient adversary use to mis-train or evade a learning system?</description>
    </item>
    
    <item>
      <title>封装，与协议的分层</title>
      <link>https://yinzo.github.io/posts/%E5%B0%81%E8%A3%85%E4%B8%8E%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%86%E5%B1%82/</link>
      <pubDate>Fri, 29 Jan 2016 18:41:00 +0800</pubDate>
      
      <guid>https://yinzo.github.io/posts/%E5%B0%81%E8%A3%85%E4%B8%8E%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%86%E5%B1%82/</guid>
      <description>封装，与协议的分层 要理解协议的分层，若是了解编程理念中的『封装』，可能更有助于理解分层的意义。
『封装』，狭义上指的是编写程序时，通过把一些重复操作的代码写成一个单独的函数，这就可以叫做一个简单的封装。
而我对于封装的理解，举个例子，当你忙了一天回到家，站在你的家门口，想要打开你家的房门时，你需要做以下事情：
步骤很多，对不对。不过这个描述也没错，我们的确需要做出这些步骤才能开门。
但是，我们和别人聊天的时候，你想要告诉别人你昨天很累，回到家马上就睡觉了，你会说『昨天我回到家门口，掏出钥匙，找到对应的钥匙……』吗？
我想大部分人都不会的。
我会说『昨天我回到家门口，打开门，马上就进到卧室睡觉了』，这实际上就是一个封装，我们把这些步骤封装成了一个『开门』的步骤。
看到这里你可能已经大概感觉到了，封装，实际上是把一些步骤，打包整合，使它变成了更高层次的行为。看到这里，我觉得我们应该停下来，多思考一会儿关于封装的概念，毕竟这个概念对于理解后面的协议分层非常关键，所以，让我们暂时停一下脚步，来观察并思考一下，我们日常生活中，还有哪些东西实际上也是一种封装吧。</description>
    </item>
    
    <item>
      <title>网络协议</title>
      <link>https://yinzo.github.io/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Fri, 29 Jan 2016 18:40:00 +0800</pubDate>
      
      <guid>https://yinzo.github.io/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</guid>
      <description>网络协议 比如：一个工作需要经过三个步骤，分别是步骤A/步骤B/步骤C。三个步骤分别由三台不同的计算机A/B/C执行。
起初，人们使用容量极小的3.5寸盘，带着要处理的数据来到计算机A面前，执行完之后带着数据分别去B和C前进行操作处理，十分的低效。
使用网络连接三台计算机之后，用户可以在A处理完数据，直接传递给B和C进行处理，再将处理结果传回A即可。
甚至，进一步的发展之后，用户都拥有了自己的计算机，则用户可以在任意一台连接了A的计算机上，比如自己的电脑，直接将数据传递到A、B、C计算机上处理，而无需离开自己的计算机进行操作。这一步的发展，即是当前的互联网。
但是现实中，计算机不仅只由一家公司开发，不同公司的计算机起初只能与自家的计算机进行连接。不同种的计算机无法进行连接交流。就像语言不通的外国人，无法交流。
于是，为了连接不同种类计算机，我们统一了计算机交流的语言。由此，无论你的结构与其他计算机有多不同，只要能够使用这种统一语言，就能加入到互联网这个大聊天室之中，与任何计算机进行通信交流。
这种统一的语言，就是『协议』。
由于各种机缘巧合，TCP/IP协议成为了世界上主流的网络通信协议。</description>
    </item>
    
    <item>
      <title>Notes for &lt;ICMLC2009-FabioRoli.pdf&gt;</title>
      <link>https://yinzo.github.io/posts/notes-for-icmlc2009-fabioroli.pdf/</link>
      <pubDate>Fri, 29 Jan 2016 14:14:00 +0800</pubDate>
      
      <guid>https://yinzo.github.io/posts/notes-for-icmlc2009-fabioroli.pdf/</guid>
      <description>Notes for &amp;ldquo;ICMLC2009-FabioRoli.pdf&amp;rdquo; The Classifier which take the adversary actions into account. It can develop according to the adversary actions.
Its motivations is that the classical model cannot perform well in adversarial environments. Because the classical model is build and set up base on the random noise, it’s also use for normal random noise environment. But in adversarial environment, the noise it face is adversarial noise, which is generated by adversary on purpose.</description>
    </item>
    
    <item>
      <title>2015暑假</title>
      <link>https://yinzo.github.io/posts/2015%E6%9A%91%E5%81%87/</link>
      <pubDate>Wed, 02 Sep 2015 22:03:00 +0800</pubDate>
      
      <guid>https://yinzo.github.io/posts/2015%E6%9A%91%E5%81%87/</guid>
      <description>2015暑假 正式开始学习技术以来的第二个暑假了，上一个暑假的效率之高，可能没有什么机遇的话挺难超越的了。
先放一张这次暑假一开始的计划图以及其完成度。
接下来一一说明
 暑假开始，第一个进行的是SmartQQBot的重构。这时已经回到了家中，主要都是在家里的42寸上完成的，效率不算太高，一个星期3K行左右的Python，主要时间花费在程序模块化逻辑的思考，以及优化二次开发流程上。 接下来，开始花了两天的零散时间整理归纳了自己当前（当时）的技能树，里面漏掉了后端部分中的NodeJS枝，不过也不算很熟练，只是基本入门写了个小东西的水平，也就不追加到博文里了。 深入学习Python。这一部分有少量在重构SmartQQBot的时候就开始了，主要使用廖雪峰的Python2.7教程以及Python Documentation，之所以没有标记为完成是因为没有固定的标准，在我看来Python值得我深入的地方还有很多，所以我选择标记为未完成。 预习下学期内容。这个部分其实算是坑掉了，因为到后期时间不多、精力不够（懒）的原因，只看完了《啊哈！算法》并用Python实现了部分算法就没有深入下去了。 深入学习SQL注入。主要使用Drops的大量注入相关文章，配合DVWA手工注入练习。基本了解了SQL注入的一些原理。（盲注还没来得及下手测试）期间在查阅资料的过程中顺手翻译了两篇文章，发到了Drops捞了一笔。标注为未完成的理由同Python。 Cookie-Pot这个项目被我意外的坑掉了。因为在深入了Python和注入之后，发现自己对于前端的内容是越来越不感兴趣了。这样看来我未来的方向里已经排除掉了前端，顶多作为个人爱好再发展发展了。 之后剩余了2周左右的时间，基本都在慢慢看《数学之美》。原本以为两周能看完的，但是里面NLP的部分完全理解需要的概率论知识我都不太记得了，而且课本没带回家，所以进度非常慢，算法理解度也不甚理想。  除了以上计划中的内容，我还进行了以下活动
 暑假刚开始还没回家的两个星期。在学校接了一（两）单前端外包，大概也是因此对前端失去了部分兴趣。 帮一个师兄的项目写了个简易的前端，算是第一次与他人合作进行配合开发。以前都是自己规划自己写后端自己写前端，没有太多与人合作开发的经历。（这个仍在进行）  大概就是以上所写的内容了，可能有所遗漏，之后想起来再补充。
啊对了，回学校之后还修证了一下博客的样式;D，新样式简洁多了
总的来说效率算中上，完成度为80%。新的学期也有新的目标，希望能够尽快成长为能够实现自己脑中所有构思的人。
2015.09.02</description>
    </item>
    
    <item>
      <title>Oracle注入速查表</title>
      <link>https://yinzo.github.io/posts/oracle%E6%B3%A8%E5%85%A5%E9%80%9F%E6%9F%A5%E8%A1%A8/</link>
      <pubDate>Fri, 28 Aug 2015 17:30:00 +0800</pubDate>
      
      <guid>https://yinzo.github.io/posts/oracle%E6%B3%A8%E5%85%A5%E9%80%9F%E6%9F%A5%E8%A1%A8/</guid>
      <description>Oracle注入速查表 注：下面的一部分查询只能由admin执行，我会在查询的末尾以&amp;rdquo;-priv“标注。
探测版本：
SELECT banner FROM v$version WHERE banner LIKE ‘Oracle%’; SELECT banner FROM v$version WHERE banner LIKE ‘TNS%’; SELECT version FROM v$instance;  注释：
SELECT 1 FROM dual — comment  注: Oracle的SELECT语句必须包含FROM从句，所以当我们并不是真的准备查询一个表的时候，我们必须使用一个假的表名‘dual’
当前用户：
SELECT user FROM dual  列出所有用户：
SELECT username FROM all_users ORDER BY username; SELECT name FROM sys.user$; — priv  列出密码哈希：
SELECT name, password, astatus FROM sys.user$ — priv, &amp;amp;lt;= 10g. astatus能够在acct被锁定的状态下给你反馈 SELECT name,spare4 FROM sys.</description>
    </item>
    
    <item>
      <title>解决Python的pytesseract库执行时报错</title>
      <link>https://yinzo.github.io/posts/%E8%A7%A3%E5%86%B3python%E7%9A%84pytesseract%E5%BA%93%E6%89%A7%E8%A1%8C%E6%97%B6%E6%8A%A5%E9%94%99/</link>
      <pubDate>Sun, 23 Aug 2015 01:42:00 +0800</pubDate>
      
      <guid>https://yinzo.github.io/posts/%E8%A7%A3%E5%86%B3python%E7%9A%84pytesseract%E5%BA%93%E6%89%A7%E8%A1%8C%E6%97%B6%E6%8A%A5%E9%94%99/</guid>
      <description>解决Python的pytesseract库执行时报错 AttributeError: &#39;NoneType&#39; object has no attribute &#39;bands&#39;  修改PIL库site-packages/PIL/Image.py1496行
def split(self): “Split image into bands” if self.im.bands == 1:  为
def split(self): “Split image into bands” self.load() if self.im.bands == 1:  即可。</description>
    </item>
    
    <item>
      <title>SQL注入速查表</title>
      <link>https://yinzo.github.io/posts/sql%E6%B3%A8%E5%85%A5%E9%80%9F%E6%9F%A5%E8%A1%A8/</link>
      <pubDate>Mon, 10 Aug 2015 17:30:00 +0800</pubDate>
      
      <guid>https://yinzo.github.io/posts/sql%E6%B3%A8%E5%85%A5%E9%80%9F%E6%9F%A5%E8%A1%A8/</guid>
      <description>SQL注入速查表 _文档版本：1.4_现在仅支持MySQL、Microsoft SQL Server，以及一部分ORACLE和PostgreSQL。大部分样例都不能保证每一个场景都适用。现实场景由于各种插入语、不同的代码环境以及各种不常见甚至奇特的SQL语句，而经常发生变化。
样例仅用于读者理解对于“可能出现的攻击(a potential attack)”的基础概念，并且几乎每一个部分都有一段简洁的概要
 M: MySQL S: SQL Server P: PostgreSQL O: Oracle +: (大概)其他所有数据库  例子：
 (MS) 代表 : MySQL 和 SQL Server 等 (M*S) 代表 : 仅对某些版本或者某些附在后文中的特殊情况的 MySQL，以及SQL Server   关于SQL注入速查表 语法参考，攻击样例以及注入小技巧 ​   行间注释
  使用了行间注释的SQL注入攻击样例
  行内注释
  使用了行内注释的注入攻击样例
  MySQL版本探测攻击样例
  堆叠查询(Stacking Queries)
  支持堆叠查询的语言/数据库
  关于MySQL和PHP
  堆叠注入攻击样例
  If语句</description>
    </item>
    
    <item>
      <title>个人总结</title>
      <link>https://yinzo.github.io/posts/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 26 Jul 2015 23:55:00 +0800</pubDate>
      
      <guid>https://yinzo.github.io/posts/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</guid>
      <description>个人总结 记录一下技能树里面的具体内容：
 瞎玩Flash    VB自学，初二——高一
 当时在玩无损，写了个cue文件批量修改与格式化的小软件      C#自学，高二——高三
 高三用C#做出一个舒尔特表格的3×3与5×5版本    入门Ubuntu
   自学HTML/CSS/PHP/JavaScript/MySQL 转到Mac平台 建立第一个WordPress博客，自行修改主题。 写出第一个基于JavaScript的小东西：Spin! 一个星期自学JQuery并完成舒尔特表格JS版 入门Python，写出第一个POC，遍历14级新生信息 自学计算机网络   课程学习C++，高分过 水了几次CTF，入门了XSS、了解了CSRF、用工具日了几个SQL注入，成功shell 入手Linode1024 使用Django+MySQL完整搭出个人博客 完成学生信息查询系统 为了更便捷的科学上网以及充分利用VPS，搭建Shadowsocks 完成编写SmartQQ-Bot初版 参加（水）华为杯大学生智能大赛，入门机器学习 完成SmartQQ-Bot失物招领版本 C++课程设计，独立使用MySQL+Qt完成数据库+界面，高分过 基本完成SmartQQ-Bot框架的开发 学习《啊哈！算法》  现在我在用的好多技能，都还是高三毕业那个两个月的暑假学出来的，当时我的效率简直吓哭，比高三那时候疯的多了，一个星期自学完计算机网络什么的现在简直不敢想，3个小时就坐不住了。
之前放假之前说好的完成TODO_list，现在也就搞了搞SmartQQBot框架跟深入Python，效率不堪直视。嗯现在归纳个人技能表也算做好了:D。
之后几天内差不多该回学校了，一堆一堆的书都等着我呢;P</description>
    </item>
    
    <item>
      <title>基于SmartQQ的Python QQ机器人框架</title>
      <link>https://yinzo.github.io/posts/%E5%9F%BA%E4%BA%8Esmartqq%E7%9A%84python-qq%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Tue, 21 Jul 2015 15:44:00 +0800</pubDate>
      
      <guid>https://yinzo.github.io/posts/%E5%9F%BA%E4%BA%8Esmartqq%E7%9A%84python-qq%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%A1%86%E6%9E%B6/</guid>
      <description>基于SmartQQ的Python QQ机器人框架 这是一个原本是自己在看到某一个QQ群中的机器人后，以娱乐的心态写的一个QQ机器人。登陆部分逻辑与代码参考了原名：SmartQQ-for-Raspberry-Pi(PiWebQQV2)这一项目，结合自己的需求写出来的一个以娱乐为主的小玩具。
习惯性地把自己写的小东西发布到Github，意外地发现受到了一定的支持。加上在进一步开发失物招领功能的时候发现代码逻辑有点混乱，于是决定进行一次完全的重构，希望能够开发出一个便于二次开发的QQ机器人框架。
以下为没有重构之前的机器人的README，但是近期（两到三个星期）机器人就将重构，所以以下内容可能会马上过时。
  python QQBot.py 等待提示“登陆二维码下载成功，请扫描”，打开脚本所在目录的v.jpg图片扫描二维码。 等待登陆成功的提示&amp;lt;!–+ 登陆成功后出现&amp;rdquo;&amp;gt;&amp;gt;“表示可输入命令，此时私聊问答功能自动激活，群聊各功能需要手动关注该群才会激活，关注群的命令为group 群号，此命令为控制台命令，不是在qq中发送。–&amp;gt; 修改config文件夹中的QQBot_default.conf配置文件 群聊各功能需要在groupCheckList中添加群号，每行一个，来关注群以激活群功能。  注：以下命令皆是在qq中发送，群聊命令发送到所在群中   群聊学习功能，类似于小黄鸡，在群中通过发送`` !learn {ha}{哈哈} ``语句，则机器人检测到发言中包含“ha”时将自动回复“哈哈”。`` !delete {ha}{哈哈} ``可以删除该内容。学习内容会自动储存在`` groupReplys ``目录中群号.save文件     群聊复读功能，检测到群聊中___连续两个___回复内容相同，将自动复读该内容1次。     群聊关注功能，使用命令`` !follow qq号 ``可以使机器人复读此人所有发言（除命令外）使用命令`` !unfollow qq号 ``解除关注。qq号处可使用&amp;quot;me&amp;quot;来快速关注与解除关注自己，例：`` !follow me ``     私聊问答功能，可以自定义机器人私聊时提出问题，并可储存对方的回复，一般用于自动问卷调查。    logging模块优化分离，保证主程序无任何print输出。私聊与群消息提醒使用单独的文件输出。
  细化配置项（tucao_auth = (all/self/custom/none)）
  tucao内容储存优化，使用cPickle库
  工程模块化重构
  群成员外号表</description>
    </item>
    
    <item>
      <title>煎蛋无聊图排行生成器</title>
      <link>https://yinzo.github.io/posts/%E7%85%8E%E8%9B%8B%E6%97%A0%E8%81%8A%E5%9B%BE%E6%8E%92%E8%A1%8C%E7%94%9F%E6%88%90%E5%99%A8/</link>
      <pubDate>Wed, 14 Jan 2015 17:41:00 +0800</pubDate>
      
      <guid>https://yinzo.github.io/posts/%E7%85%8E%E8%9B%8B%E6%97%A0%E8%81%8A%E5%9B%BE%E6%8E%92%E8%A1%8C%E7%94%9F%E6%88%90%E5%99%A8/</guid>
      <description>煎蛋无聊图排行生成器 Github点这里以下是readme
  beautifulsoup4  python jandan_pic_ranker.py
之后按照提示输入即可将排行榜页面生成至当前目录
 自动存档功能：首次使用会将目标页面保存至本地，下一次统计该页面时将自动调用存档 多模式可选：无聊图、妹子图、（即将加入nsfw）  </description>
    </item>
    
    <item>
      <title>给你的 Django1.7 添加 favicon</title>
      <link>https://yinzo.github.io/posts/%E7%BB%99%E4%BD%A0%E7%9A%84-django1.7-%E6%B7%BB%E5%8A%A0-favicon/</link>
      <pubDate>Tue, 16 Dec 2014 20:51:00 +0800</pubDate>
      
      <guid>https://yinzo.github.io/posts/%E7%BB%99%E4%BD%A0%E7%9A%84-django1.7-%E6%B7%BB%E5%8A%A0-favicon/</guid>
      <description>给你的 Django1.7 添加 favicon url(r&#39;^favicon\.ico$&#39;, &#39;django.views.generic.simple.redirect_to&#39;, {&#39;url&#39;: &#39;/static/images/favicon.ico&#39;}),  对于Django1.6以后的版本，django.views.generic.simple这个类已经不存在了，取而代之的是django.views.generic.base这个类中的RedirectView这个方法。
所以，对于新的方法，我们可以这么写
(r&#39;^favicon\.ico/$&#39;, RedirectView.as_view(url=&#39;/static/images/favicon.ico&#39;)),  如果你不喜欢这样，还可以使用第二种方法。
在views.py中这样写一个新方法
from django.shortcuts import redirect …… def favicon_redirect(request): return redirect(&#39;/static/images/favicon.ico&#39;)  之后，在urls.py中对于favicon.ico的请求调用这一函数就好了。
如果出现favicon的500错误，你需要在浏览器中直接访问 /favicon.ico 才能看到具体错误内容;D。</description>
    </item>
    
    <item>
      <title>通过 CSS 修改 webkit 浏览器滚动条样式</title>
      <link>https://yinzo.github.io/posts/%E9%80%9A%E8%BF%87-css-%E4%BF%AE%E6%94%B9-webkit-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%A0%B7%E5%BC%8F/</link>
      <pubDate>Mon, 15 Dec 2014 21:01:00 +0800</pubDate>
      
      <guid>https://yinzo.github.io/posts/%E9%80%9A%E8%BF%87-css-%E4%BF%AE%E6%94%B9-webkit-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%A0%B7%E5%BC%8F/</guid>
      <description>通过 CSS 修改 webkit 浏览器滚动条样式  ::-webkit-scrollbar 滚动条整体部分，可以设置宽度啥的 ::-webkit-scrollbar-button 滚动条两端的按钮 ::-webkit-scrollbar-track 外层轨道 ::-webkit-scrollbar-track-piece 内层滚动槽 ::-webkit-scrollbar-thumb 滚动的滑块 ::-webkit-scrollbar-corner 边角 ::-webkit-resizer 定义右下角拖动块的样式  上面是滚动条的主要几个设置属性，还有更详尽的CSS属性
:horizontal 水平方向的滚动条
:vertical 垂直 方向的滚动条
:decrement 应用于按钮和内层轨道(track piece)。它用来指示按钮或者内层轨道是否会减小视窗的位置(比如，垂直滚动条的上面，水平滚动条的左边。)
:increment 与decrement类似，用来指示按钮或内层轨道是否会增大视窗的位置(比如，垂直滚动条的下面和水平滚动条的右边。)
:start 伪类也应用于按钮和滑块。它用来定义对象是否放到滑块的前面。
:end 类似于start伪类，标识对象是否放到滑块的后面。
:double-button 该伪类以用于按钮和内层轨道。用于判断一个按钮是不是放在滚动条同一端的一对按钮中的一个。对于内层轨道来说，它表示内层轨道是否紧靠一对按钮。
:single-button 类似于double-button伪类。对按钮来说，它用于判断一个按钮是否自己独立的在滚动条的一段。对内层轨道来说，它表示内层轨道是否紧靠一个single-button。
:no-button 用于内层轨道，表示内层轨道是否要滚动到滚动条的终端，比如，滚动条两端没有按钮的时候。
:corner-present 用于所有滚动条轨道，指示滚动条圆角是否显示。
:window-inactive 用于所有的滚动条轨道，指示应用滚动条的某个页面容器(元素)是否当前被激活。(在webkit最近的版本中，该伪类也可以用于::selection伪元素。webkit团队有计划扩展它并推动成为一个标准的伪类)
以下是我的滚动条样式代码
::-webkit-scrollbar { height:5px; width: 5px; background-color: white; } ::-webkit-scrollbar-thumb { width:5px; background-color: rgb(0, 167, 255); box-shadow: 0 0 5px rgb(0, 167, 255); border-radius: 20px; transition: box-shadow 0.</description>
    </item>
    
    <item>
      <title>为你的 Django 博客添加 Disqus 评论系统</title>
      <link>https://yinzo.github.io/posts/%E4%B8%BA%E4%BD%A0%E7%9A%84-django-%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0-disqus-%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Mon, 15 Dec 2014 15:59:00 +0800</pubDate>
      
      <guid>https://yinzo.github.io/posts/%E4%B8%BA%E4%BD%A0%E7%9A%84-django-%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0-disqus-%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/</guid>
      <description>为你的 Django 博客添加 Disqus 评论系统  安装 Disqus ,依官方推荐，使用pip自动安装~
若是没有 pip 也不用着急，去官方下载一份二进制包，然后解压，进入目录安装
 修改 setting.py ,在 INSTALLED_APPS 中添加 disqus 项并在文件末尾添加两项参数。其中一项就是刚才复制的KEY啦。
 通过Django Shell 执行以下命令。恩里面的domain和name改成你自己的就好啦。
我自己在这一步遇到了一个错误，执行Site.objects.all()的时候报错，提示
这是由于没有安装django.sites模块造成的。
只需要在 INSTALLED_APPS 中添加这一模块然后 syncdb就好了。
 修改模板文件，在指定位置添加 Disqus
其中第一项必选，加载 disqus ，第二至第四项可选。
后三项分别是
 显示评论 显示评论数 显示最近评论。  其中显示评论数是通过JS修改含data-disqus-identifier=“{{ object.id }}&amp;ldquo;属性的标签来显示的。所以记得加上哦。以上，就是 Disqus 的安装啦</description>
    </item>
    
    <item>
      <title>Django自定义 Markdown 过滤器</title>
      <link>https://yinzo.github.io/posts/django%E8%87%AA%E5%AE%9A%E4%B9%89-markdown-%E8%BF%87%E6%BB%A4%E5%99%A8/</link>
      <pubDate>Mon, 15 Dec 2014 14:05:00 +0800</pubDate>
      
      <guid>https://yinzo.github.io/posts/django%E8%87%AA%E5%AE%9A%E4%B9%89-markdown-%E8%BF%87%E6%BB%A4%E5%99%A8/</guid>
      <description>Django自定义 Markdown 过滤器 附 my_markdown.py 代码
from django import template from markdown import markdown register = template.Library() @register.filter(name=&#39;my_markdown&#39;) def my_markdown(value): return markdown(value) </description>
    </item>
    
    <item>
      <title>Django前端输入中文后MySQL出现中文乱码</title>
      <link>https://yinzo.github.io/posts/django%E5%89%8D%E7%AB%AF%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E5%90%8Emysql%E5%87%BA%E7%8E%B0%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</link>
      <pubDate>Mon, 15 Dec 2014 00:20:00 +0800</pubDate>
      
      <guid>https://yinzo.github.io/posts/django%E5%89%8D%E7%AB%AF%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E5%90%8Emysql%E5%87%BA%E7%8E%B0%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</guid>
      <description>Django前端输入中文后MySQL出现中文乱码 注：需完全一致，当初我数据库用的是 gbk , django 用的 utf8 结果依然是乱码，统一成 utf8 后就好了。
附: MySQL 控制台修改字符集
首先查看当前 MySQL 字符集
mysql&amp;amp;gt; show variables like &#39;char%&#39;; +--------------------------+----------------------------+ | Variable_name | Value | +--------------------------+----------------------------+ | character_set_client | gbk | | character_set_connection | gbk | | character_set_database | utf8 | | character_set_filesystem | binary | | character_set_results | gbk | | character_set_server | utf8 | | character_set_system | utf8 | | character_sets_dir | /usr/share/mysql/charsets/ | +--------------------------+----------------------------+ 8 rows in set (0.</description>
    </item>
    
    <item>
      <title>Django的过滤器们</title>
      <link>https://yinzo.github.io/posts/django%E7%9A%84%E8%BF%87%E6%BB%A4%E5%99%A8%E4%BB%AC/</link>
      <pubDate>Mon, 15 Dec 2014 00:02:00 +0800</pubDate>
      
      <guid>https://yinzo.github.io/posts/django%E7%9A%84%E8%BF%87%E6%BB%A4%E5%99%A8%E4%BB%AC/</guid>
      <description>Django的过滤器们 {{ my_text|escape|linebreaks }} 串联：先转义文本到HTML，再转换每行到
标签
{{ bio | truncatewords:“30” }} 显示前30个字
{{ 123|add:“5” }} 给value加上一个数值
{{ “AB&amp;rsquo;CD”|addslashes }} 单引号加上转义号，一般用于输出到javascript中
{{ “abcd”|capfirst }} 第一个字母大写
{{ “abcd”|center:“50” }} 输出指定长度的字符串，并把值对中
{{ “123spam456spam789”|cut:“spam” }} 查找删除指定字符串
{{ value|date:“F j, Y” }} 格式化日期
{{ value|default:“(N/A)” }} 值不存在，使用指定值
{{ value|default_if_none:“(N/A)” }} 值是None，使用指定值
{{ 列表变量|dictsort:“数字” }} 排序从小到大
{{ 列表变量|dictsortreversed:“数字” }} 排序从大到小
{% if 92|divisibleby:“2” %} 判断是否整除指定数字
{{ string|escape }} 转换为html实体
{{ 21984124|filesizeformat }} 以1024为基数，计算最大值，保留1位小数，增加可读性
{{ list|first }} 返回列表第一个元素</description>
    </item>
    
    <item>
      <title>解决OSX升级10.10后无法开启MAMP Apache服务</title>
      <link>https://yinzo.github.io/posts/%E8%A7%A3%E5%86%B3osx%E5%8D%87%E7%BA%A710.10%E5%90%8E%E6%97%A0%E6%B3%95%E5%BC%80%E5%90%AFmamp-apache%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Sun, 14 Dec 2014 21:26:00 +0800</pubDate>
      
      <guid>https://yinzo.github.io/posts/%E8%A7%A3%E5%86%B3osx%E5%8D%87%E7%BA%A710.10%E5%90%8E%E6%97%A0%E6%B3%95%E5%BC%80%E5%90%AFmamp-apache%E6%9C%8D%E5%8A%A1/</guid>
      <description>解决OSX升级10.10后无法开启MAMP Apache服务 再次打开MAMP即可开启Apache.
原文</description>
    </item>
    
  </channel>
</rss>